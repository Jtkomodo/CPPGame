; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28315.0 

	TITLE	D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__BD3EDE1B_vcruntime_new@h DB 01H
__09340588_corecrt_math@h DB 01H
__24E9E95F_stdlib@h DB 01H
__EC2FBCF1_cstdlib DB 01H
__C0436A37_cmath DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__4877352E_type_traits DB 01H
__B0C4CEA9_malloc@h DB 01H
__CFCEF810_vcruntime_exception@h DB 01H
__CB7CF65A_exception DB 01H
__367CC694_corecrt_memcpy_s@h DB 01H
__35D7DDB3_corecrt_memory@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__5467428D_corecrt_wconio@h DB 01H
__4442441F_corecrt_wio@h DB 01H
__45F4AF76_corecrt_wtime@h DB 01H
__186FF47F_stat@h DB 01H
__534C724A_wchar@h DB 01H
__CDF80030_limits DB 01H
__45864D8F_xutility DB 01H
__B1B75AB9_xmemory DB 01H
__C564DC25_xstring DB 01H
__4232CC07_stdexcept DB 01H
__34C7AB85_xcall_once@h DB 01H
__8B9AB9A5_system_error DB 01H
__60622685_vcruntime_typeinfo@h DB 01H
__3559BE96_typeinfo DB 01H
__71560CBE_memory DB 01H
__5D135BB1_xfacet DB 01H
__7242C389_ctype@h DB 01H
__2AD05D5E_xlocinfo DB 01H
__1A5AA814_xlocale DB 01H
__13352A4D_xiosbase DB 01H
__84DDCE03_xlocnum DB 01H
__735DEEF4_ios DB 01H
__8FA2E757_func_common@inl DB 01H
__D01632FC_Model@h DB 01H
__920B0093_Model@cpp DB 01H
__805570D0_vector DB 01H
__6A9A47EA_istream DB 01H
__094A72D0_ostream DB 01H
__409274BB_streambuf DB 01H
__0111D5B6_iosfwd DB 01H
__DB22397A_utility DB 01H
__2C3DAE68_xstddef DB 01H
__C1707A8C_xatomic@h DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z ; Model::Model
PUBLIC	?Draw@Model@@QAEXXZ				; Model::Draw
PUBLIC	??1Model@@QAE@XZ				; Model::~Model
PUBLIC	?enableAtrib@Model@@AAEXXZ			; Model::enableAtrib
PUBLIC	?deallocate@?$allocator@U?$vec@$02M$0A@@glm@@@std@@QAEXQAU?$vec@$02M$0A@@glm@@I@Z ; std::allocator<glm::vec<3,float,0> >::deallocate
PUBLIC	??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
PUBLIC	?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::size
PUBLIC	??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::operator[]
PUBLIC	?_Destroy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02M$0A@@glm@@0@Z ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Destroy
PUBLIC	?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Tidy
PUBLIC	?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<3,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,float,0> > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$vec@$01M$0A@@glm@@@std@@QAEXQAU?$vec@$01M$0A@@glm@@I@Z ; std::allocator<glm::vec<2,float,0> >::deallocate
PUBLIC	??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::~vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >
PUBLIC	?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::size
PUBLIC	??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::operator[]
PUBLIC	?_Destroy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$01M$0A@@glm@@0@Z ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Destroy
PUBLIC	?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Tidy
PUBLIC	?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<2,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<2,float,0> > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$vec@$02I$0A@@glm@@@std@@QAEXQAU?$vec@$02I$0A@@glm@@I@Z ; std::allocator<glm::vec<3,unsigned int,0> >::deallocate
PUBLIC	??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::~vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >
PUBLIC	?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::size
PUBLIC	??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::operator[]
PUBLIC	?_Destroy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02I$0A@@glm@@0@Z ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Destroy
PUBLIC	?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Tidy
PUBLIC	?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<3,unsigned int,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,unsigned int,0> > >,1>::_Get_first
PUBLIC	??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,unsigned int,0> >
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<2,float,0> >
PUBLIC	??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,float,0> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<3,unsigned int,0> > >
PUBLIC	??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<2,float,0> > >
PUBLIC	??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<3,float,0> > >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1OM@DMFHHJDE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1NA@NNOGIJCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1NA@FAFFEPED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ ; `string'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__glDrawElements@16:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___glewBindBuffer:DWORD
EXTRN	___glewBufferData:DWORD
EXTRN	___glewGenBuffers:DWORD
EXTRN	___glewEnableVertexAttribArray:DWORD
EXTRN	___glewVertexAttribPointer:DWORD
EXTRN	___glewBindVertexArray:DWORD
EXTRN	___glewDeleteVertexArrays:DWORD
EXTRN	___glewGenVertexArrays:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1NA@FAFFEPED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1NA@FAFFEPED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'l', 00H, 'm', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, '<', 00H, '3', 00H, ',', 00H, 'f', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 't', 00H, ',', 00H, '0', 00H, '>', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, 'g', 00H, 'l', 00H, 'm', 00H, ':', 00H, ':', 00H
	DB	'v', 00H, 'e', 00H, 'c', 00H, '<', 00H, '3', 00H, ',', 00H, 'f'
	DB	00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, ',', 00H, '0', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@NNOGIJCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1NA@NNOGIJCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'l', 00H, 'm', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, '<', 00H, '2', 00H, ',', 00H, 'f', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 't', 00H, ',', 00H, '0', 00H, '>', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, 'g', 00H, 'l', 00H, 'm', 00H, ':', 00H, ':', 00H
	DB	'v', 00H, 'e', 00H, 'c', 00H, '<', 00H, '2', 00H, ',', 00H, 'f'
	DB	00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, ',', 00H, '0', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OM@DMFHHJDE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1OM@DMFHHJDE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'l', 00H, 'm', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, '<', 00H, '3', 00H, ',', 00H, 'u', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, ',', 00H, '0', 00H, '>', 00H, ',', 00H
	DB	'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H
	DB	't', 00H, ' ', 00H, 'g', 00H, 'l', 00H, 'm', 00H, ':', 00H, ':'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, '<', 00H, '3', 00H, ',', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ',', 00H
	DB	'0', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':'
	DB	00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '4', 00H, '.', 00H, '2', 00H, '8', 00H, '3', 00H
	DB	'1', 00H, '4', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.24.28314\include\vector', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '4', 00H, '.', 00H, '2', 00H, '8', 00H, '3', 00H
	DB	'1', 00H, '4', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.24.28314\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 06aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Model@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$3
__ehfuncinfo$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 667  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 994  : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 995  :     // deallocate a plain pointer using an allocator
; 996  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 997  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 998  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 999  :     } else {
; 1000 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1001 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1002 :     }
; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z PROC ; std::_Destroy_range<std::allocator<glm::vec<3,float,0> > >, COMDAT

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<glm::vec<3,float,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z PROC ; std::_Destroy_range<std::allocator<glm::vec<2,float,0> > >, COMDAT

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<glm::vec<2,float,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z PROC ; std::_Destroy_range<std::allocator<glm::vec<3,unsigned int,0> > >, COMDAT

; 940  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 941  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 942  :     using _Ty = typename _Alloc::value_type;
; 943  :     if
; 944  :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 945  :             (void) _First;
; 946  :             (void) _Last;
; 947  :             (void) _Al;
; 948  :         }
; 949  :     else {
; 950  :         for (; _First != _Last; ++_First) {
; 951  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 952  :         }
; 953  :     }
; 954  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<glm::vec<3,unsigned int,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 187  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 196  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,float,0> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,float,0> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<2,float,0> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<2,float,0> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1022 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1023 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1024 :     using _Ty = typename _Alloc::value_type;
; 1025 :     _Ptr->~_Ty();
; 1026 :     _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1027 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 569  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 570  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 571  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 572  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,unsigned int,0> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,unsigned int,0> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<glm::vec<3,unsigned int,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,unsigned int,0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<glm::vec<3,unsigned int,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,unsigned int,0> > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1736 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02I$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<3,unsigned int,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,unsigned int,0> > >,1>::_Get_first

; 1737 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Tidy, COMDAT
; _this$ = ecx

; 1689 :     void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1690 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1691 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1692 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1693 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1694 : 
; 1695 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1696 : 
; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 1698 :             _Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02I$0A@@glm@@0@Z ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Destroy

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@U?$vec@$02I$0A@@glm@@@std@@QAEXQAU?$vec@$02I$0A@@glm@@I@Z ; std::allocator<glm::vec<3,unsigned int,0> >::deallocate

; 1700 : 
; 1701 :             _Myfirst = pointer();

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 1702 :             _Mylast  = pointer();

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 1703 :             _Myend   = pointer();

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 1704 :         }
; 1705 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Destroy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02I$0A@@glm@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02I$0A@@glm@@0@Z PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Destroy, COMDAT
; _this$ = ecx

; 1614 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02I$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02I$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<3,unsigned int,0> > >
	add	esp, 12					; 0000000cH

; 1616 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02I$0A@@glm@@0@Z ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Pos$ = 8						; size = 4
??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::operator[], COMDAT
; _this$ = ecx

; 1498 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1499 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1500 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1501 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1OM@DMFHHJDE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1502 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");

	xor	eax, eax
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1503 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1504 : 
; 1505 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 12
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1506 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::size, COMDAT
; _this$ = ecx

; 1483 :     _NODISCARD size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1484 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 1486 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -252						; size = 4
_$S1$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ PROC ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::~vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >, COMDAT
; _this$ = ecx

; 673  :     ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 674  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Tidy

; 675  : #if _ITERATOR_DEBUG_LEVEL != 0
; 676  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02I$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??$?0U?$vec@$02I$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02I$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,unsigned int,0> >
	lea	eax, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 677  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 678  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 679  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ ENDP ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::~vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$vec@$02I$0A@@glm@@@std@@QAEXQAU?$vec@$02I$0A@@glm@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$vec@$02I$0A@@glm@@@std@@QAEXQAU?$vec@$02I$0A@@glm@@I@Z PROC ; std::allocator<glm::vec<3,unsigned int,0> >::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$vec@$02I$0A@@glm@@@std@@QAEXQAU?$vec@$02I$0A@@glm@@I@Z ENDP ; std::allocator<glm::vec<3,unsigned int,0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<glm::vec<2,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<2,float,0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<glm::vec<2,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<2,float,0> > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1736 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$01M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<2,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<2,float,0> > >,1>::_Get_first

; 1737 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Tidy, COMDAT
; _this$ = ecx

; 1689 :     void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1690 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1691 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1692 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1693 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1694 : 
; 1695 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1696 : 
; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 1698 :             _Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$01M$0A@@glm@@0@Z ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Destroy

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 3
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@U?$vec@$01M$0A@@glm@@@std@@QAEXQAU?$vec@$01M$0A@@glm@@I@Z ; std::allocator<glm::vec<2,float,0> >::deallocate

; 1700 : 
; 1701 :             _Myfirst = pointer();

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 1702 :             _Mylast  = pointer();

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 1703 :             _Myend   = pointer();

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 1704 :         }
; 1705 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Destroy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$01M$0A@@glm@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$01M$0A@@glm@@0@Z PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Destroy, COMDAT
; _this$ = ecx

; 1614 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$01M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$01M$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<2,float,0> > >
	add	esp, 12					; 0000000cH

; 1616 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$01M$0A@@glm@@0@Z ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Pos$ = 8						; size = 4
??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::operator[], COMDAT
; _this$ = ecx

; 1498 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1499 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1500 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1501 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	cmp	DWORD PTR __Pos$[ebp], edx
	jae	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1NA@NNOGIJCF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1502 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");

	xor	eax, eax
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1503 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1504 : 
; 1505 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 1506 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::size, COMDAT
; _this$ = ecx

; 1483 :     _NODISCARD size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1484 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 1486 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -252						; size = 4
_$S2$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ PROC ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::~vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >, COMDAT
; _this$ = ecx

; 673  :     ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 674  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Tidy

; 675  : #if _ITERATOR_DEBUG_LEVEL != 0
; 676  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$01M$0A@@glm@@@2@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S2$[ebp]
	call	??$?0U?$vec@$01M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$01M$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<2,float,0> >
	lea	eax, DWORD PTR _$S2$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 677  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 678  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 679  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	50					; 00000032H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ ENDP ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::~vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$vec@$01M$0A@@glm@@@std@@QAEXQAU?$vec@$01M$0A@@glm@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$vec@$01M$0A@@glm@@@std@@QAEXQAU?$vec@$01M$0A@@glm@@I@Z PROC ; std::allocator<glm::vec<2,float,0> >::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$vec@$01M$0A@@glm@@@std@@QAEXQAU?$vec@$01M$0A@@glm@@I@Z ENDP ; std::allocator<glm::vec<2,float,0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<glm::vec<3,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,float,0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<glm::vec<3,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,float,0> > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1736 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$vec@$02M$0A@@glm@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::vec<3,float,0> >,std::_Vector_val<std::_Simple_types<glm::vec<3,float,0> > >,1>::_Get_first

; 1737 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Tidy, COMDAT
; _this$ = ecx

; 1689 :     void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1690 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1691 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 1692 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 1693 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 1694 : 
; 1695 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1696 : 
; 1697 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 1698 :             _Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02M$0A@@glm@@0@Z ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Destroy

; 1699 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@U?$vec@$02M$0A@@glm@@@std@@QAEXQAU?$vec@$02M$0A@@glm@@I@Z ; std::allocator<glm::vec<3,float,0> >::deallocate

; 1700 : 
; 1701 :             _Myfirst = pointer();

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 1702 :             _Mylast  = pointer();

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 1703 :             _Myend   = pointer();

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 1704 :         }
; 1705 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?_Destroy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02M$0A@@glm@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02M$0A@@glm@@0@Z PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Destroy, COMDAT
; _this$ = ecx

; 1614 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1615 :         _Destroy_range(_First, _Last, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@YAXPAU?$vec@$02M$0A@@glm@@QAU12@AAV?$allocator@U?$vec@$02M$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::vec<3,float,0> > >
	add	esp, 12					; 0000000cH

; 1616 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXPAU?$vec@$02M$0A@@glm@@0@Z ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Pos$ = 8						; size = 4
??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::operator[], COMDAT
; _this$ = ecx

; 1498 :     _NODISCARD _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1499 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1500 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1501 :         _STL_VERIFY(

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	mov	esi, esp
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_0GH@GEBGMJJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	mov	esi, esp
	push	0
	push	1502					; 000005deH
	push	OFFSET ??_C@_1MO@NIHBFLCG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1NA@FAFFEPED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1502 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");

	xor	eax, eax
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 1503 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1504 : 
; 1505 :         return _My_data._Myfirst[_Pos];

	imul	eax, DWORD PTR __Pos$[ebp], 12
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1506 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::size, COMDAT
; _this$ = ecx

; 1483 :     _NODISCARD size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1484 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1485 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 1486 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -252						; size = 4
_$S3$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ PROC ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >, COMDAT
; _this$ = ecx

; 673  :     ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4

; 674  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEXXZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Tidy

; 675  : #if _ITERATOR_DEBUG_LEVEL != 0
; 676  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@AAEAAV?$allocator@U?$vec@$02M$0A@@glm@@@2@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S3$[ebp]
	call	??$?0U?$vec@$02M$0A@@glm@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$vec@$02M$0A@@glm@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><glm::vec<3,float,0> >
	lea	eax, DWORD PTR _$S3$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 677  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 678  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 679  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@vector:
	DD	1
	DD	$LN5@vector
$LN5@vector:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	51					; 00000033H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ENDP ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$vec@$02M$0A@@glm@@@std@@QAEXQAU?$vec@$02M$0A@@glm@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$vec@$02M$0A@@glm@@@std@@QAEXQAU?$vec@$02M$0A@@glm@@I@Z PROC ; std::allocator<glm::vec<3,float,0> >::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$vec@$02M$0A@@glm@@@std@@QAEXQAU?$vec@$02M$0A@@glm@@I@Z ENDP ; std::allocator<glm::vec<3,float,0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ?enableAtrib@Model@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?enableAtrib@Model@@AAEXXZ PROC				; Model::enableAtrib, COMDAT
; _this$ = ecx

; 72   : void Model::enableAtrib() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 73   : 	glEnableVertexAttribArray(0);//enabling vertex attrib

	mov	esi, esp
	push	0
	call	DWORD PTR ___glewEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   :     glEnableVertexAttribArray(1);//enabling vertex attrib

	mov	esi, esp
	push	1
	call	DWORD PTR ___glewEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 75   : 	glEnableVertexAttribArray(2);//enabling vertex attrib

	mov	esi, esp
	push	2
	call	DWORD PTR ___glewEnableVertexAttribArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 76   : 
; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?enableAtrib@Model@@AAEXXZ ENDP				; Model::enableAtrib
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ??1Model@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1Model@@QAE@XZ PROC					; Model::~Model, COMDAT
; _this$ = ecx

; 84   : Model::~Model() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Model@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 85   : 	glDeleteVertexArrays(1, &VAO_ID);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewDeleteVertexArrays
	cmp	esi, esp
	call	__RTC_CheckEsp

; 86   : 	
; 87   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Model@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Model@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Model@@QAE@XZ ENDP					; Model::~Model
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ?Draw@Model@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Draw@Model@@QAEXXZ PROC				; Model::Draw, COMDAT
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 63   : 	glBindVertexArray(VAO_ID);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR ___glewBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 64   : 	glDrawElements(GL_TRIANGLES,Model::drawCount,GL_UNSIGNED_INT,0);

	mov	esi, esp
	push	0
	push	5125					; 00001405H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	4
	call	DWORD PTR __imp__glDrawElements@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 65   : 
; 66   : 
; 67   : 
; 68   : 
; 69   : 
; 70   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Draw@Model@@QAEXXZ ENDP				; Model::Draw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_verts$ = 8						; size = 16
_uvs$ = 24						; size = 16
_normals$ = 40						; size = 16
_inds$ = 56						; size = 16
??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z PROC ; Model::Model, COMDAT
; _this$ = ecx

; 7    : Model::Model(std::vector<glm::vec3> verts, std::vector<glm::vec2> uvs, std::vector<glm::vec3> normals, std::vector<glm::uvec3> inds) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 8    : 
; 9    : 	//defing buffers to load values in
; 10   : 	glGenVertexArrays(1, &VAO_ID);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewGenVertexArrays
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11   : 	glBindVertexArray(VAO_ID);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR ___glewBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12   : 
; 13   : 	Model::drawCount =inds.size()*3;

	lea	ecx, DWORD PTR _inds$[ebp]
	call	?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::size
	imul	eax, eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 14   : 	//std::cout <<ind[6]<< std::endl;
; 15   : 	glGenBuffers(1, &VertI);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16   : 	glGenBuffers(1, &UVI);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17   : 	glGenBuffers(1, &INDI);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18   : 	glGenBuffers(1, &NORMALSI);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR ___glewGenBuffers
	cmp	esi, esp
	call	__RTC_CheckEsp

; 19   : 
; 20   : 	enableAtrib();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?enableAtrib@Model@@AAEXXZ		; Model::enableAtrib

; 21   : 
; 22   : 	//loading values into buffers 
; 23   : 	glBindBuffer(GL_ARRAY_BUFFER, VertI);//binding buffer

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ___glewBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 24   : 	glBufferData(GL_ARRAY_BUFFER, verts.size() * sizeof(glm::vec3), &verts[0], GL_STATIC_DRAW);//loading data

	mov	esi, esp
	push	35044					; 000088e4H
	push	0
	lea	ecx, DWORD PTR _verts$[ebp]
	call	??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::operator[]
	push	eax
	lea	ecx, DWORD PTR _verts$[ebp]
	call	?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::size
	imul	eax, eax, 12
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR ___glewBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 25   : 	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);//defing the vertex atrib

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	push	0
	call	DWORD PTR ___glewVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 26   : 
; 27   : 
; 28   : // loading values into buffers
; 29   : 	glBindBuffer(GL_ARRAY_BUFFER, UVI);//binding buffer

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ___glewBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   : 	glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &uvs[0], GL_STATIC_DRAW);//loading data

	mov	esi, esp
	push	35044					; 000088e4H
	push	0
	lea	ecx, DWORD PTR _uvs$[ebp]
	call	??A?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$01M$0A@@glm@@I@Z ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::operator[]
	push	eax
	lea	ecx, DWORD PTR _uvs$[ebp]
	call	?size@?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::size
	shl	eax, 3
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR ___glewBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 31   : 	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);//defing the vertex atrib

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	2
	push	1
	call	DWORD PTR ___glewVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 32   : 
; 33   : 
; 34   : 	glBindBuffer(GL_ARRAY_BUFFER, NORMALSI);//binding buffer

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	34962					; 00008892H
	call	DWORD PTR ___glewBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 35   : 	glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &normals[0], GL_STATIC_DRAW);//loading data

	mov	esi, esp
	push	35044					; 000088e4H
	push	0
	lea	ecx, DWORD PTR _normals$[ebp]
	call	??A?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02M$0A@@glm@@I@Z ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::operator[]
	push	eax
	lea	ecx, DWORD PTR _normals$[ebp]
	call	?size@?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::size
	imul	eax, eax, 12
	push	eax
	push	34962					; 00008892H
	call	DWORD PTR ___glewBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 36   : 	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, 0);//defing the vertex atrib

	mov	esi, esp
	push	0
	push	0
	push	0
	push	5126					; 00001406H
	push	3
	push	2
	call	DWORD PTR ___glewVertexAttribPointer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 37   : 
; 38   : 
; 39   : 
; 40   : 
; 41   : 
; 42   : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, INDI);//binding buffer

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	34963					; 00008893H
	call	DWORD PTR ___glewBindBuffer
	cmp	esi, esp
	call	__RTC_CheckEsp

; 43   : 	glBufferData(GL_ELEMENT_ARRAY_BUFFER, inds.size()* sizeof(glm::uvec3),&inds[0], GL_STATIC_DRAW);//loading data

	mov	esi, esp
	push	35044					; 000088e4H
	push	0
	lea	ecx, DWORD PTR _inds$[ebp]
	call	??A?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAEAAU?$vec@$02I$0A@@glm@@I@Z ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::operator[]
	push	eax
	lea	ecx, DWORD PTR _inds$[ebp]
	call	?size@?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QBEIXZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::size
	imul	eax, eax, 12
	push	eax
	push	34963					; 00008893H
	call	DWORD PTR ___glewBufferData
	cmp	esi, esp
	call	__RTC_CheckEsp

; 44   : 	glBindVertexArray(0);

	mov	esi, esp
	push	0
	call	DWORD PTR ___glewBindVertexArray
	cmp	esi, esp
	call	__RTC_CheckEsp

; 45   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _verts$[ebp]
	call	??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _uvs$[ebp]
	call	??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::~vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _normals$[ebp]
	call	??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inds$[ebp]
	call	??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::~vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR _inds$[ebp]
	jmp	??1?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >::~vector<glm::vec<3,unsigned int,0>,std::allocator<glm::vec<3,unsigned int,0> > >
__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$1:
	lea	ecx, DWORD PTR _normals$[ebp]
	jmp	??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$2:
	lea	ecx, DWORD PTR _uvs$[ebp]
	jmp	??1?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >::~vector<glm::vec<2,float,0>,std::allocator<glm::vec<2,float,0> > >
__unwindfunclet$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z$3:
	lea	ecx, DWORD PTR _verts$[ebp]
	jmp	??1?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@QAE@XZ ; std::vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >::~vector<glm::vec<3,float,0>,std::allocator<glm::vec<3,float,0> > >
__ehhandler$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Model@@QAE@V?$vector@U?$vec@$02M$0A@@glm@@V?$allocator@U?$vec@$02M$0A@@glm@@@std@@@std@@V?$vector@U?$vec@$01M$0A@@glm@@V?$allocator@U?$vec@$01M$0A@@glm@@@std@@@2@0V?$vector@U?$vec@$02I$0A@@glm@@V?$allocator@U?$vec@$02I$0A@@glm@@@std@@@2@@Z ENDP ; Model::Model
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$2 = -48						; size = 4
__Lock$3 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1201 : inline void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1202 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1203 :     if (_Myproxy) { // proxy allocated, drain it

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_all

; 1204 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1205 : 
; 1206 :         for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$2[ebp], ecx
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$2[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_all

; 1207 :             (*_Pnext)->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0

; 1208 :         }

	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1209 : 
; 1210 :         _Myproxy->_Myfirstiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 1211 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Orphan_all:

; 1212 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1213 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN7@Orphan_all
$LN7@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 106  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 107  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 108  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN7@Adjust_man
	jmp	SHORT $LN2@Adjust_man
$LN7@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN2@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN4@Adjust_man

; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN13@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN13@Adjust_man
	jmp	SHORT $LN8@Adjust_man
$LN13@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN8@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN10@Adjust_man

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax], ecx

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Model.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __920B0093_Model@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
