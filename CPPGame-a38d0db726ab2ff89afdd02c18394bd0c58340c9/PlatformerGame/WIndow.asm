; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28315.0 

	TITLE	D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?key_callback@@YAXPAUGLFWwindow@@HHHH@Z		; key_callback
PUBLIC	?callback@@3P6AXPAUGLFWwindow@@HHHH@ZA		; callback
msvcjmc	SEGMENT
__7242C389_ctype@h DB 01H
__90A1F774_basetsd@h DB 01H
__367CC694_corecrt_memcpy_s@h DB 01H
__35D7DDB3_corecrt_memory@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__3C23D660_guiddef@h DB 01H
__AF541008_winnt@h DB 01H
__0D001789_processthreadsapi@h DB 01H
__F972325D_memoryapi@h DB 01H
__76CD430D_winerror@h DB 01H
__737D49DB_winbase@h DB 01H
__1B9502AC_winuser@h DB 01H
__376EBCA0_winioctl@h DB 01H
__24E9E95F_stdlib@h DB 01H
__2CCBBE23_propidl@h DB 01H
__AD360DAF_oleauto@h DB 01H
__0396F1A5_stralign@h DB 01H
__BD3EDE1B_vcruntime_new@h DB 01H
__09340588_corecrt_math@h DB 01H
__EC2FBCF1_cstdlib DB 01H
__C0436A37_cmath DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__4877352E_type_traits DB 01H
__B0C4CEA9_malloc@h DB 01H
__CFCEF810_vcruntime_exception@h DB 01H
__CB7CF65A_exception DB 01H
__5467428D_corecrt_wconio@h DB 01H
__4442441F_corecrt_wio@h DB 01H
__45F4AF76_corecrt_wtime@h DB 01H
__186FF47F_stat@h DB 01H
__534C724A_wchar@h DB 01H
__CDF80030_limits DB 01H
__45864D8F_xutility DB 01H
__B1B75AB9_xmemory DB 01H
__C564DC25_xstring DB 01H
__4232CC07_stdexcept DB 01H
__34C7AB85_xcall_once@h DB 01H
__8B9AB9A5_system_error DB 01H
__60622685_vcruntime_typeinfo@h DB 01H
__3559BE96_typeinfo DB 01H
__71560CBE_memory DB 01H
__5D135BB1_xfacet DB 01H
__2AD05D5E_xlocinfo DB 01H
__1A5AA814_xlocale DB 01H
__13352A4D_xiosbase DB 01H
__84DDCE03_xlocnum DB 01H
__735DEEF4_ios DB 01H
__8FA2E757_func_common@inl DB 01H
__05858A22_string DB 01H
__66607376_tuple DB 01H
__5A557807_xbit_ops@h DB 01H
__AFECAA51_xhash DB 01H
__32190132_Window@h DB 01H
__0BC8076B_WIndow@cpp DB 01H
__32C29690_unordered_map DB 01H
__DE98524E_list DB 01H
__6A9A47EA_istream DB 01H
__094A72D0_ostream DB 01H
__409274BB_streambuf DB 01H
__0111D5B6_iosfwd DB 01H
__DB22397A_utility DB 01H
__2C3DAE68_xstddef DB 01H
__C1707A8C_xatomic@h DB 01H
__805570D0_vector DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
?callback@@3P6AXPAUGLFWwindow@@HHHH@ZA DD FLAT:?key_callback@@YAXPAUGLFWwindow@@HHHH@Z ; callback
_DATA	ENDS
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_ceilf
PUBLIC	?_Fnv1a_append_bytes@std@@YAIIQBEI@Z		; std::_Fnv1a_append_bytes
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z ; std::_Conditionally_enabled_hash<int,1>::operator()
PUBLIC	?_Do_hash@?$hash@H@std@@SAIABH@Z		; std::hash<int>::_Do_hash
PUBLIC	??0?$tuple@$$V@std@@QAE@XZ			; std::tuple<>::tuple<>
PUBLIC	??0?$tuple@$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	?_Floor_of_log_2@std@@YAKI@Z			; std::_Floor_of_log_2
PUBLIC	?_Ceiling_of_log_2@std@@YAKI@Z			; std::_Ceiling_of_log_2
PUBLIC	??0Window@@QAE@HHQBD@Z				; Window::Window
PUBLIC	?getWindow@Window@@QAEAAUGLFWwindow@@XZ		; Window::getWindow
PUBLIC	?getWidth@Window@@QAEHXZ			; Window::getWidth
PUBLIC	?getHeight@Window@@QAEHXZ			; Window::getHeight
PUBLIC	?Update@Window@@QAEXXZ				; Window::Update
PUBLIC	?Render@Window@@QAEXXZ				; Window::Render
PUBLIC	?clear@Window@@QAEXXZ				; Window::clear
PUBLIC	?Destroy@Window@@QAEXXZ				; Window::Destroy
PUBLIC	?SHouldExit@Window@@QAEEXZ			; Window::SHouldExit
PUBLIC	?checkState@Window@@SAEH@Z			; Window::checkState
PUBLIC	??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@H@std@@QBE_NABH0@Z		; std::equal_to<int>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
PUBLIC	??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>
PUBLIC	??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,unsigned char> >::allocator<std::pair<int const ,unsigned char> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEXQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
PUBLIC	??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::~list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_end
PUBLIC	?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::max_size
PUBLIC	?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_erase
PUBLIC	?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::~_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >
PUBLIC	??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
PUBLIC	??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
PUBLIC	??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::~unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
PUBLIC	?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::__autoclassinit2
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Try_emplace<int const &>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<int const ,unsigned char>,void *> >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator!=
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator++
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::__autoclassinit2
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >
PUBLIC	??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
PUBLIC	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > ><std::allocator<std::pair<int const ,unsigned char> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
PUBLIC	??$_Hash_representation@H@std@@YAIABH@Z		; std::_Hash_representation<int>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>
PUBLIC	??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> ><std::pair<int const ,unsigned char> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
PUBLIC	??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Find_last<int>
PUBLIC	??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> * &,bool,0>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ; std::forward_as_tuple<int const &>
PUBLIC	??0?$tuple@ABH@std@@QAE@$$QAV01@@Z		; std::tuple<int const &>::tuple<int const &>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
PUBLIC	??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>
PUBLIC	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>
PUBLIC	??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > ><std::pair<int const ,unsigned char> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$_Fnv1a_append_value@H@std@@YAIIABH@Z		; std::_Fnv1a_append_value<int>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
PUBLIC	??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??0?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Release
PUBLIC	??$_Emplace_back@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
PUBLIC	??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
PUBLIC	??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
PUBLIC	??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z ; std::addressof<std::pair<int const ,unsigned char> >
PUBLIC	??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::destroy<std::pair<int const ,unsigned char> >
PUBLIC	??$exchange@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@$$T@std@@YAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@QAV12@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z		; std::tuple<int const &>::tuple<int const &><int const &,0>
PUBLIC	??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::forward<std::tuple<int const &> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBHE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::construct<std::pair<int const ,unsigned char>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
PUBLIC	??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
PUBLIC	??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>
PUBLIC	??$?0ABH$$Z$$V@?$pair@$$CBHE@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><int const &>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z	; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
PUBLIC	??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHE@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><std::tuple<int const &>,std::tuple<>,0>
PUBLIC	??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::move<std::tuple<int const &> &>
PUBLIC	??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z	; std::get<0,int const &>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@2IB ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_buckets
PUBLIC	??_C@_07LIJFLNDM@problem@			; `string'
PUBLIC	??_C@_0GJ@PLLJCKNF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_1NC@HJDMEDPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp__glBlendFunc@8:PROC
EXTRN	__imp__glClear@4:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	_glewInit@0:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_glfwInit:PROC
EXTRN	_glfwTerminate:PROC
EXTRN	_glfwWindowHint:PROC
EXTRN	_glfwCreateWindow:PROC
EXTRN	_glfwDestroyWindow:PROC
EXTRN	_glfwWindowShouldClose:PROC
EXTRN	_glfwPollEvents:PROC
EXTRN	_glfwSetKeyCallback:PROC
EXTRN	_glfwMakeContextCurrent:PROC
EXTRN	_glfwSwapBuffers:PROC
EXTRN	_glfwSwapInterval:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__ceil:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A DB 028H DUP (?) ; keys
?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A DB 028H DUP (?) ; lastkeys
_BSS	ENDS
CRT$XCU	SEGMENT
?keys$initializer$@@3P6AXXZA DD FLAT:??__Ekeys@@YAXXZ	; keys$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
CONST	SEGMENT
??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@HJDMEDPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@HJDMEDPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '4', 00H, '.', 00H, '2', 00H, '8', 00H, '3', 00H
	DB	'1', 00H, '4', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@PLLJCKNF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GJ@PLLJCKNF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.24.28314\include\xutility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIJFLNDM@problem@
CONST	SEGMENT
??_C@_07LIJFLNDM@problem@ DB 'problem', 00H		; `string'
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@2IB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@2IB DD 08H ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '4', 00H, '.', 00H, '2', 00H, '8', 00H, '3', 00H
	DB	'1', 00H, '4', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.24.28314\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 06aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@_N@std@@YA$$QA_NAA_N@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Fnv1a_append_value@H@std@@YAIIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@M@std@@YA$$QAMAAM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$0
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$tuple@ABH@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABH@std@@YAABHABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z$0
__ehfuncinfo$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Max_value@I@std@@YAABIABI0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Hash_representation@H@std@@YAIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z$0
__ehfuncinfo$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z$0
__ehfuncinfo$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ$0
__ehfuncinfo$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Ceiling_of_log_2@std@@YAKI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Floor_of_log_2@std@@YAKI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$tuple@$$V@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$tuple@$$V@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Do_hash@?$hash@H@std@@SAIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Min_value@I@std@@YAABIABI0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Container_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Adopt@_Iterator_base0@std@@QAEXPBX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max@?$numeric_limits@H@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@QBDH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fnv1a_append_bytes@std@@YAIIQBEI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??2@YAPAXIPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?lastkeys$initializer$@@3P6AXXZA DD FLAT:??__Elastkeys@@YAXXZ ; lastkeys$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Tuple$ = 8						; size = 4
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z PROC	; std::get<0,int const &>, COMDAT

; 755  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 756  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 757  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 758  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	eax, DWORD PTR __Tuple$[ebp]
	mov	eax, DWORD PTR [eax]

; 759  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z ENDP	; std::get<0,int const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::move<std::tuple<int const &> &>, COMDAT

; 1438 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1440 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::move<std::tuple<int const &> &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHE@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHE@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><std::tuple<int const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 974  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::move<std::tuple<int const &> &>
	add	esp, 4
	push	eax
	call	??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z ; std::get<0,int const &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHE@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><std::tuple<int const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Arg$ = 8						; size = 4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z PROC		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>, COMDAT
; _this$ = ecx

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@ABH@std@@YAABHABH@Z		; std::forward<int const &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z ENDP		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 210  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0ABH$$Z$$V@?$pair@$$CBHE@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = -221						; size = 1
$T2 = -209						; size = 1
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABH$$Z$$V@?$pair@$$CBHE@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z PROC ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><int const &>, COMDAT
; _this$ = ecx

; 981  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>(), index_sequence_for<_Types2...>()) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR __Val2$[ebp]
	push	edx
	lea	eax, DWORD PTR __Val1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHE@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><std::tuple<int const &>,std::tuple<>,0>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$?0ABH$$Z$$V@?$pair@$$CBHE@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z PROC ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>, COMDAT
; _this$ = ecx

; 234  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
	mov	eax, DWORD PTR __This_arg$[ebp]
	push	eax
	call	??$forward@ABH@std@@YAABHABH@Z		; std::forward<int const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z ; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z ENDP ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], edx

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z PROC ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT

; 1054 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45864D8F_xutility
	call	@__CheckForDebuggerJustMyCode@4
$LN4@Verify_ran:

; 1055 :     // special case range verification for pointers
; 1056 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	ja	SHORT $LN7@Verify_ran
	jmp	SHORT $LN2@Verify_ran
$LN7@Verify_ran:
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1056					; 00000420H
	push	OFFSET ??_C@_0GJ@PLLJCKNF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@Verify_ran
	int	3
$LN11@Verify_ran:
	mov	esi, esp
	push	0
	push	1056					; 00000420H
	push	OFFSET ??_C@_1NC@HJDMEDPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
	push	OFFSET ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Verify_ran
$LN2@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN4@Verify_ran

; 1057 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ENDP ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 667  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> *>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBHE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::construct<std::pair<int const ,unsigned char>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT

; 670  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	push	ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _<_Args_2>$[ebp]
	push	ecx
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
	add	esp, 4
	push	eax
	mov	ecx, esi
	call	??0?$tuple@$$V@std@@QAE@ABV01@@Z	; std::tuple<>::tuple<>
	push	ecx
	mov	esi, esp
	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	call	??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::forward<std::tuple<int const &> >
	add	esp, 4
	push	eax
	mov	ecx, esi
	call	??0?$tuple@ABH@std@@QAE@$$QAV01@@Z	; std::tuple<int const &>::tuple<int const &>
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ; std::forward<std::piecewise_construct_t const &>
	add	esp, 4
	mov	cl, BYTE PTR [eax]
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??$?0ABH$$Z$$V@?$pair@$$CBHE@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,unsigned char>::pair<int const ,unsigned char><int const &>

; 671  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 672  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@U?$pair@$$CBHE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::construct<std::pair<int const ,unsigned char>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::forward<std::tuple<int const &> >, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::forward<std::tuple<int const &> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z PROC		; std::tuple<int const &>::tuple<int const &><int const &,0>, COMDAT
; _this$ = ecx

; 291  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	ecx, DWORD PTR __This_arg$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z ENDP		; std::tuple<int const &>::tuple<int const &><int const &,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@_N@std@@YA$$QA_NAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@_N@std@@YA$$QA_NAA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@_N@std@@YA$$QA_NAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser, COMDAT
; _this$ = ecx

; 1134 :         ~_Range_eraser() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1135 :             _List._Unchecked_erase(_First, _Next);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_erase

; 1136 :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Bump_erased, COMDAT
; _this$ = ecx

; 1130 :         void _Bump_erased() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1131 :             _Next = _Next->_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+8], eax

; 1132 :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Bump_erased
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__List_$ = 8						; size = 4
__First_$ = 12						; size = 4
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Range_eraser, COMDAT
; _this$ = ecx

; 1128 :             : _List(_List_), _First(_First_), _Next(_First_) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __List_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __First_$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __First_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Range_eraser
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>, COMDAT
; _this$ = ecx

; 179  :         noexcept(_Nothrow_compare<key_equal, _Keyty1, _Keyty2>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 180  :         // test if _Keyval1 NOT equal to _Keyval2
; 181  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	eax, DWORD PTR __Keyval2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
	mov	ecx, eax
	call	??R?$equal_to@H@std@@QBE_NABH0@Z	; std::equal_to<int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv74[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv74[ebp]

; 182  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::~_Clear_guard, COMDAT
; _this$ = ecx

; 516  :         ~_Clear_guard() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 517  :             if (_Target) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Clear_guar

; 518  :                 _Target->clear();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::clear
$LN3@Clear_guar:

; 519  :             }
; 520  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::~_Clear_guard
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@QAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Target_$ = 8						; size = 4
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@QAV12@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::_Clear_guard, COMDAT
; _this$ = ecx

; 511  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Target_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@QAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAABQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
	add	esp, 4
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$exchange@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@$$T@std@@YAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@$$T@std@@YAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::nullptr_t>, COMDAT

; 569  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 570  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 571  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 572  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@$$T@std@@YAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::destroy<std::pair<int const ,unsigned char> >, COMDAT

; 675  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 676  :         _Ptr->~_Uty();
; 677  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::destroy<std::pair<int const ,unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,unsigned char> >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<int const ,unsigned char>,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>, COMDAT
; _this$ = ecx

; 1427 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1428 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	call	??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@ABV12@@std@@YAXAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@ABV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
	add	esp, 8

; 1429 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1430 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Release, COMDAT
; _this$ = ecx

; 1432 :     _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1433 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1434 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1435 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>, COMDAT
; _this$ = ecx

; 1422 :     ~_Uninitialized_backout() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1423 :         _Destroy_range(_First, _Last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	add	esp, 8

; 1424 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
??0?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>, COMDAT
; _this$ = ecx

; 1415 :     explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT

; 1139 : _NODISCARD constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45864D8F_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 1140 :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 1141 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>, COMDAT

; 1080 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45864D8F_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 1081 :     // check that [_First, _Last) forms an iterator range
; 1082 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1083 :         _Verify_range(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Verify_range@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXQBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ; std::_Verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 8

; 1084 :     } else {
; 1085 :         (void) _First; // TRANSITION, VSO#486357
; 1086 :         (void) _Last; // TRANSITION, VSO#486357
; 1087 :     }
; 1088 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 87   : _DECLSPEC_ALLOCATOR void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 88   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 90   :     if (_Block_size <= _Bytes) {

	mov	eax, DWORD PTR __Block_size$[ebp]
	cmp	eax, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN8@Allocate_m

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 92   :     }
; 93   : 
; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	eax, DWORD PTR __Block_size$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	je	SHORT $LN7@Allocate_m
	jmp	SHORT $LN2@Allocate_m
$LN7@Allocate_m:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	95					; 0000005fH
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
$LN12@Allocate_m:
	mov	esi, esp
	push	0
	push	95					; 0000005fH
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN2@Allocate_m:
	xor	eax, eax
	jne	SHORT $LN4@Allocate_m

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	eax, DWORD PTR __Ptr_container$[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 98   : 
; 99   : #ifdef _DEBUG
; 100  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 101  : #endif // _DEBUG
; 102  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@H@std@@YAIIABH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Fnv1a_append_value@H@std@@YAIIABH@Z PROC		; std::_Fnv1a_append_value<int>, COMDAT

; 2093 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Fnv1a_append_value@H@std@@YAIIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2094 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2095 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	push	4
	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Fnv1a_append_bytes@std@@YAIIQBEI@Z	; std::_Fnv1a_append_bytes
	add	esp, 12					; 0000000cH

; 2096 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Fnv1a_append_value@H@std@@YAIIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Fnv1a_append_value@H@std@@YAIIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Fnv1a_append_value@H@std@@YAIIABH@Z ENDP		; std::_Fnv1a_append_value<int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@M@std@@YA$$QAMAAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@M@std@@YA$$QAMAAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@M@std@@YA$$QAMAAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *>, COMDAT

; 241  : void _Destroy_in_place(_Ty& _Obj) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 242  :     _Obj.~_Ty();
; 243  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 8
	push	eax
	call	??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z ; std::addressof<std::pair<int const ,unsigned char> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::destroy<std::pair<int const ,unsigned char> >
	add	esp, 8

; 318  :         _Freenode0(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 319  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > ><std::pair<int const ,unsigned char> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > ><std::pair<int const ,unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>, COMDAT
; _this$ = ecx

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U?$pair@$$CBHE@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > ><std::pair<int const ,unsigned char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 994  : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 995  :     // deallocate a plain pointer using an allocator
; 996  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 997  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 998  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 999  :     } else {
; 1000 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1001 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1002 :     }
; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool,0>, COMDAT
; _this$ = ecx

; 149  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YA$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@_N@std@@YA$$QA_NAA_N@Z	; std::forward<bool>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\unordered_map
;	COMDAT ??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z PROC ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>, COMDAT

; 73   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __32C29690_unordered_map
	call	@__CheckForDebuggerJustMyCode@4

; 74   :         return _Val.first;

	mov	eax, DWORD PTR __Val$[ebp]

; 75   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ENDP ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
_<_Vals_1>$ = 16					; size = 4
_<_Vals_2>$ = 20					; size = 4
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 586  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Al_$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 587  :         this->_Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Allocate

; 588  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_2>$[ebp]
	push	eax
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _<_Vals_1>$[ebp]
	push	ecx
	call	??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::forward<std::tuple<int const &> >
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _<_Vals_0>$[ebp]
	push	edx
	call	??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ; std::forward<std::piecewise_construct_t const &>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	call	??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z ; std::addressof<std::pair<int const ,unsigned char> >
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$construct@U?$pair@$$CBHE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::construct<std::pair<int const ,unsigned char>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
	add	esp, 20					; 00000014H

; 589  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT
; _this$ = ecx

; 591  :     ~_List_node_emplace_op2() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 592  :         if (this->_Ptr != pointer{}) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@List_node_

; 593  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	call	??$addressof@U?$pair@$$CBHE@std@@@std@@YAPAU?$pair@$$CBHE@0@AAU10@@Z ; std::addressof<std::pair<int const ,unsigned char> >
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$destroy@U?$pair@$$CBHE@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@QAU?$pair@$$CBHE@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::destroy<std::pair<int const ,unsigned char> >
	add	esp, 8
$LN1@List_node_:

; 594  :         }
; 595  :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT
; _this$ = ecx

; 1047 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1048 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@Alloc_cons

; 1049 :             _Al.deallocate(_Ptr, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEXQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::deallocate
$LN3@Alloc_cons:

; 1050 :         }
; 1051 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1042 :     void _Allocate() { // disengage *this, then allocate a new memory block

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1043 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1044 :         _Ptr = _Al.allocate(1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1045 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Release, COMDAT
; _this$ = ecx

; 1038 :     _NODISCARD pointer _Release() noexcept { // disengage *this and return contained pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1039 :         return _STD exchange(_Ptr, nullptr);

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	??$exchange@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@$$T@std@@YAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::nullptr_t>
	add	esp, 8

; 1040 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Release
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT
; _this$ = ecx

; 1036 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 821  : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 822  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tuple@$$V@std@@QAE@XZ		; std::tuple<>::tuple<>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 823  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ??0?$tuple@ABH@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$tuple@ABH@std@@QAE@$$QAV01@@Z PROC			; std::tuple<int const &>::tuple<int const &>, COMDAT
; _this$ = ecx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$tuple@ABH@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@$$V@std@@QAE@ABV01@@Z	; std::tuple<>::tuple<>
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$tuple@ABH@std@@QAE@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$tuple@ABH@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$tuple@ABH@std@@QAE@$$QAV01@@Z ENDP			; std::tuple<int const &>::tuple<int const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z PROC ; std::forward_as_tuple<int const &>, COMDAT

; 821  : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 822  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABH@std@@YAABHABH@Z		; std::forward<int const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z	; std::tuple<int const &>::tuple<int const &><int const &,0>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 823  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ENDP ; std::forward_as_tuple<int const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABH@std@@YAABHABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABH@std@@YAABHABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABH@std@@YAABHABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> * &,bool,0>, COMDAT
; _this$ = ecx

; 149  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	call	??$forward@_N@std@@YA$$QA_NAA_N@Z	; std::forward<bool>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> * &,bool,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z
_TEXT	SEGMENT
__Bucket_lo$ = -56					; size = 4
__End$ = -44						; size = 4
__Where$ = -32						; size = 4
__Bucket$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
__Hashval$ = 16						; size = 4
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Find_last<int>, COMDAT
; _this$ = ecx

; 1683 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1684 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1685 :         const size_type _Bucket = _Hashval & _Mask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Hashval$[ebp]
	and	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR __Bucket$[ebp], ecx

; 1686 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+eax*4+4]
	mov	DWORD PTR __Where$[ebp], eax

; 1687 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __End$[ebp], ecx

; 1688 :         if (_Where == _End) {

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR __End$[ebp]
	jne	SHORT $LN5@Find_last

; 1689 :             return {_End, _Nodeptr{}};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Find_last
$LN5@Find_last:

; 1690 :         }
; 1691 : 
; 1692 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR __Bucket_lo$[ebp], eax
$LN4@Find_last:

; 1693 :         for (;;) {
; 1694 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1695 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 8
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@Find_last

; 1696 :                 if
; 1697 :                     _CONSTEXPR_IF(!_Traits::_Standard) {
; 1698 :                         if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1699 :                             return {_Where->_Next, _Nodeptr{}};
; 1700 :                         }
; 1701 :                     }
; 1702 : 
; 1703 :                 return {_Where->_Next, _Where};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1704 :             }
; 1705 : 
; 1706 :             if (_Where == _Bucket_lo) {

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR __Bucket_lo$[ebp]
	jne	SHORT $LN7@Find_last

; 1707 :                 return {_Where, _Nodeptr{}};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1708 :             }
; 1709 : 
; 1710 :             _Where = _Where->_Prev;

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Where$[ebp], ecx

; 1711 :         }

	jmp	SHORT $LN4@Find_last
$LN1@Find_last:

; 1712 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Find_last<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>, COMDAT
; _this$ = ecx

; 172  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 173  :         // hash _Keyval to size_t value
; 174  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
	mov	ecx, eax
	call	??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z ; std::_Conditionally_enabled_hash<int,1>::operator()

; 175  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 121  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 122  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 123  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 111  : #if _HAS_EXCEPTIONS
; 112  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@sentry

; 113  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 114  :             }
; 115  : #else // _HAS_EXCEPTIONS
; 116  :             this->_Myostr._Osfx();
; 117  : #endif // _HAS_EXCEPTIONS
; 118  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 93   :             if (!_Ostr.good()) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 94   :                 _Ok = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 95   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Tied$[ebp], eax

; 99   :             if (!_Tied || _Tied == &_Ostr) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN4@sentry
	mov	eax, DWORD PTR __Tied$[ebp]
	cmp	eax, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 101  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Tied$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
$LN1@sentry:

; 107  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 80   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN3@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Sentry_bas:

; 82   :             }
; 83   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 73   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN1@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Sentry_bas:

; 75   :             }
; 76   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 28   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 34   :             if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH
	jbe	SHORT $LN2@Get_size_o

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
$LN3@Get_size_o:

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * &>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
	add	esp, 4
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 28   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 34   :             if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	jbe	SHORT $LN2@Get_size_o

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
$LN3@Get_size_o:

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> ><std::pair<int const ,unsigned char> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> ><std::pair<int const ,unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>, COMDAT
; _this$ = ecx

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U?$pair@$$CBHE@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> ><std::pair<int const ,unsigned char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xutility
;	COMDAT ??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__ULast$ = -20						; size = 4
__UFirst$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT

; 3806 : void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) { // copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45864D8F_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 3807 :     _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	add	esp, 8

; 3808 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 3809 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 3810 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<_FwdIt>, _Ty>) {
; 3811 :         _CSTD memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
; 3812 :     } else {
; 3813 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@fill:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN1@fill

; 3814 :             *_UFirst = _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __UFirst$[ebp]
	mov	DWORD PTR [edx], ecx

; 3815 :         }

	jmp	SHORT $LN2@fill
$LN1@fill:

; 3816 :     }
; 3817 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__Backout$2 = -52					; size = 8
__ULast$ = -36						; size = 4
__UFirst$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT

; 1762 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1763 :     // copy _Val throughout raw [_First, _Last)
; 1764 :     _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@PAV12@@std@@YAXABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	add	esp, 8

; 1765 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1766 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1767 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<_NoThrowFwdIt>, _Tval>) {
; 1768 :         _CSTD memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
; 1769 :     } else {
; 1770 :         _Uninitialized_backout<_Unwrapped_t<_NoThrowFwdIt>> _Backout{_UFirst};

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$2[ebp]
	call	??0?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN2@uninitiali:

; 1771 :         while (_Backout._Last != _ULast) {

	mov	eax, DWORD PTR __Backout$2[ebp+4]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@uninitiali

; 1772 :             _Backout._Emplace_back(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$2[ebp]
	call	??$_Emplace_back@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > const &>

; 1773 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 1774 : 
; 1775 :         _Backout._Release();

	lea	ecx, DWORD PTR __Backout$2[ebp]
	call	?_Release@?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::_Release

; 1776 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$2[ebp]
	call	??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>

; 1777 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@uninitiali:
	DD	1
	DD	$LN8@uninitiali
$LN8@uninitiali:
	DD	-52					; ffffffccH
	DD	8
	DD	$LN6@uninitiali
$LN6@uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z$0:
	lea	ecx, DWORD PTR __Backout$2[ebp]
	jmp	??1?$_Uninitialized_backout@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
__ehhandler$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 28   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 34   :             if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
$LN3@Get_size_o:

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 187  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 196  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 171  : _DECLSPEC_ALLOCATOR void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 172  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 173  : #if defined(_M_IX86) || defined(_M_X64)
; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Allocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	cmp	DWORD PTR __Bytes$[ebp], 0
	je	SHORT $LN3@Allocate

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN1@Allocate:

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -220						; size = 4
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 36   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Max_value@I@std@@YAABIABI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 37   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Max_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Max_value
$LN3@Max_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Max_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]

; 38   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Max_value@I@std@@YAABIABI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Max_value@I@std@@YAABIABI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$_Hash_representation@H@std@@YAIABH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??$_Hash_representation@H@std@@YAIABH@Z PROC		; std::_Hash_representation<int>, COMDAT

; 2100 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Hash_representation@H@std@@YAIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2101 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	push	-2128831035				; 811c9dc5H
	call	??$_Fnv1a_append_value@H@std@@YAIIABH@Z	; std::_Fnv1a_append_value<int>
	add	esp, 8

; 2102 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Hash_representation@H@std@@YAIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Hash_representation@H@std@@YAIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Hash_representation@H@std@@YAIABH@Z ENDP		; std::_Hash_representation<int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>, COMDAT
; _this$ = ecx

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	push	eax
	call	??$forward@M@std@@YA$$QAMAAM@Z		; std::forward<float>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
_<_Val2_1>$ = 16					; size = 4
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT
; _this$ = ecx

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _<_Val2_1>$[ebp]
	push	eax
	call	??$forward@M@std@@YA$$QAMAAM@Z		; std::forward<float>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _<_Val2_0>$[ebp]
	push	ecx
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	add	esp, 4
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAM@Z ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
	add	esp, 4

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 4
	push	eax
	call	??$_Destroy_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *>
	add	esp, 4

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::deallocate
	add	esp, 12					; 0000000cH

; 313  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Pnext$2 = -32						; size = 4
__Pnode$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	eax, DWORD PTR __Head$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	eax, DWORD PTR __Head$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
	cmp	DWORD PTR __Pnode$[ebp], 0
	je	SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$2[ebp], ecx

; 329  :             _Freenode(_Al, _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > ><std::allocator<std::pair<int const ,unsigned char> > const &,0>, COMDAT
; _this$ = ecx

; 297  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T3[ebp], al
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$forward@ABV?$allocator@U?$pair@$$CBHE@std@@@std@@@std@@YAABV?$allocator@U?$pair@$$CBHE@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<int const ,unsigned char> > const &>
	add	esp, 4
	push	eax
	movzx	edx, BYTE PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>

; 298  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 299  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > ><std::allocator<std::pair<int const ,unsigned char> > const &,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>, COMDAT

; 959  : void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowFwdIt _Last) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 960  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 961  :     if
; 962  :         _CONSTEXPR_IF(is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 963  :             (void) _First;
; 964  :             (void) _Last;
; 965  :         }
; 966  :     else {
; 967  :         for (; _First != _Last; ++_First) {
; 968  :             _Destroy_in_place(*_First);
; 969  :         }
; 970  :     }
; 971  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___param1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___param0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator++, COMDAT
; _this$ = ecx

; 107  :     _List_unchecked_iterator& operator++() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 108  :         _Mybase::operator++();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++

; 109  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 110  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHE@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHE@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator*, COMDAT
; _this$ = ecx

; 99   :     _NODISCARD reference operator*() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 100  :         return const_cast<reference>(_Mybase::operator*());

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*

; 101  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHE@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 77   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 78   :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 79   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 73   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 74   :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 75   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 62   :     _List_unchecked_const_iterator& operator--() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 63   :         _Ptr = _Ptr->_Prev;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 64   :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 65   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _List_unchecked_const_iterator& operator++() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 52   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 53   :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 54   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 43   :     _NODISCARD reference operator*() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 44   :         return _Ptr->_Myval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 8

; 45   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 41   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 290  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1097 :     void _Alloc_proxy(_Alloc&& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1098 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	DWORD PTR __New_proxy$[ebp], eax

; 1099 :         _Construct_in_place(*_New_proxy, this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_proxy$[ebp]
	push	edx
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1100 :         _Myproxy            = _New_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_proxy$[ebp]
	mov	DWORD PTR [eax], ecx

; 1101 :         _New_proxy->_Mycont = this;

	mov	eax, DWORD PTR __New_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 1102 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1295 :     ~_Container_proxy_ptr12() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1296 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Container_

; 1297 :             _Delete_plain_internal(_Al, _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8
$LN3@Container_:

; 1298 :         }
; 1299 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1281 :     _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1282 :         : _Al(_Al_) { // create a new _Container_proxy pointing at _Mycont

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1283 :         _Ptr = _Unfancy(_Al_.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al_$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1284 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	eax, DWORD PTR __Mycont$[ebp]
	push	eax
	call	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1285 :         _Mycont._Myproxy = _Ptr;

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1286 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<int const ,unsigned char>,void *> >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<int const ,unsigned char>,void *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1022 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1023 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1024 :     using _Ty = typename _Alloc::value_type;
; 1025 :     _Ptr->~_Ty();
; 1026 :     _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1027 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 569  : _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 570  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 571  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 572  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 785  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z
_TEXT	SEGMENT
$T2 = -348						; size = 4
$T3 = -333						; size = 1
$T4 = -324						; size = 8
$T5 = -308						; size = 4
$T6 = -293						; size = 1
$T7 = -281						; size = 1
__Newnode$ = -80					; size = 8
__Target$ = -64						; size = 8
__Hashval$ = -48					; size = 4
__Keyval$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval_arg$ = 12					; size = 4
??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Try_emplace<int const &>, COMDAT
; _this$ = ecx

; 840  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 841  :         const auto& _Keyval = _Keyval_arg;

	mov	eax, DWORD PTR __Keyval_arg$[ebp]
	mov	DWORD PTR __Keyval$[ebp], eax

; 842  :         const auto _Hashval = _Traitsobj(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
	mov	DWORD PTR __Hashval$[ebp], eax

; 843  :         auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	eax, DWORD PTR __Hashval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Target$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Find_last<int>

; 844  :         if (_Target._Duplicate) {

	cmp	DWORD PTR __Target$[ebp+4], 0
	je	SHORT $LN2@Try_emplac

; 845  :             return {_Target._Duplicate, false};

	mov	BYTE PTR $T7[ebp], 0
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR __Target$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@AAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> * &,bool,0>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN1@Try_emplac
$LN2@Try_emplac:

; 846  :         }
; 847  : 
; 848  :         _Check_max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_max_size

; 849  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval_arg$[ebp]
	push	ecx
	call	??$forward@ABH@std@@YAABHABH@Z		; std::forward<int const &>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ; std::forward_as_tuple<int const &>
	add	esp, 8
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Newnode$[ebp]
	call	??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 850  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 851  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 852  :         if (_Check_rehash_required_1()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Try_emplac

; 853  :             _Rehash_for_1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Rehash_for_1

; 854  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	eax, DWORD PTR __Hashval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newnode$[ebp+4]
	add	ecx, 8
	push	ecx
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Find_last@H@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Hash_find_last_result@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@ABHI@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Find_last<int>
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Target$[ebp], ecx
	mov	DWORD PTR __Target$[ebp+4], edx
$LN3@Try_emplac:

; 855  :         }
; 856  : 
; 857  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	lea	ecx, DWORD PTR __Newnode$[ebp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::_Release
	push	eax
	mov	eax, DWORD PTR __Target$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hashval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Insert_new_node_before
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR $T3[ebp], 1
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N$0A@@?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@$$QA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned char>,void *> *,bool,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Newnode$[ebp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Try_emplac:

; 858  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Try_emplac
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN10@Try_emplac:
	DD	2
	DD	$LN9@Try_emplac
$LN9@Try_emplac:
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN6@Try_emplac
	DD	-80					; ffffffb0H
	DD	8
	DD	$LN7@Try_emplac
$LN7@Try_emplac:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN6@Try_emplac:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z$0:
	lea	ecx, DWORD PTR __Newnode$[ebp]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
__ehhandler$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Try_emplace<int const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 943  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 944  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 945  :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 946  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 947  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -356						; size = 8
tv343 = -348						; size = 8
tv291 = -344						; size = 4
tv288 = -344						; size = 8
tv286 = -344						; size = 4
tv329 = -340						; size = 8
tv290 = -340						; size = 4
tv285 = -340						; size = 4
tv287 = -336						; size = 4
tv137 = -336						; size = 4
tv289 = -333						; size = 1
tv284 = -333						; size = 1
$T2 = -328						; size = 4
$T3 = -316						; size = 4
$T4 = -304						; size = 4
$T5 = -292						; size = 4
$T6 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 731  :     const char* _Val) { // insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 732  :     using _Elem = char;
; 733  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 734  : 
; 735  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 736  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 737  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv329[ebp], eax
	mov	DWORD PTR tv329[ebp+4], edx
	cmp	DWORD PTR tv329[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv329[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv343[ebp], eax
	mov	DWORD PTR tv343[ebp+4], edx
	mov	eax, DWORD PTR tv343[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv343[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp+4], edx

; 738  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 739  : 
; 740  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 741  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 742  :     } else { // state okay, insert

	jmp	$LN9@operator
$LN8@operator:

; 743  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 744  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 745  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN11@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN11@operator
$LN26@operator:

; 746  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv284[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv284[ebp]
	push	eax
	mov	ecx, DWORD PTR tv285[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 747  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 748  :                     break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 749  :                 }
; 750  :             }

	jmp	$LN2@operator
$LN11@operator:

; 751  :         }
; 752  : 
; 753  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	DWORD PTR tv288[ebp+4], edx
	mov	eax, DWORD PTR tv288[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv288[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 754  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN13@operator:

; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN14@operator

; 758  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN14@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN14@operator
$LN28@operator:

; 759  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv289[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@operator

; 760  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 761  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 762  :                 }
; 763  :             }

	jmp	$LN5@operator
$LN14@operator:

; 764  :         }
; 765  : 
; 766  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 767  :         _CATCH_IO_(ios_base, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN9@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 768  :     }
; 769  : 
; 770  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 771  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 772  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?key_callback@@YAXPAUGLFWwindow@@HHHH@Z
_TEXT	SEGMENT
tv69 = -193						; size = 1
_window$ = 8						; size = 4
_key$ = 12						; size = 4
_scancode$ = 16						; size = 4
_action$ = 20						; size = 4
_mods$ = 24						; size = 4
?key_callback@@YAXPAUGLFWwindow@@HHHH@Z PROC		; key_callback, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 26   : 	if (key != -1) {

	cmp	DWORD PTR _key$[ebp], -1
	je	SHORT $LN1@key_callba

; 27   : 		keys[key] = (action != GLFW_RELEASE);

	cmp	DWORD PTR _action$[ebp], 0
	je	SHORT $LN4@key_callba
	mov	BYTE PTR tv69[ebp], 1
	jmp	SHORT $LN5@key_callba
$LN4@key_callba:
	mov	BYTE PTR tv69[ebp], 0
$LN5@key_callba:
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, OFFSET ?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
	mov	cl, BYTE PTR tv69[ebp]
	mov	BYTE PTR [eax], cl
$LN1@key_callba:

; 28   : 	}
; 29   : 	
; 30   : 
; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?key_callback@@YAXPAUGLFWwindow@@HHHH@Z ENDP		; key_callback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Flastkeys@@YAXXZ
text$yd	SEGMENT
??__Flastkeys@@YAXXZ PROC				; `dynamic atexit destructor for 'lastkeys'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Flastkeys@@YAXXZ ENDP				; `dynamic atexit destructor for 'lastkeys''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ??__Elastkeys@@YAXXZ
text$di	SEGMENT
??__Elastkeys@@YAXXZ PROC				; `dynamic initializer for 'lastkeys'', COMDAT

; 21   : static std::unordered_map<int, boolean> lastkeys;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	mov	ecx, OFFSET ?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z
	mov	ecx, OFFSET ?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
	push	OFFSET ??__Flastkeys@@YAXXZ		; `dynamic atexit destructor for 'lastkeys''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Elastkeys@@YAXXZ ENDP				; `dynamic initializer for 'lastkeys''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Fkeys@@YAXXZ
text$yd	SEGMENT
??__Fkeys@@YAXXZ PROC					; `dynamic atexit destructor for 'keys'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fkeys@@YAXXZ ENDP					; `dynamic atexit destructor for 'keys''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ??__Ekeys@@YAXXZ
text$di	SEGMENT
??__Ekeys@@YAXXZ PROC					; `dynamic initializer for 'keys'', COMDAT

; 20   : static std::unordered_map<int, boolean> keys;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	mov	ecx, OFFSET ?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z
	mov	ecx, OFFSET ?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
	push	OFFSET ??__Fkeys@@YAXXZ			; `dynamic atexit destructor for 'keys''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Ekeys@@YAXXZ ENDP					; `dynamic initializer for 'keys''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z PROC ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXI@Z ENDP ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ PROC ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::~unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ENDP ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::~unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\unordered_map
;	COMDAT ??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Keyval$ = 8						; size = 4
??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z PROC ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[], COMDAT
; _this$ = ecx

; 400  :     mapped_type& operator[](const key_type& _Keyval) {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __32C29690_unordered_map
	call	@__CheckForDebuggerJustMyCode@4

; 401  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Try_emplace@ABH$$V@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@_N@1@ABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Try_emplace<int const &>
	mov	eax, DWORD PTR [eax]
	add	eax, 12					; 0000000cH

; 402  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ENDP ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\unordered_map
;	COMDAT ??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -209						; size = 1
_this$ = -8						; size = 4
??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ PROC ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >, COMDAT
; _this$ = ecx

; 124  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __32C29690_unordered_map
	call	@__CheckForDebuggerJustMyCode@4
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,unsigned char> >::allocator<std::pair<int const ,unsigned char> >
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ENDP ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::~_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::~list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::~_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :     const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1341 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >, COMDAT
; _this$ = ecx

; 374  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __805570D0_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -252						; size = 4
_$S1$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >, COMDAT
; _this$ = ecx

; 344  :     ~_Hash_vec() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 345  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Tidy

; 346  : #if _ITERATOR_DEBUG_LEVEL != 0
; 347  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
	push	eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	lea	eax, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 348  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 349  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 350  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Hash_vec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@Hash_vec:
	DD	1
	DD	$LN5@Hash_vec
$LN5@Hash_vec:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@Hash_vec
$LN3@Hash_vec:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Tidy, COMDAT
; _this$ = ecx

; 336  :     void _Tidy() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 337  :         _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	add	esp, 8

; 338  :         _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::size
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
	mov	ecx, eax
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::deallocate

; 339  :         _Mypair._Myval2._Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 340  :         _Mypair._Myval2._Mylast  = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 341  :         _Mypair._Myval2._Myend   = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 342  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Newend$1 = -56					; size = 4
__Newvec$2 = -44					; size = 4
__Alvec$ = -32						; size = 4
__Oldsize$ = -20					; size = 4
_this$ = -8						; size = 4
__Cells$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Assign_grow, COMDAT
; _this$ = ecx

; 313  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 314  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 315  :         const auto _Oldsize = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::size
	mov	DWORD PTR __Oldsize$[ebp], eax

; 316  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 317  :         auto& _Alvec = _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
	mov	DWORD PTR __Alvec$[ebp], eax

; 318  :         if (_Oldsize < _Cells) {

	mov	eax, DWORD PTR __Oldsize$[ebp]
	cmp	eax, DWORD PTR __Cells$[ebp]
	jae	SHORT $LN2@Assign_gro

; 319  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	eax, DWORD PTR __Cells$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alvec$[ebp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocate
	mov	DWORD PTR __Newvec$2[ebp], eax

; 320  :             // nothrow hereafter
; 321  :             if (_Oldsize != 0) {

	cmp	DWORD PTR __Oldsize$[ebp], 0
	je	SHORT $LN4@Assign_gro

; 322  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Destroy_range@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@QAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *>
	add	esp, 8

; 323  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldsize);

	mov	eax, DWORD PTR __Oldsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR __Alvec$[ebp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::deallocate
$LN4@Assign_gro:

; 324  :             }
; 325  : 
; 326  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$2[ebp]
	mov	DWORD PTR [eax+4], ecx

; 327  :             const auto _Newend       = _Newvec + _Cells;

	mov	eax, DWORD PTR __Cells$[ebp]
	mov	ecx, DWORD PTR __Newvec$2[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Newend$1[ebp], edx

; 328  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newend$1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 329  :             _Mypair._Myval2._Myend   = _Newend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newend$1[ebp]
	mov	DWORD PTR [eax+12], ecx

; 330  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newend$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$2[ebp]
	push	edx
	call	??$uninitialized_fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 12					; 0000000cH

; 331  :         } else {

	jmp	SHORT $LN1@Assign_gro
$LN2@Assign_gro:

; 332  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 12					; 0000000cH
$LN1@Assign_gro:

; 333  :         }
; 334  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size, COMDAT
; _this$ = ecx

; 308  :     _NODISCARD size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 309  :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >,1>::_Get_first
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 310  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 311  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::size, COMDAT
; _this$ = ecx

; 304  :     _NODISCARD size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 305  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 306  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size, COMDAT

; 679  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 681  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocate, COMDAT
; _this$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 785  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@QAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 1924 :     const float& _Max_bucket_size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1925 :         return _Traitsobj._Get_max_bucket_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size

; 1926 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 1920 :     float& _Max_bucket_size() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1921 :         return _Traitsobj._Get_max_bucket_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size

; 1922 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Insert_before$2 = -156				; size = 4
__Bucket_hi$3 = -144					; size = 4
__Bucket_lo$4 = -132					; size = 4
__Bucket$5 = -120					; size = 4
__Inserted_key$6 = -108					; size = 4
__Next_inserted$7 = -96					; size = 4
__Inserted$ = -84					; size = 4
__Guard$ = -72						; size = 4
__End$ = -60						; size = 4
__Max_storage_buckets$ = -48				; size = 4
__Max_storage_buckets_log2$ = -36			; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Buckets$ = 8						; size = 4
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Forced_rehash, COMDAT
; _this$ = ecx

; 1828 :     void _Forced_rehash(size_type _Buckets) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1829 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1830 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1831 :         // load_factor() <= max_load_factor().
; 1832 : 
; 1833 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1834 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1835 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::max_size
	shr	eax, 1
	push	eax
	call	?_Floor_of_log_2@std@@YAKI@Z		; std::_Floor_of_log_2
	add	esp, 4
	mov	DWORD PTR __Max_storage_buckets_log2$[ebp], eax

; 1836 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, 1
	mov	ecx, DWORD PTR __Max_storage_buckets_log2$[ebp]
	shl	eax, cl
	mov	DWORD PTR __Max_storage_buckets$[ebp], eax

; 1837 :         if (_Buckets > _Max_storage_buckets) {

	mov	eax, DWORD PTR __Buckets$[ebp]
	cmp	eax, DWORD PTR __Max_storage_buckets$[ebp]
	jbe	SHORT $LN8@Forced_reh

; 1838 :             _Xlength_error("invalid hash bucket count");

	push	OFFSET ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN8@Forced_reh:

; 1839 :         }
; 1840 : 
; 1841 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1842 :         // 2 invariant
; 1843 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1844 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1845 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	eax, DWORD PTR __Buckets$[ebp]
	push	eax
	call	?_Ceiling_of_log_2@std@@YAKI@Z		; std::_Ceiling_of_log_2
	add	esp, 4
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR __Buckets$[ebp], edx

; 1846 :         const _Unchecked_iterator _End = _Unchecked_end();

	push	4
	lea	ecx, DWORD PTR __End$[ebp]
	call	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR __End$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_end

; 1847 : 
; 1848 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	eax, DWORD PTR __End$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buckets$[ebp]
	shl	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Assign_grow

; 1849 :         _Mask   = _Buckets - 1;

	mov	eax, DWORD PTR __Buckets$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1850 :         _Maxidx = _Buckets;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Buckets$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1851 : 
; 1852 :         _Clear_guard _Guard{this};

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Guard$[ebp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@QAV12@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::_Clear_guard
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1853 : 
; 1854 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	push	4
	lea	ecx, DWORD PTR __Inserted$[ebp]
	call	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR __Inserted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_begin

; 1855 : 
; 1856 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1857 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	push	4
	lea	ecx, DWORD PTR __Next_inserted$7[ebp]
	call	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Inserted$[ebp]
	mov	DWORD PTR __Next_inserted$7[ebp], eax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	eax, DWORD PTR __Next_inserted$7[ebp]
	mov	DWORD PTR __Inserted$[ebp], eax
$LN4@Forced_reh:
	lea	eax, DWORD PTR __End$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Inserted$[ebp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@Forced_reh

; 1858 :             ++_Next_inserted;

	lea	ecx, DWORD PTR __Next_inserted$7[ebp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator++

; 1859 : 
; 1860 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	ecx, DWORD PTR __Inserted$[ebp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > >::operator*
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	mov	DWORD PTR __Inserted_key$6[ebp], eax

; 1861 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	eax, DWORD PTR __Inserted_key$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket
	mov	DWORD PTR __Bucket$5[ebp], eax

; 1862 : 
; 1863 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1864 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1865 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	eax, DWORD PTR __Bucket$5[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR __Bucket_lo$4[ebp], eax

; 1866 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	eax, DWORD PTR __Bucket$5[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR [edx+eax*4+4]
	mov	DWORD PTR __Bucket_hi$3[ebp], eax

; 1867 : 
; 1868 :             if (_Bucket_lo == _End) {

	lea	eax, DWORD PTR __End$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Bucket_lo$4[ebp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Forced_reh

; 1869 :                 // The bucket was empty, set it to the inserted element.
; 1870 :                 _Bucket_lo = _Inserted;

	mov	eax, DWORD PTR __Bucket_lo$4[ebp]
	mov	ecx, DWORD PTR __Inserted$[ebp]
	mov	DWORD PTR [eax], ecx

; 1871 :                 _Bucket_hi = _Inserted;

	mov	eax, DWORD PTR __Bucket_hi$3[ebp]
	mov	ecx, DWORD PTR __Inserted$[ebp]
	mov	DWORD PTR [eax], ecx

; 1872 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1873 :             }
; 1874 : 
; 1875 :             // Search the bucket for the insertion location and move element if necessary.
; 1876 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	push	4
	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Bucket_hi$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Insert_before$2[ebp], ecx

; 1877 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Inserted_key$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@Forced_reh

; 1878 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1879 :                 // new bucket inclusive end.
; 1880 :                 ++_Insert_before;

	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++

; 1881 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	eax, DWORD PTR __Inserted$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@Forced_reh

; 1882 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	eax, DWORD PTR __Next_inserted$7[ebp]
	push	eax
	mov	ecx, DWORD PTR __Inserted$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Insert_before$2[ebp]
	push	edx
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice
	add	esp, 12					; 0000000cH
$LN11@Forced_reh:

; 1883 :                 }
; 1884 : 
; 1885 :                 _Bucket_hi = _Inserted;

	mov	eax, DWORD PTR __Bucket_hi$3[ebp]
	mov	ecx, DWORD PTR __Inserted$[ebp]
	mov	DWORD PTR [eax], ecx

; 1886 :                 continue;

	jmp	$LN2@Forced_reh
$LN7@Forced_reh:

; 1887 :             }
; 1888 : 
; 1889 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1890 :             // go backwards to maintain sortedness when !_Standard.
; 1891 :             for (;;) {
; 1892 :                 if (_Bucket_lo == _Insert_before) {

	lea	eax, DWORD PTR __Insert_before$2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Bucket_lo$4[ebp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Forced_reh

; 1893 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1894 :                     // Element can't be already in position here because:
; 1895 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1896 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1897 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	eax, DWORD PTR __Next_inserted$7[ebp]
	push	eax
	mov	ecx, DWORD PTR __Inserted$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Insert_before$2[ebp]
	push	edx
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice
	add	esp, 12					; 0000000cH

; 1898 :                     _Bucket_lo = _Inserted;

	mov	eax, DWORD PTR __Bucket_lo$4[ebp]
	mov	ecx, DWORD PTR __Inserted$[ebp]
	mov	DWORD PTR [eax], ecx

; 1899 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1900 :                 }
; 1901 : 
; 1902 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator--
	mov	ecx, eax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBHE@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator*
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Inserted_key$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@Forced_reh

; 1903 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1904 :                     ++_Insert_before;

	lea	ecx, DWORD PTR __Insert_before$2[ebp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,std::_Iterator_base0>::operator++

; 1905 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1906 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1907 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	eax, DWORD PTR __Next_inserted$7[ebp]
	push	eax
	mov	ecx, DWORD PTR __Inserted$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Insert_before$2[ebp]
	push	edx
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice
	add	esp, 12					; 0000000cH

; 1908 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1909 :                 }
; 1910 :             }

	jmp	$LN7@Forced_reh
$LN6@Forced_reh:

; 1911 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1912 : 
; 1913 :         _Guard._Target = nullptr;

	mov	DWORD PTR __Guard$[ebp], 0

; 1914 : 
; 1915 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1916 :         _Stl_internal_check_container_invariants();
; 1917 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1918 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Guard$[ebp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::~_Clear_guard
$LN14@Forced_reh:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Forced_reh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN23@Forced_reh:
	DD	5
	DD	$LN22@Forced_reh
$LN22@Forced_reh:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN16@Forced_reh
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN17@Forced_reh
	DD	-84					; ffffffacH
	DD	4
	DD	$LN18@Forced_reh
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN19@Forced_reh
	DD	-156					; ffffff64H
	DD	4
	DD	$LN20@Forced_reh
$LN20@Forced_reh:
	DB	95					; 0000005fH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	0
$LN19@Forced_reh:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN18@Forced_reh:
	DB	95					; 0000005fH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN17@Forced_reh:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN16@Forced_reh:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR __Guard$[ebp]
	jmp	??1_Clear_guard@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Clear_guard::~_Clear_guard
__ehhandler$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Forced_rehash
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
$T2 = -248						; size = 4
__Req_buckets$ = -44					; size = 4
__Old_buckets$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__For_size$ = 8						; size = 4
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Desired_grow_bucket_count, COMDAT
; _this$ = ecx

; 1807 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1808 :         const size_type _Old_buckets = bucket_count();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count
	mov	DWORD PTR __Old_buckets$[ebp], eax

; 1809 :         const size_type _Req_buckets = _Max_value(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	eax, DWORD PTR __For_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_load_factor_buckets
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	push	OFFSET ?_Min_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@2IB
	call	??$_Max_value@I@std@@YAABIABI0@Z	; std::_Max_value<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Req_buckets$[ebp], edx

; 1810 :         if (_Old_buckets >= _Req_buckets) {

	mov	eax, DWORD PTR __Old_buckets$[ebp]
	cmp	eax, DWORD PTR __Req_buckets$[ebp]
	jb	SHORT $LN2@Desired_gr

; 1811 :             // we already have enough buckets so there's no need to change the count
; 1812 :             return _Old_buckets;

	mov	eax, DWORD PTR __Old_buckets$[ebp]
	jmp	SHORT $LN4@Desired_gr
$LN2@Desired_gr:

; 1813 :         }
; 1814 : 
; 1815 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	DWORD PTR __Old_buckets$[ebp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	eax, DWORD PTR __Old_buckets$[ebp]
	shl	eax, 3
	cmp	eax, DWORD PTR __Req_buckets$[ebp]
	jb	SHORT $LN3@Desired_gr

; 1816 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1817 :             return _Old_buckets * 8;

	mov	eax, DWORD PTR __Old_buckets$[ebp]
	shl	eax, 3
	jmp	SHORT $LN4@Desired_gr
$LN3@Desired_gr:

; 1818 :         }
; 1819 : 
; 1820 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1821 :         return _Req_buckets;

	mov	eax, DWORD PTR __Req_buckets$[ebp]
$LN4@Desired_gr:

; 1822 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Desired_grow_bucket_count
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv90 = -240						; size = 4
tv85 = -236						; size = 4
tv129 = -232						; size = 4
tv78 = -228						; size = 8
tv74 = -220						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__For_size$ = 8						; size = 4
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_load_factor_buckets, COMDAT
; _this$ = ecx

; 1802 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1803 :         // returns the minimum number of buckets necessary for the elements in _List
; 1804 :         return static_cast<size_type>(_CSTD ceilf(_For_size / max_load_factor()));

	mov	eax, DWORD PTR __For_size$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv74[ebp]
	mov	ecx, DWORD PTR tv74[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv78[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv78[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::max_load_factor
	fstp	DWORD PTR tv85[ebp]
	movss	xmm0, DWORD PTR tv129[ebp]
	divss	xmm0, DWORD PTR tv85[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	fstp	DWORD PTR tv90[ebp]
	movss	xmm0, DWORD PTR tv90[ebp]
	call	__ftoui3

; 1805 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Min_load_factor_buckets
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Newsize$ = -32					; size = 4
__Oldsize$ = -20					; size = 4
_this$ = -8						; size = 4
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Rehash_for_1, COMDAT
; _this$ = ecx

; 1778 :     void _Rehash_for_1() {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1779 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1780 :         const auto _Newsize = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1781 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEII@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Desired_grow_bucket_count
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Forced_rehash

; 1782 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ
_TEXT	SEGMENT
tv77 = -280						; size = 4
tv133 = -276						; size = 8
tv130 = -268						; size = 4
tv142 = -264						; size = 4
tv140 = -260						; size = 4
tv92 = -256						; size = 8
tv88 = -248						; size = 4
tv86 = -244						; size = 4
__Newsize$ = -44					; size = 4
__Oldsize$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_rehash_required_1, COMDAT
; _this$ = ecx

; 1772 :     bool _Check_rehash_required_1() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1773 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1774 :         const auto _Newsize      = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1775 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::max_load_factor
	fstp	DWORD PTR tv86[ebp]
	movss	xmm0, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv88[ebp]
	mov	ecx, DWORD PTR tv88[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv92[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv92[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv140[ebp], xmm0
	movss	DWORD PTR tv142[ebp], xmm1
	call	?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count
	mov	DWORD PTR tv130[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR tv130[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv133[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv133[ebp]
	movss	xmm1, DWORD PTR tv142[ebp]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv140[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[ebp], 0
$LN4@Check_reha:
	mov	al, BYTE PTR tv77[ebp]

; 1776 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBE_NXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_rehash_required_1
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
__Oldsize$ = -20					; size = 4
_this$ = -8						; size = 4
?_Check_max_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_max_size, COMDAT
; _this$ = ecx

; 1765 :     void _Check_max_size() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1766 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1767 :         if (_Oldsize == _List.max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::max_size
	cmp	DWORD PTR __Oldsize$[ebp], eax
	jne	SHORT $LN3@Check_max_

; 1768 :             _Xlength_error("unordered_map/set too long");

	push	OFFSET ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Check_max_:

; 1769 :         }
; 1770 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z
_TEXT	SEGMENT
__Bucket_hi$ = -96					; size = 4
__Bucket_lo$ = -84					; size = 4
__Bucket$ = -72						; size = 4
__Bucket_array$ = -60					; size = 4
__Head$ = -48						; size = 4
__Insert_after$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Hashval$ = 8						; size = 4
__Insert_before$ = 12					; size = 4
__Newnode$ = 16						; size = 4
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Insert_new_node_before, COMDAT
; _this$ = ecx

; 1734 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1735 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	eax, DWORD PTR __Insert_before$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Insert_after$[ebp], ecx

; 1736 :         ++_List._Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1737 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	lea	eax, DWORD PTR __Insert_before$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	push	ecx
	call	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
	add	esp, 8

; 1738 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	lea	eax, DWORD PTR __Insert_after$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newnode$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * const &>
	add	esp, 8

; 1739 :         _Insert_after->_Next  = _Newnode;

	mov	eax, DWORD PTR __Insert_after$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1740 :         _Insert_before->_Prev = _Newnode;

	mov	eax, DWORD PTR __Insert_before$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1741 : 
; 1742 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Head$[ebp], ecx

; 1743 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Bucket_array$[ebp], ecx

; 1744 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Hashval$[ebp]
	and	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR __Bucket$[ebp], ecx

; 1745 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	eax, DWORD PTR __Bucket$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_array$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Bucket_lo$[ebp], edx

; 1746 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	eax, DWORD PTR __Bucket$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_array$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR __Bucket_hi$[ebp], edx

; 1747 :         if (_Bucket_lo._Ptr == _Head) {

	mov	eax, DWORD PTR __Bucket_lo$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Head$[ebp]
	jne	SHORT $LN2@Insert_new

; 1748 :             // bucket is empty, set both
; 1749 :             _Bucket_lo._Ptr = _Newnode;

	mov	eax, DWORD PTR __Bucket_lo$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1750 :             _Bucket_hi._Ptr = _Newnode;

	mov	eax, DWORD PTR __Bucket_hi$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1751 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	eax, DWORD PTR __Bucket_lo$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Insert_before$[ebp]
	jne	SHORT $LN4@Insert_new

; 1752 :             // new node is the lowest element in the bucket
; 1753 :             _Bucket_lo._Ptr = _Newnode;

	mov	eax, DWORD PTR __Bucket_lo$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Insert_new
$LN4@Insert_new:

; 1754 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	eax, DWORD PTR __Bucket_hi$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Insert_after$[ebp]
	jne	SHORT $LN3@Insert_new

; 1755 :             // new node is the highest element in the bucket
; 1756 :             _Bucket_hi._Ptr = _Newnode;

	mov	eax, DWORD PTR __Bucket_hi$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert_new:

; 1757 :         }
; 1758 : 
; 1759 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1760 :         _Stl_internal_check_container_invariants();
; 1761 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1762 :         return _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]

; 1763 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Insert_new
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN11@Insert_new:
	DD	1
	DD	$LN10@Insert_new
$LN10@Insert_new:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN8@Insert_new
$LN8@Insert_new:
	DB	95					; 0000005fH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@IQAU32@0@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Insert_new_node_before
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -248						; size = 4
__Head$3 = -44						; size = 4
__Oldsize$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::clear, COMDAT
; _this$ = ecx

; 1273 :     void clear() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1274 :         // TRANSITION, ABI:
; 1275 :         // LWG 2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1276 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1277 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1278 :         //   (2) The hash function operator() may throw exceptions, and
; 1279 :         //   (3) clear() is a noexcept function.
; 1280 :         // We do comply with LWG 2550 if the hash function is noexcept, or if the container was empty.
; 1281 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1282 :         if (_Oldsize == 0) {

	cmp	DWORD PTR __Oldsize$[ebp], 0
	jne	SHORT $LN2@clear

; 1283 :             return;

	jmp	SHORT $LN4@clear
$LN2@clear:

; 1284 :         }
; 1285 : 
; 1286 :         if
; 1287 :             _CONSTEXPR_IF(_Nothrow_hash<_Traits, key_type>) {
; 1288 :                 // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1289 :                 // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1290 :                 // as many buckets as elements, remove element-by-element.
; 1291 :                 if ((bucket_count() >> 3) > _Oldsize) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count
	shr	eax, 3
	cmp	eax, DWORD PTR __Oldsize$[ebp]
	jbe	SHORT $LN3@clear

; 1292 :                     const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Head$3[ebp], ecx

; 1293 :                     _Unchecked_erase(_Head->_Next, _Head);

	mov	eax, DWORD PTR __Head$3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Head$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_erase

; 1294 :                     return;

	jmp	SHORT $LN4@clear
$LN3@clear:

; 1295 :                 }
; 1296 :             }
; 1297 : 
; 1298 :         // Bulk destroy items and reset buckets
; 1299 :         _List.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::clear

; 1300 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_end
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	??$fill@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@V12@@std@@YAXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@0@0ABV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > >
	add	esp, 12					; 0000000cH
$LN4@clear:

; 1301 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::clear
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
_TEXT	SEGMENT
tv172 = -445						; size = 1
tv138 = -445						; size = 1
tv136 = -445						; size = 1
$T2 = -440						; size = 4
$T3 = -428						; size = 4
$T4 = -416						; size = 4
__At_bucket_back$5 = -209				; size = 1
__Old_hi$6 = -200					; size = 4
__Bucket_hi$7 = -188					; size = 4
__Bucket_lo$8 = -176					; size = 4
__Bucket$9 = -164					; size = 4
__At_bucket_back$10 = -149				; size = 1
__Old_hi$11 = -140					; size = 4
__Update_lo$12 = -125					; size = 1
__Bucket_hi$13 = -116					; size = 4
__Bucket_lo$14 = -104					; size = 4
__Bucket$15 = -92					; size = 4
__Predecessor$16 = -80					; size = 4
__Eraser$ = -68						; size = 12
__Bucket_bounds$ = -48					; size = 4
__End$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1164 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-448]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1165 :         if (_First == _Last) {

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN10@Unchecked_

; 1166 :             return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	jmp	$LN18@Unchecked_
$LN10@Unchecked_:

; 1167 :         }
; 1168 : 
; 1169 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __End$[ebp], ecx

; 1170 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Bucket_bounds$[ebp], ecx

; 1171 :         _Range_eraser _Eraser{_List, _First};

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@AAV?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Range_eraser

; 1172 :         {
; 1173 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1174 :             const auto _Predecessor = _First->_Prev;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Predecessor$16[ebp], ecx

; 1175 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	add	eax, 8
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket
	mov	DWORD PTR __Bucket$15[ebp], eax

; 1176 :             // nothrow hereafter this block
; 1177 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$15[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_bounds$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Bucket_lo$14[ebp], edx

; 1178 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$15[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_bounds$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR __Bucket_hi$13[ebp], edx

; 1179 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	eax, DWORD PTR __Bucket_lo$14[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Eraser$[ebp+8]
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[ebp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[ebp], 0
$LN20@Unchecked_:
	mov	dl, BYTE PTR tv136[ebp]
	mov	BYTE PTR __Update_lo$12[ebp], dl

; 1180 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	eax, DWORD PTR __Bucket_hi$13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_hi$11[ebp], ecx
$LN4@Unchecked_:

; 1181 :             for (;;) { // remove elements until we hit the end of the bucket
; 1182 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	cmp	eax, DWORD PTR __Old_hi$11[ebp]
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[ebp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[ebp], 0
$LN22@Unchecked_:
	mov	cl, BYTE PTR tv138[ebp]
	mov	BYTE PTR __At_bucket_back$10[ebp], cl

; 1183 :                 _Eraser._Bump_erased();

	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Bump_erased

; 1184 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR __At_bucket_back$10[ebp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1185 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1186 :                 }
; 1187 : 
; 1188 :                 if (_Eraser._Next == _Last) {

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN12@Unchecked_

; 1189 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR __Update_lo$12[ebp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1190 :                         // erased the bucket's prefix
; 1191 :                         _Bucket_lo = _Eraser._Next;

	mov	eax, DWORD PTR __Bucket_lo$14[ebp]
	mov	ecx, DWORD PTR __Eraser$[ebp+8]
	mov	DWORD PTR [eax], ecx
$LN13@Unchecked_:

; 1192 :                     }
; 1193 : 
; 1194 :                     return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN18@Unchecked_
$LN12@Unchecked_:

; 1195 :                 }
; 1196 :             }

	jmp	SHORT $LN4@Unchecked_
$LN3@Unchecked_:

; 1197 : 
; 1198 :             if (_Update_lo) {

	movzx	eax, BYTE PTR __Update_lo$12[ebp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1199 :                 // emptied the bucket
; 1200 :                 _Bucket_lo = _End;

	mov	eax, DWORD PTR __Bucket_lo$14[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	DWORD PTR [eax], ecx

; 1201 :                 _Bucket_hi = _End;

	mov	eax, DWORD PTR __Bucket_hi$13[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1203 :                 _Bucket_hi = _Predecessor;

	mov	eax, DWORD PTR __Bucket_hi$13[ebp]
	mov	ecx, DWORD PTR __Predecessor$16[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Unchecked_:

; 1204 :             }
; 1205 :         }
; 1206 : 
; 1207 :         // hereafter we are always erasing buckets' prefixes
; 1208 :         while (_Eraser._Next != _Last) {

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN6@Unchecked_

; 1209 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	add	eax, 8
	push	eax
	call	??$_Kfn@$$CBHE@?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHE@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Kfn<int const ,unsigned char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket
	mov	DWORD PTR __Bucket$9[ebp], eax

; 1210 :             // nothrow hereafter this block
; 1211 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$9[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_bounds$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Bucket_lo$8[ebp], edx

; 1212 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	eax, DWORD PTR __Bucket$9[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR __Bucket_bounds$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR __Bucket_hi$7[ebp], edx

; 1213 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	eax, DWORD PTR __Bucket_hi$7[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_hi$6[ebp], ecx
$LN9@Unchecked_:

; 1214 :             for (;;) { // remove elements until we hit the end of the bucket
; 1215 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	cmp	eax, DWORD PTR __Old_hi$6[ebp]
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[ebp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[ebp], 0
$LN24@Unchecked_:
	mov	cl, BYTE PTR tv172[ebp]
	mov	BYTE PTR __At_bucket_back$5[ebp], cl

; 1216 :                 _Eraser._Bump_erased();

	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::_Bump_erased

; 1217 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR __At_bucket_back$5[ebp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1218 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1219 :                 }
; 1220 : 
; 1221 :                 if (_Eraser._Next == _Last) {

	mov	eax, DWORD PTR __Eraser$[ebp+8]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN17@Unchecked_

; 1222 :                     // erased the bucket's prefix
; 1223 :                     _Bucket_lo = _Eraser._Next;

	mov	eax, DWORD PTR __Bucket_lo$8[ebp]
	mov	ecx, DWORD PTR __Eraser$[ebp+8]
	mov	DWORD PTR [eax], ecx

; 1224 :                     return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN18@Unchecked_
$LN17@Unchecked_:

; 1225 :                 }
; 1226 :             }

	jmp	SHORT $LN9@Unchecked_
$LN8@Unchecked_:

; 1227 : 
; 1228 :             // emptied the bucket
; 1229 :             _Bucket_lo = _End;

	mov	eax, DWORD PTR __Bucket_lo$8[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	DWORD PTR [eax], ecx

; 1230 :             _Bucket_hi = _End;

	mov	eax, DWORD PTR __Bucket_hi$7[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	DWORD PTR [eax], ecx

; 1231 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1232 : 
; 1233 :         return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR __Eraser$[ebp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Range_eraser::~_Range_eraser
	mov	eax, DWORD PTR $T2[ebp]
$LN18@Unchecked_:

; 1234 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@Unchecked_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 448				; 000001c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN28@Unchecked_:
	DD	1
	DD	$LN27@Unchecked_
$LN27@Unchecked_:
	DD	-68					; ffffffbcH
	DD	12					; 0000000cH
	DD	$LN25@Unchecked_
$LN25@Unchecked_:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-452]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_erase
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::max_load_factor, COMDAT
; _this$ = ecx

; 1060 :     _NODISCARD float max_load_factor() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1061 :         return _Max_bucket_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IBEABMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
	fld	DWORD PTR [eax]

; 1062 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_load_factor@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::max_load_factor
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket, COMDAT
; _this$ = ecx

; 1004 :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 1005 :         return _Traitsobj(_Keyval) & _Mask;

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+32]

; 1006 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?bucket@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count, COMDAT
; _this$ = ecx

; 994  :     _NODISCARD size_type bucket_count() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 995  :         return _Maxidx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 996  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?bucket_count@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::bucket_count
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 959  :     _Unchecked_iterator _Unchecked_end() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 960  :         return _List._Unchecked_end();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_end
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 961  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_end
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 951  :     _Unchecked_iterator _Unchecked_begin() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 952  :         return _List._Unchecked_begin();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 953  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Unchecked_begin
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >, COMDAT
; _this$ = ecx

; 408  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Parg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > ><std::allocator<std::pair<int const ,unsigned char> > const &,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 8

; 409  :         // construct empty hash table
; 410  :         _Max_bucket_size() = _Bucket_size;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAEAAMXZ ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0

; 411  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_end
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAEXIV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::_Assign_grow

; 412  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 413  :         _Stl_internal_check_container_invariants();
; 414  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 415  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::~list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > > > > >
__ehhandler$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@@std@@IAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >::_Hash<std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :     const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1341 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z
_TEXT	SEGMENT
__Before_prev$ = -44					; size = 4
__Last_prev$ = -32					; size = 4
__First_prev$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__Before$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice, COMDAT

; 469  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 470  :         // splice [_First, _Last) before _Before; returns _Last
; 471  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 472  :         // 3 reads and 6 writes
; 473  : 
; 474  :         // fixup the _Next values
; 475  :         const auto _First_prev  = _First->_Prev;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __First_prev$[ebp], ecx

; 476  :         _First_prev->_Next      = _Last;

	mov	eax, DWORD PTR __First_prev$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Last_prev$[ebp], ecx

; 478  :         _Last_prev->_Next       = _Before;

	mov	eax, DWORD PTR __Last_prev$[ebp]
	mov	ecx, DWORD PTR __Before$[ebp]
	mov	DWORD PTR [eax], ecx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	eax, DWORD PTR __Before$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Before_prev$[ebp], ecx

; 480  :         _Before_prev->_Next     = _First;

	mov	eax, DWORD PTR __Before_prev$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	eax, DWORD PTR __Before$[ebp]
	mov	ecx, DWORD PTR __Last_prev$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 484  :         _Last->_Prev   = _First_prev;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First_prev$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 485  :         _First->_Prev  = _Before_prev;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Before_prev$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 486  : 
; 487  :         return _Last;

	mov	eax, DWORD PTR __Last$[ebp]

; 488  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@SAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@QAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Unchecked_splice
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnextnext$2 = -72					; size = 4
__Head$ = -60						; size = 4
__Pnext$ = -48						; size = 4
__Lock$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Orphan_non_end, COMDAT
; _this$ = ecx

; 377  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx

; 381  :         const auto _Head          = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Head$[ebp], ecx
$LN2@Orphan_non:

; 382  :         while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_non

; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnextnext$2[ebp], ecx

; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Head$[ebp]
	jne	SHORT $LN4@Orphan_non

; 385  :                 _Pnext = _Pnextnext;

	mov	eax, DWORD PTR __Pnextnext$2[ebp]
	mov	DWORD PTR __Pnext$[ebp], eax

; 386  :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_non
$LN4@Orphan_non:

; 387  :                 (*_Pnext)->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0

; 388  :                 *_Pnext             = *_Pnextnext;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR __Pnextnext$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@Orphan_non:

; 389  :             }
; 390  :         }

	jmp	SHORT $LN2@Orphan_non
$LN3@Orphan_non:

; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_non
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Orphan_non:
	DD	1
	DD	$LN9@Orphan_non
$LN9@Orphan_non:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN7@Orphan_non
$LN7@Orphan_non:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Orphan_non_end
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >, COMDAT
; _this$ = ecx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 1772 :     const _Alnode& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1773 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first

; 1774 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 1768 :     _Alnode& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1769 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Get_first

; 1770 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Newhead$ = -88					; size = 4
__Al$ = -76						; size = 4
__Proxy$ = -64						; size = 8
_$S16$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1753 :     void _Alloc_sentinel_and_proxy() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1754 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S16$[ebp]
	call	??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<int const ,unsigned char>,void *> >
	lea	eax, DWORD PTR _$S16$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 1755 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1756 :         auto& _Al     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1757 :         auto _Newhead = _Al.allocate(1);

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocate
	mov	DWORD PTR __Newhead$[ebp], eax

; 1758 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	lea	eax, DWORD PTR __Newhead$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newhead$[ebp]
	push	ecx
	call	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
	add	esp, 8

; 1759 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	lea	eax, DWORD PTR __Newhead$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newhead$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned char>,void *> *,std::_List_node<std::pair<int const ,unsigned char>,void *> * &>
	add	esp, 8

; 1760 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newhead$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1761 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 1762 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Alloc_sent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@Alloc_sent:
	DD	3
	DD	$LN8@Alloc_sent
$LN8@Alloc_sent:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN4@Alloc_sent
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN5@Alloc_sent
	DD	-88					; ffffffa8H
	DD	4
	DD	$LN6@Alloc_sent
$LN6@Alloc_sent:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$LN5@Alloc_sent:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN4@Alloc_sent:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__ehhandler$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Alloc_sentinel_and_proxy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Tidy, COMDAT
; _this$ = ecx

; 1416 :     void _Tidy() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1417 :         auto& _Al      = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1418 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1419 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1420 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 1421 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 1422 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::clear, COMDAT
; _this$ = ecx

; 1406 :     void clear() noexcept { // erase all

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1407 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1408 :         _My_data._Orphan_non_end();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Orphan_non_end

; 1409 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	push	eax
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 1410 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 1411 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 1412 :         _My_data._Mysize        = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1413 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::clear
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
_TEXT	SEGMENT
__Next$2 = -132						; size = 4
__Erasures$ = -120					; size = 4
__Al$ = -108						; size = 4
__Pnextnext$3 = -96					; size = 4
__Pnext$4 = -84						; size = 4
__Marked$5 = -72					; size = 4
__Lock$6 = -60						; size = 4
__Head$ = -48						; size = 4
__Predecessor$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1356 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept { // erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1357 :         if (_First == _Last) {

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN10@Unchecked_

; 1358 :             return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
	jmp	$LN15@Unchecked_
$LN10@Unchecked_:

; 1359 :         }
; 1360 : 
; 1361 :         const auto _Predecessor = _First->_Prev;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Predecessor$[ebp], ecx

; 1362 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1363 :         const auto _Head = _Mypair._Myval2._Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Head$[ebp], ecx

; 1364 :         if (_First == _Head->_Next && _Last == _Head) { // orphan all non-end iterators

	mov	eax, DWORD PTR __Head$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN11@Unchecked_
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Head$[ebp]
	jne	SHORT $LN11@Unchecked_

; 1365 :             _Mypair._Myval2._Orphan_non_end();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >::_Orphan_non_end

; 1366 :         } else { // orphan erased iterators

	jmp	$LN12@Unchecked_
$LN11@Unchecked_:

; 1367 :             _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$6[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1368 :             for (auto _Marked = _First; _Marked != _Last; _Marked = _Marked->_Next) { // mark erased nodes

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Marked$5[ebp], eax
	jmp	SHORT $LN4@Unchecked_
$LN2@Unchecked_:
	mov	eax, DWORD PTR __Marked$5[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Marked$5[ebp], ecx
$LN4@Unchecked_:
	mov	eax, DWORD PTR __Marked$5[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Unchecked_

; 1369 :                 _Marked->_Prev = nullptr;

	mov	eax, DWORD PTR __Marked$5[ebp]
	mov	DWORD PTR [eax+4], 0

; 1370 :             }

	jmp	SHORT $LN2@Unchecked_
$LN3@Unchecked_:

; 1371 : 
; 1372 :             _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$4[ebp], ecx
$LN5@Unchecked_:

; 1373 :             while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$4[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Unchecked_

; 1374 :                 _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$4[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnextnext$3[ebp], ecx

; 1375 :                 if (static_cast<const_iterator&>(**_Pnext)._Ptr->_Prev) { // node still has a _Prev, skip

	mov	eax, DWORD PTR __Pnext$4[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN13@Unchecked_

; 1376 :                     _Pnext = _Pnextnext;

	mov	eax, DWORD PTR __Pnextnext$3[ebp]
	mov	DWORD PTR __Pnext$4[ebp], eax

; 1377 :                 } else { // orphan the iterator

	jmp	SHORT $LN14@Unchecked_
$LN13@Unchecked_:

; 1378 :                     (*_Pnext)->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$4[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0

; 1379 :                     *_Pnext             = *_Pnextnext;

	mov	eax, DWORD PTR __Pnext$4[ebp]
	mov	ecx, DWORD PTR __Pnextnext$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN14@Unchecked_:

; 1380 :                 }
; 1381 :             }

	jmp	SHORT $LN5@Unchecked_
$LN6@Unchecked_:

; 1382 : 
; 1383 :             // _Prev pointers not restored because we're about to delete the nodes of which they are a member anyway
; 1384 :         }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$6[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@Unchecked_:

; 1385 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1386 : 
; 1387 :         // snip out the removed range
; 1388 :         _Predecessor->_Next = _Last;

	mov	eax, DWORD PTR __Predecessor$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx

; 1389 :         _Last->_Prev        = _Predecessor;

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Predecessor$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1390 : 
; 1391 :         // count and deallocate the removed nodes
; 1392 :         auto& _Al           = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 1393 :         size_type _Erasures = 0;

	mov	DWORD PTR __Erasures$[ebp], 0
$LN9@Unchecked_:

; 1394 :         do {
; 1395 :             const auto _Next = _First->_Next;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Next$2[ebp], ecx

; 1396 :             _Node::_Freenode(_Al, _First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@PAU01@@Z ; std::_List_node<std::pair<int const ,unsigned char>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >
	add	esp, 8

; 1397 :             _First = _Next;

	mov	eax, DWORD PTR __Next$2[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1398 :             ++_Erasures;

	mov	eax, DWORD PTR __Erasures$[ebp]
	add	eax, 1
	mov	DWORD PTR __Erasures$[ebp], eax

; 1399 :         } while (_First != _Last);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN9@Unchecked_

; 1400 : 
; 1401 :         _Mypair._Myval2._Mysize -= _Erasures;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR __Erasures$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1402 :         return _Last;

	mov	eax, DWORD PTR __Last$[ebp]
$LN15@Unchecked_:

; 1403 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@Unchecked_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN19@Unchecked_:
	DD	1
	DD	$LN18@Unchecked_
$LN18@Unchecked_:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN16@Unchecked_
$LN16@Unchecked_:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_erase@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@PAU32@QAU32@@Z ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_erase
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::max_size, COMDAT
; _this$ = ecx

; 1174 :     _NODISCARD size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1175 :         return _Min_value(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@ABEABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::max_size
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1176 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1177 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1095 :     _Unchecked_iterator _Unchecked_end() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1096 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1097 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_end@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_end
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1087 :     _Unchecked_iterator _Unchecked_begin() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1088 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@$$CBHE@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@1@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1089 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Unchecked_begin@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Unchecked_begin
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_$S2$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::~list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >, COMDAT
; _this$ = ecx

; 1025 :     ~list() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4

; 1026 :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Tidy

; 1027 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1028 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S2$[ebp]
	call	??$?0U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<int const ,unsigned char>,void *> >
	lea	eax, DWORD PTR _$S2$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 1029 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1030 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1031 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@list
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@list:
	DD	1
	DD	$LN5@list
$LN5@list:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@list
$LN3@list:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	50					; 00000032H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::~list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\list
;	COMDAT ??0?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??0?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z PROC ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >, COMDAT
; _this$ = ecx

; 787  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DE98524E_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0ABV?$allocator@U?$pair@$$CBHE@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHE@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned char> > >,1><std::allocator<std::pair<int const ,unsigned char> > const &>

; 788  :         _Alloc_sentinel_and_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@AAEXXZ ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::_Alloc_sentinel_and_proxy

; 789  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$list@U?$pair@$$CBHE@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHE@std@@@1@@Z ENDP ; std::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >::list<std::pair<int const ,unsigned char>,std::allocator<std::pair<int const ,unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::max_size, COMDAT

; 679  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 268435455				; 0fffffffH

; 681  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::deallocate, COMDAT

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 667  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@2@QAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocate, COMDAT
; _this$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$0BA@@std@@YAII@Z	; std::_Get_size_of_n<16>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 785  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEXQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEXQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHE@std@@PAX@std@@@std@@QAEXQAU?$_List_node@U?$pair@$$CBHE@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,unsigned char>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,unsigned char> >::allocator<std::pair<int const ,unsigned char> >, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$allocator@U?$pair@$$CBHE@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,unsigned char> >::allocator<std::pair<int const ,unsigned char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\unordered_map
;	COMDAT ??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Traits$ = 8						; size = 4
??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z PROC ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>, COMDAT
; _this$ = ecx

; 51   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __32C29690_unordered_map
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Traits$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Umap_traits@HEV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHE@std@@@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ENDP ; std::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>::_Umap_traits<int,unsigned char,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned char> >,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :     const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1341 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :     const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1341 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??R?$equal_to@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@H@std@@QBE_NABH0@Z PROC			; std::equal_to<int>::operator(), COMDAT
; _this$ = ecx

; 90   :     constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 92   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??R?$equal_to@H@std@@QBE_NABH0@Z ENDP			; std::equal_to<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 188  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 189  :         return _Mypair._Myval2._Myval2;

	mov	eax, DWORD PTR _this$[ebp]

; 190  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 184  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4

; 185  :         return _Mypair._Myval2._Myval2;

	mov	eax, DWORD PTR _this$[ebp]

; 186  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xhash
;	COMDAT ??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -245						; size = 1
$T3 = -233						; size = 1
$T4 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >, COMDAT
; _this$ = ecx

; 161  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __AFECAA51_xhash
	call	@__CheckForDebuggerJustMyCode@4
	xorps	xmm0, xmm0
	movss	DWORD PTR $T4[ebp], xmm0
	xor	eax, eax
	mov	BYTE PTR $T3[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T2[ebp], cl
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@$$QAU21@$$QAM@Z ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@XZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?checkState@Window@@SAEH@Z
_TEXT	SEGMENT
_last$ = -29						; size = 1
_now$ = -17						; size = 1
_state$ = -5						; size = 1
_key$ = 8						; size = 4
?checkState@Window@@SAEH@Z PROC				; Window::checkState, COMDAT

; 109  : byte Window::checkState(int key) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 110  : 	
; 111  : 	byte state;
; 112  : 	boolean now=keys[key];

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, OFFSET ?keys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _now$[ebp], cl

; 113  : 	boolean last = lastkeys[key];

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, OFFSET ?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _last$[ebp], cl

; 114  : 
; 115  : 	if (last==true) {

	movzx	eax, BYTE PTR _last$[ebp]
	cmp	eax, 1
	jne	SHORT $LN2@checkState

; 116  : 		if (now==true) {

	movzx	eax, BYTE PTR _now$[ebp]
	cmp	eax, 1
	jne	SHORT $LN4@checkState

; 117  : 			state = 3;

	mov	BYTE PTR _state$[ebp], 3

; 118  : 		}

	jmp	SHORT $LN5@checkState
$LN4@checkState:

; 119  : 		else {
; 120  : 			state = 2;

	mov	BYTE PTR _state$[ebp], 2
$LN5@checkState:

; 121  : 		}
; 122  : 
; 123  : 	}

	jmp	SHORT $LN3@checkState
$LN2@checkState:

; 124  : 
; 125  : 
; 126  : 	else {
; 127  : 		if (now==true) {

	movzx	eax, BYTE PTR _now$[ebp]
	cmp	eax, 1
	jne	SHORT $LN6@checkState

; 128  : 			state = 1;

	mov	BYTE PTR _state$[ebp], 1

; 129  : 		}

	jmp	SHORT $LN3@checkState
$LN6@checkState:

; 130  : 		else {
; 131  : 			state = 0;

	mov	BYTE PTR _state$[ebp], 0
$LN3@checkState:

; 132  : 		}
; 133  : 
; 134  : 	}
; 135  : 
; 136  : 
; 137  : 	lastkeys[key] = now;

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, OFFSET ?lastkeys@@3V?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@A
	call	??A?$unordered_map@HEU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHE@std@@@2@@std@@QAEAAEABH@Z ; std::unordered_map<int,unsigned char,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned char> > >::operator[]
	mov	cl, BYTE PTR _now$[ebp]
	mov	BYTE PTR [eax], cl

; 138  : 	return state;

	mov	al, BYTE PTR _state$[ebp]

; 139  : 
; 140  : 
; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?checkState@Window@@SAEH@Z ENDP				; Window::checkState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?SHouldExit@Window@@QAEEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?SHouldExit@Window@@QAEEXZ PROC				; Window::SHouldExit, COMDAT
; _this$ = ecx

; 99   : boolean Window::SHouldExit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 100  : 
; 101  : 	return glfwWindowShouldClose(window);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_glfwWindowShouldClose
	add	esp, 4

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SHouldExit@Window@@QAEEXZ ENDP				; Window::SHouldExit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?Destroy@Window@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Destroy@Window@@QAEXXZ PROC				; Window::Destroy, COMDAT
; _this$ = ecx

; 103  : void Window::Destroy() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 104  : 	glfwDestroyWindow(window);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_glfwDestroyWindow
	add	esp, 4

; 105  : 	
; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Destroy@Window@@QAEXXZ ENDP				; Window::Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?clear@Window@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@Window@@QAEXXZ PROC				; Window::clear, COMDAT
; _this$ = ecx

; 96   : void Window::clear() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 97   : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//this polls all the input 

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@Window@@QAEXXZ ENDP				; Window::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?Render@Window@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Render@Window@@QAEXXZ PROC				; Window::Render, COMDAT
; _this$ = ecx

; 87   : void Window::Render() {///swap buffers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 88   : 
; 89   : 
; 90   : 	glfwSwapBuffers(window);//swaps the last screen buffer with the current one so that the image can be viewed 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_glfwSwapBuffers
	add	esp, 4

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@Window@@QAEXXZ ENDP				; Window::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?Update@Window@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Update@Window@@QAEXXZ PROC				; Window::Update, COMDAT
; _this$ = ecx

; 92   : void Window::Update() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 93   : 	glfwPollEvents();//this polls all the input 

	call	_glfwPollEvents

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Update@Window@@QAEXXZ ENDP				; Window::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?getHeight@Window@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getHeight@Window@@QAEHXZ PROC				; Window::getHeight, COMDAT
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 81   : 	return height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@Window@@QAEHXZ ENDP				; Window::getHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?getWidth@Window@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getWidth@Window@@QAEHXZ PROC				; Window::getWidth, COMDAT
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 76   : 	return width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@Window@@QAEHXZ ENDP				; Window::getWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?getWindow@Window@@QAEAAUGLFWwindow@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getWindow@Window@@QAEAAUGLFWwindow@@XZ PROC		; Window::getWindow, COMDAT
; _this$ = ecx

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 71   : 	return *window;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getWindow@Window@@QAEAAUGLFWwindow@@XZ ENDP		; Window::getWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ??0Window@@QAE@HHQBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_name$ = 16						; size = 4
??0Window@@QAE@HHQBD@Z PROC				; Window::Window, COMDAT
; _this$ = ecx

; 34   : Window::Window(int width, int height, const char name[]) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 35   : 	if (!glfwInit()) {

	call	_glfwInit
	test	eax, eax
	jne	SHORT $LN2@Window

; 36   : 		exit(-1);

	mov	esi, esp
	push	-1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Window:

; 37   : 	}
; 38   : 	/* Create a windowed mode window and its OpenGL context */
; 39   : 
; 40   : 	glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);

	push	1
	push	131077					; 00020005H
	call	_glfwWindowHint
	add	esp, 8

; 41   : 
; 42   : 	window = glfwCreateWindow(width, height, name, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_glfwCreateWindow
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 43   : 	if (!window)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Window

; 44   : 	{
; 45   : 		glfwTerminate();

	call	_glfwTerminate

; 46   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Window:

; 47   : 	}
; 48   : 
; 49   : 	/* Make the window's context current */
; 50   : 	glfwMakeContextCurrent(window);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_glfwMakeContextCurrent
	add	esp, 4

; 51   : 	
; 52   : 	
; 53   : 	if (glewInit() != GLEW_OK) {

	call	_glewInit@0
	test	eax, eax
	je	SHORT $LN4@Window

; 54   : 		std::cout << "problem" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_07LIJFLNDM@problem@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 55   : 		exit(7);

	mov	esi, esp
	push	7
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@Window:

; 56   : 	}
; 57   : 	
; 58   : 	glEnable(GL_TEXTURE_2D);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 59   : 	glEnable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 60   : 	//glEnable(GL_CULL_FACE);
; 61   : 	
; 62   : 	//glCullFace(GL_BACK);
; 63   : 	glEnable(GL_BLEND);

	mov	esi, esp
	push	3042					; 00000be2H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 64   : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	mov	esi, esp
	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 65   : 	glfwSetKeyCallback(window,callback);

	mov	eax, DWORD PTR ?callback@@3P6AXPAUGLFWwindow@@HHHH@ZA ; callback
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_glfwSetKeyCallback
	add	esp, 8

; 66   : 	glfwSwapInterval(0);

	push	0
	call	_glfwSwapInterval
	add	esp, 4

; 67   : }

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Window:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Window@@QAE@HHQBD@Z ENDP				; Window::Window
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAKI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Value$ = 8						; size = 4
?_Ceiling_of_log_2@std@@YAKI@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 49   : _NODISCARD inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { // returns ceil(log_2(_Value))

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ceiling_of_log_2@std@@YAKI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __5A557807_xbit_ops@h
	call	@__CheckForDebuggerJustMyCode@4

; 50   :                                                                                   // pre: _Value > 1
; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	mov	eax, DWORD PTR __Value$[ebp]
	sub	eax, 1
	push	eax
	call	?_Floor_of_log_2@std@@YAKI@Z		; std::_Floor_of_log_2
	add	esp, 4
	add	eax, 1

; 52   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Ceiling_of_log_2@std@@YAKI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ceiling_of_log_2@std@@YAKI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ceiling_of_log_2@std@@YAKI@Z ENDP			; std::_Ceiling_of_log_2
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAKI@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Value$ = 8						; size = 4
?_Floor_of_log_2@std@@YAKI@Z PROC			; std::_Floor_of_log_2, COMDAT

; 23   : _NODISCARD inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { // returns floor(log_2(_Value))

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Floor_of_log_2@std@@YAKI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __5A557807_xbit_ops@h
	call	@__CheckForDebuggerJustMyCode@4

; 24   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	mov	eax, DWORD PTR __Value$[ebp]
	or	eax, 1
	mov	DWORD PTR __Value$[ebp], eax

; 25   :     unsigned long _Result;
; 26   : 
; 27   : #ifdef _M_CEE_PURE
; 28   : #ifdef _WIN64
; 29   :     _Result = 63;
; 30   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 31   :     _Result = 31;
; 32   : #endif // 64 vs. 32-bit
; 33   : 
; 34   :     while ((size_t{1} << _Result) > _Value) {
; 35   :         --_Result;
; 36   :     }
; 37   : 
; 38   : #else // ^^^ _M_CEE_PURE ^^^ // vvv !_M_CEE_PURE vvv
; 39   : #ifdef _WIN64
; 40   :     _BitScanReverse64(&_Result, _Value);
; 41   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 42   :     _BitScanReverse(&_Result, _Value);

	bsr	eax, DWORD PTR __Value$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 43   : #endif // 64 vs. 32-bit
; 44   : #endif // _M_CEE_PURE
; 45   : 
; 46   :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 47   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Floor_of_l
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Floor_of_l:
	DD	1
	DD	$LN5@Floor_of_l
$LN5@Floor_of_l:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Floor_of_l
$LN3@Floor_of_l:
	DB	95					; 0000005fH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Floor_of_log_2@std@@YAKI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Floor_of_log_2@std@@YAKI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Floor_of_log_2@std@@YAKI@Z ENDP			; std::_Floor_of_log_2
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 201  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$tuple@$$V@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$tuple@$$V@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$tuple@$$V@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$tuple@$$V@std@@QAE@XZ PROC				; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 199  :     constexpr tuple() noexcept /* strengthened */ {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$tuple@$$V@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __66607376_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$tuple@$$V@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$tuple@$$V@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$tuple@$$V@std@@QAE@XZ ENDP				; std::tuple<>::tuple<>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ?_Do_hash@?$hash@H@std@@SAIABH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
?_Do_hash@?$hash@H@std@@SAIABH@Z PROC			; std::hash<int>::_Do_hash, COMDAT

; 2143 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Do_hash@?$hash@H@std@@SAIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2144 :         return _Hash_representation(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	call	??$_Hash_representation@H@std@@YAIABH@Z	; std::_Hash_representation<int>
	add	esp, 4

; 2145 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Do_hash@?$hash@H@std@@SAIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Do_hash@?$hash@H@std@@SAIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Do_hash@?$hash@H@std@@SAIABH@Z ENDP			; std::hash<int>::_Do_hash
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z PROC ; std::_Conditionally_enabled_hash<int,1>::operator(), COMDAT
; _this$ = ecx

; 2123 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2124 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	call	?_Do_hash@?$hash@H@std@@SAIABH@Z	; std::hash<int>::_Do_hash
	add	esp, 4

; 2125 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z ENDP ; std::_Conditionally_enabled_hash<int,1>::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -220						; size = 4
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 29   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Min_value@I@std@@YAABIABI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Min_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Min_value
$LN3@Min_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]

; 31   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Min_value@I@std@@YAABIABI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Min_value@I@std@@YAABIABI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 404  :     _NODISCARD static constexpr int_type eof() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 405  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 406  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 397  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 398  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 309  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 310  :         // find length of null-terminated string
; 311  : #if _HAS_CXX17
; 312  : #ifdef __cpp_char8_t
; 313  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 314  : #if _HAS_U8_INTRINSICS
; 315  :             return __builtin_u8strlen(_First);
; 316  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 317  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 318  : #endif // _HAS_U8_INTRINSICS
; 319  :         } else
; 320  : #endif // __cpp_char8_t
; 321  :         {
; 322  :             return __builtin_strlen(_First);
; 323  :         }
; 324  : #else // _HAS_CXX17
; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 326  : #endif // _HAS_CXX17
; 327  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1261 :     void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1262 :         _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1263 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$2 = -48						; size = 4
__Lock$3 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1201 : inline void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1202 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1203 :     if (_Myproxy) { // proxy allocated, drain it

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_all

; 1204 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1205 : 
; 1206 :         for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$2[ebp], ecx
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$2[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_all

; 1207 :             (*_Pnext)->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0

; 1208 :         }

	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1209 : 
; 1210 :         _Myproxy->_Myfirstiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 1211 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Orphan_all:

; 1212 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1213 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN7@Orphan_all
$LN7@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1088 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Container_base12@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Container_base12@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Container_base12@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1080 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1068 :     void _Adopt(const void*) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Adopt@_Iterator_base0@std@@QAEXPBX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 106  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 107  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 108  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN7@Adjust_man
	jmp	SHORT $LN2@Adjust_man
$LN7@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN2@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN4@Adjust_man

; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN13@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN13@Adjust_man
	jmp	SHORT $LN8@Adjust_man
$LN13@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN8@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN10@Adjust_man

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax], ecx

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 50   :     _DECLSPEC_ALLOCATOR static void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 51   :         return ::operator new(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 52   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 557  :     _NODISCARD static constexpr int(max)() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max@?$numeric_limits@H@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __CDF80030_limits
	call	@__CheckForDebuggerJustMyCode@4

; 558  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 559  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max@?$numeric_limits@H@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max@?$numeric_limits@H@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 322  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __CB7CF65A_exception
	call	@__CheckForDebuggerJustMyCode@4

; 323  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Throw_bad_:

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_array_new_length@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 138  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_array_new_length@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 137  :         : bad_alloc("bad array new length")

	push	OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@AAE@QBD@Z		; std::bad_alloc::bad_alloc

; 138  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 139  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0bad_array_new_length@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 127  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@AAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 126  :         : exception(_Message, 1)

	push	1
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 127  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 128  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0bad_alloc@std@@AAE@QBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1exception@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 87   :         __std_exception_destroy(&_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_destroy
	add	esp, 4

; 88   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0exception@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 68   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 71   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0exception@std@@QAE@QBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 62   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 64   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 65   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@QBDH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@QBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YAIIQBEI@Z
_TEXT	SEGMENT
__Idx$2 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
__First$ = 12						; size = 4
__Count$ = 16						; size = 4
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2073 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Fnv1a_append_bytes@std@@YAIIQBEI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2074 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	DWORD PTR __Idx$2[ebp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	eax, DWORD PTR __Idx$2[ebp]
	add	eax, 1
	mov	DWORD PTR __Idx$2[ebp], eax
$LN4@Fnv1a_appe:
	mov	eax, DWORD PTR __Idx$2[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@Fnv1a_appe

; 2075 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	eax, DWORD PTR __First$[ebp]
	add	eax, DWORD PTR __Idx$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$[ebp], ecx

; 2076 :         _Val *= _FNV_prime;

	imul	eax, DWORD PTR __Val$[ebp], 16777619
	mov	DWORD PTR __Val$[ebp], eax

; 2077 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2078 : 
; 2079 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]

; 2080 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Fnv1a_append_bytes@std@@YAIIQBEI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fnv1a_append_bytes@std@@YAIIQBEI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z ENDP		; std::_Fnv1a_append_bytes
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv74 = -196						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 643  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __09340588_corecrt_math@h
	call	@__CheckForDebuggerJustMyCode@4

; 644  :             return (float)ceil(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	mov	esi, esp
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 645  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??2@YAPAXIPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __BD3EDE1B_vcruntime_new@h
	call	@__CheckForDebuggerJustMyCode@4

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 171  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??2@YAPAXIPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??2@YAPAXIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\WIndow.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0BC8076B_WIndow@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
