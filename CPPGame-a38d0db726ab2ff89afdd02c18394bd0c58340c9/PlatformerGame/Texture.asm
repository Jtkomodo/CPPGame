; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28315.0 

	TITLE	D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__BD3EDE1B_vcruntime_new@h DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__367CC694_corecrt_memcpy_s@h DB 01H
__35D7DDB3_corecrt_memory@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__5467428D_corecrt_wconio@h DB 01H
__4442441F_corecrt_wio@h DB 01H
__45F4AF76_corecrt_wtime@h DB 01H
__186FF47F_stat@h DB 01H
__534C724A_wchar@h DB 01H
__09340588_corecrt_math@h DB 01H
__24E9E95F_stdlib@h DB 01H
__EC2FBCF1_cstdlib DB 01H
__CDF80030_limits DB 01H
__4877352E_type_traits DB 01H
__B0C4CEA9_malloc@h DB 01H
__CFCEF810_vcruntime_exception@h DB 01H
__CB7CF65A_exception DB 01H
__45864D8F_xutility DB 01H
__B1B75AB9_xmemory DB 01H
__C564DC25_xstring DB 01H
__7242C389_ctype@h DB 01H
__05858A22_string DB 01H
__62D6DAAC_xmmintrin@h DB 01H
__AA12E9A8_stb_image@h DB 01H
__C0436A37_cmath DB 01H
__4232CC07_stdexcept DB 01H
__34C7AB85_xcall_once@h DB 01H
__8B9AB9A5_system_error DB 01H
__60622685_vcruntime_typeinfo@h DB 01H
__3559BE96_typeinfo DB 01H
__71560CBE_memory DB 01H
__5D135BB1_xfacet DB 01H
__2AD05D5E_xlocinfo DB 01H
__1A5AA814_xlocale DB 01H
__13352A4D_xiosbase DB 01H
__84DDCE03_xlocnum DB 01H
__735DEEF4_ios DB 01H
__2514D6BD_Texture@h DB 01H
__2ED228C6_Texture@cpp DB 01H
__6A9A47EA_istream DB 01H
__094A72D0_ostream DB 01H
__409274BB_streambuf DB 01H
__0111D5B6_iosfwd DB 01H
__DB22397A_utility DB 01H
__2C3DAE68_xstddef DB 01H
__C1707A8C_xatomic@h DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?stbi__bmask@@3QBIB DD 00H				; stbi__bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
?rgb@?BC@??stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z@4QBEB DB 052H ; `stbi__process_frame_header'::`18'::rgb
	DB	047H
	DB	042H
	ORG $+1
?stbi__jbias@@3QBHB DD 00H				; stbi__jbias
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
?stbi__jpeg_dezigzag@@3QBEB DB 00H			; stbi__jpeg_dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
?tag@?CL@??stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z@4QBEB DB 04aH ; `stbi__process_marker'::`43'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	ORG $+3
?tag@?DE@??stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z@4QBEB DB 041H ; `stbi__process_marker'::`52'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
	ORG $+2
?stbi__zlength_base@@3QBHB DD 03H			; stbi__zlength_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zlength_extra@@3QBHB DD 00H			; stbi__zlength_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zdist_base@@3QBHB DD 01H				; stbi__zdist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?stbi__zdist_extra@@3QBHB DD 00H			; stbi__zdist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	DD	00H
	DD	00H
?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4QBEB DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+5
?stbi__zdefault_length@@3QBEB DB 08H			; stbi__zdefault_length
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?stbi__zdefault_distance@@3QBEB DB 05H			; stbi__zdefault_distance
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?png_sig@?1??stbi__check_png_header@@YAHPAUstbi__context@@@Z@4QBEB DB 089H ; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
?stbi__depth_scale_table@@3QBEB DB 00H			; stbi__depth_scale_table
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Texture::Texture
PUBLIC	??1Texture@@QAE@XZ				; Texture::~Texture
PUBLIC	?Bind@Texture@@QAEXI@Z				; Texture::Bind
PUBLIC	?unBind@Texture@@QAEXXZ				; Texture::unBind
PUBLIC	_stbi_load_from_memory
PUBLIC	_stbi_load_from_callbacks
PUBLIC	_stbi_load
PUBLIC	_stbi_load_from_file
PUBLIC	_stbi_load_gif_from_memory
PUBLIC	_stbi_load_16_from_memory
PUBLIC	_stbi_load_16_from_callbacks
PUBLIC	_stbi_load_16
PUBLIC	_stbi_load_from_file_16
PUBLIC	_stbi_loadf_from_memory
PUBLIC	_stbi_loadf_from_callbacks
PUBLIC	_stbi_loadf
PUBLIC	_stbi_loadf_from_file
PUBLIC	_stbi_hdr_to_ldr_gamma
PUBLIC	_stbi_hdr_to_ldr_scale
PUBLIC	_stbi_ldr_to_hdr_gamma
PUBLIC	_stbi_ldr_to_hdr_scale
PUBLIC	_stbi_is_hdr_from_callbacks
PUBLIC	_stbi_is_hdr_from_memory
PUBLIC	_stbi_is_hdr
PUBLIC	_stbi_is_hdr_from_file
PUBLIC	_stbi_failure_reason
PUBLIC	_stbi_image_free
PUBLIC	_stbi_info_from_memory
PUBLIC	_stbi_info_from_callbacks
PUBLIC	_stbi_is_16_bit_from_memory
PUBLIC	_stbi_is_16_bit_from_callbacks
PUBLIC	_stbi_info
PUBLIC	_stbi_info_from_file
PUBLIC	_stbi_is_16_bit
PUBLIC	_stbi_is_16_bit_from_file
PUBLIC	_stbi_set_unpremultiply_on_load
PUBLIC	_stbi_convert_iphone_png_to_rgb
PUBLIC	_stbi_set_flip_vertically_on_load
PUBLIC	_stbi_zlib_decode_malloc_guesssize
PUBLIC	_stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	_stbi_zlib_decode_malloc
PUBLIC	_stbi_zlib_decode_buffer
PUBLIC	_stbi_zlib_decode_noheader_malloc
PUBLIC	_stbi_zlib_decode_noheader_buffer
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem@			; `string'
PUBLIC	?__LINE__Var@?0??stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z@4JA ; `stbi__load_and_postprocess_8bit'::`1'::__LINE__Var
PUBLIC	??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@ ; `string'
PUBLIC	??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z@4JA ; `stbi__load_and_postprocess_16bit'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen@		; `string'
PUBLIC	?__LINE__Var@?0??stbi__convert_format@@YAPAEPAEHHII@Z@4JA ; `stbi__convert_format'::`1'::__LINE__Var
PUBLIC	??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	?__LINE__Var@?0??stbi__convert_format16@@YAPAGPAGHHII@Z@4JA ; `stbi__convert_format16'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths@		; `string'
PUBLIC	?__LINE__Var@?0??stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z@4JA ; `stbi__jpeg_huff_decode'::`1'::__LINE__Var
PUBLIC	??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z@4JA ; `stbi__extend_receive'::`1'::__LINE__Var
PUBLIC	??_C@_1IA@IKCMGFNK@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI@ ; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code@		; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@	; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker@		; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@	; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len@		; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit@			; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height@		; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width@			; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large@			; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height@		; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp@		; `string'
PUBLIC	?__LINE__Var@?0??stbi__bit_reverse@@YAHHH@Z@4JA	; `stbi__bit_reverse'::`1'::__LINE__Var
PUBLIC	??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ ; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes@			; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths@		; `string'
PUBLIC	?__LINE__Var@?0??stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z@4JA ; `stbi__fill_bits'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z@4JA ; `stbi__zhuffman_decode_slowpath'::`1'::__LINE__Var
PUBLIC	??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs@ ; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit@	; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist@			; `string'
PUBLIC	?__LINE__Var@?0??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4JA ; `stbi__compute_huffman_codes'::`1'::__LINE__Var
PUBLIC	??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z@4JA ; `stbi__parse_uncompressed_block'::`1'::__LINE__Var
PUBLIC	??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer@		; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header@		; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression@		; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig@		; `string'
PUBLIC	?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA ; `stbi__create_png_image_raw'::`1'::__LINE__Var
PUBLIC	??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ ; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels@		; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter@		; `string'
PUBLIC	??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs@ ; `string'
PUBLIC	??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z@4JA ; `stbi__compute_transparency'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ ; `string'
PUBLIC	?__LINE__Var@?0??stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z@4JA ; `stbi__compute_transparency16'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??stbi__de_iphone@@YAXPAUstbi__png@@@Z@4JA ; `stbi__de_iphone'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@	; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype@			; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method@		; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method@		; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@		; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@		; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@		; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE@			; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT@			; `string'
PUBLIC	?__LINE__Var@?0??stbi__shiftsigned@@YAHIHH@Z@4JA ; `stbi__shiftsigned'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@LIEKLNBF@?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2@ ; `string'
PUBLIC	??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ ; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP@			; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP@			; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks@			; `string'
PUBLIC	?__LINE__Var@?0??stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z@4JA ; `stbi__tga_load'::`1'::__LINE__Var
PUBLIC	??_C@_0L@DMAPJJO@bad?5format@			; `string'
PUBLIC	??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ ; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette@			; `string'
PUBLIC	??_C@_07ECNCNLIK@not?5PSD@			; `string'
PUBLIC	??_C@_0O@CHBCDKKC@wrong?5version@		; `string'
PUBLIC	??_C@_0BE@PJBNGDBE@wrong?5channel?5count@	; `string'
PUBLIC	??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@	; `string'
PUBLIC	??_C@_0BD@IOGGBMNK@wrong?5color?5format@	; `string'
PUBLIC	??_C@_07DPPMCAKL@corrupt@			; `string'
PUBLIC	??_C@_04KBFEPHFH@S?$IA?v4@			; `string'
PUBLIC	??_C@_04ELNJHLFH@PICT@				; `string'
PUBLIC	??_C@_08GGMBIFE@bad?5file@			; `string'
PUBLIC	??_C@_07KMJLPAII@not?5GIF@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0O@MGDACKOJ@no?5clear?5code@		; `string'
PUBLIC	??_C@_0P@GJNJCPDJ@too?5many?5codes@		; `string'
PUBLIC	??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@	; `string'
PUBLIC	??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@	; `string'
PUBLIC	??_C@_0BE@NAMJKDNF@missing?5color?5table@	; `string'
PUBLIC	??_C@_0N@DJABBOOH@unknown?5code@		; `string'
PUBLIC	??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@		; `string'
PUBLIC	??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@		; `string'
PUBLIC	??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@		; `string'
PUBLIC	??_C@_06NDOKKIDJ@?$CD?$DPRGBE@			; `string'
PUBLIC	??_C@_07NCIOKENI@not?5HDR@			; `string'
PUBLIC	??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@	; `string'
PUBLIC	??_C@_0BD@NKJFFLKL@unsupported?5format@		; `string'
PUBLIC	??_C@_03HKAKGGJN@?9Y?5@				; `string'
PUBLIC	??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@	; `string'
PUBLIC	??_C@_03FOKDFDHG@?$CLX?5@			; `string'
PUBLIC	??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ ; `string'
PUBLIC	??_C@_0BA@OLLEAHAM@max?5value?5?$DO?5255@	; `string'
PUBLIC	??_C@_0BC@MIBMIPKG@src?1res?1Textures?1@	; `string'
PUBLIC	??_C@_04EEOGCCFB@?4png@				; `string'
PUBLIC	??_C@_0BH@PIKNLKAJ@?5could?5not?5be?5found?$CB?$CB?$CB@ ; `string'
PUBLIC	??_C@_09LDDNJKDN@the?5file?5@			; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@437f0000
PUBLIC	__real@46180000
PUBLIC	__real@477fff00
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_abs:PROC
EXTRN	_pow:PROC
EXTRN	__imp__ldexp:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__lrotl:PROC
EXTRN	__imp__strtol:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glDeleteTextures@8:PROC
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	__imp__glPixelStorei@8:PROC
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	__imp__glTexParameterf@12:PROC
EXTRN	__imp___wassert:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___glewActiveTexture:DWORD
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?stbi__g_failure_reason@@3PBDB DD 01H DUP (?)		; stbi__g_failure_reason
?stbi__vertically_flip_on_load@@3HA DD 01H DUP (?)	; stbi__vertically_flip_on_load
?stbi__unpremultiply_on_load@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load
?stbi__de_iphone_flag@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag
_BSS	ENDS
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46180000
CONST	SEGMENT
__real@46180000 DD 046180000r			; 9728
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDDNJKDN@the?5file?5@
CONST	SEGMENT
??_C@_09LDDNJKDN@the?5file?5@ DB 'the file ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIKNLKAJ@?5could?5not?5be?5found?$CB?$CB?$CB@
CONST	SEGMENT
??_C@_0BH@PIKNLKAJ@?5could?5not?5be?5found?$CB?$CB?$CB@ DB ' could not be'
	DB	' found!!!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04EEOGCCFB@?4png@
CONST	SEGMENT
??_C@_04EEOGCCFB@?4png@ DB '.png', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MIBMIPKG@src?1res?1Textures?1@
CONST	SEGMENT
??_C@_0BC@MIBMIPKG@src?1res?1Textures?1@ DB 'src/res/Textures/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLLEAHAM@max?5value?5?$DO?5255@
CONST	SEGMENT
??_C@_0BA@OLLEAHAM@max?5value?5?$DO?5255@ DB 'max value > 255', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
CONST	SEGMENT
??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ DB 'invalid decode'
	DB	'd scanline length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOKDFDHG@?$CLX?5@
CONST	SEGMENT
??_C@_03FOKDFDHG@?$CLX?5@ DB '+X ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
CONST	SEGMENT
??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@ DB 'unsupported data layout'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKAKGGJN@?9Y?5@
CONST	SEGMENT
??_C@_03HKAKGGJN@?9Y?5@ DB '-Y ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKJFFLKL@unsupported?5format@
CONST	SEGMENT
??_C@_0BD@NKJFFLKL@unsupported?5format@ DB 'unsupported format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
CONST	SEGMENT
??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@ DB 'FORMAT=32-bit_rle_rgbe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCIOKENI@not?5HDR@
CONST	SEGMENT
??_C@_07NCIOKENI@not?5HDR@ DB 'not HDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
CONST	SEGMENT
??_C@_06NDOKKIDJ@?$CD?$DPRGBE@ DB '#?RGBE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
CONST	SEGMENT
??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@ DB '#?RADIANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
CONST	SEGMENT
??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@ DB '#?RGBE', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
CONST	SEGMENT
??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@ DB '#?RADIANCE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJABBOOH@unknown?5code@
CONST	SEGMENT
??_C@_0N@DJABBOOH@unknown?5code@ DB 'unknown code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAMJKDNF@missing?5color?5table@
CONST	SEGMENT
??_C@_0BE@NAMJKDNF@missing?5color?5table@ DB 'missing color table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
CONST	SEGMENT
??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@ DB 'bad Image Descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
CONST	SEGMENT
??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@ DB 'illegal code in raster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJNJCPDJ@too?5many?5codes@
CONST	SEGMENT
??_C@_0P@GJNJCPDJ@too?5many?5codes@ DB 'too many codes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGDACKOJ@no?5clear?5code@
CONST	SEGMENT
??_C@_0O@MGDACKOJ@no?5clear?5code@ DB 'no clear code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJLPAII@not?5GIF@
CONST	SEGMENT
??_C@_07KMJLPAII@not?5GIF@ DB 'not GIF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGMBIFE@bad?5file@
CONST	SEGMENT
??_C@_08GGMBIFE@bad?5file@ DB 'bad file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELNJHLFH@PICT@
CONST	SEGMENT
??_C@_04ELNJHLFH@PICT@ DB 'PICT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEPHFH@S?$IA?v4@
CONST	SEGMENT
??_C@_04KBFEPHFH@S?$IA?v4@ DB 'S', 080H, 0f6H, '4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPPMCAKL@corrupt@
CONST	SEGMENT
??_C@_07DPPMCAKL@corrupt@ DB 'corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOGGBMNK@wrong?5color?5format@
CONST	SEGMENT
??_C@_0BD@IOGGBMNK@wrong?5color?5format@ DB 'wrong color format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
CONST	SEGMENT
??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@ DB 'unsupported bit depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
CONST	SEGMENT
??_C@_0BE@PJBNGDBE@wrong?5channel?5count@ DB 'wrong channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHBCDKKC@wrong?5version@
CONST	SEGMENT
??_C@_0O@CHBCDKKC@wrong?5version@ DB 'wrong version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECNCNLIK@not?5PSD@
CONST	SEGMENT
??_C@_07ECNCNLIK@not?5PSD@ DB 'not PSD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette@ DB 'bad palette', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
CONST	SEGMENT
??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ DB 't'
	DB	00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T'
	DB	00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z@4JA DD 015dbH ; `stbi__tga_load'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp@ DB 'bad bpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE@ DB 'BMP RLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP@ DB 'bad BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP@ DB 'unknown BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP@ DB 'not BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
CONST	SEGMENT
??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '8', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@LIEKLNBF@?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2@
CONST	SEGMENT
??_C@_1CE@LIEKLNBF@?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2@ DB 'v'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'v', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '2', 00H, '5', 00H, '6', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__shiftsigned@@YAHIHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__shiftsigned@@YAHIHH@Z@4JA DD 01426H ; `stbi__shiftsigned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT@ DB 'no IDAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata@ DB 'outofdata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE@ DB 'no PLTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE@ DB 'invalid PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@ DB '1/2/4/8/16-bit only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__de_iphone@@YAXPAUstbi__png@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__de_iphone@@YAXPAUstbi__png@@@Z@4JA DD 012c3H ; `stbi__de_iphone'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z@4JA DD 01276H ; `stbi__compute_transparency16'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
CONST	SEGMENT
??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z@4JA DD 0125cH ; `stbi__compute_transparency'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
CONST	SEGMENT
??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs@
CONST	SEGMENT
??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
CONST	SEGMENT
??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '+'
	DB	00H, ' ', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA DD 01155H ; `stbi__create_png_image_raw'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig@ DB 'bad png sig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt@ DB 'zlib corrupt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'a'
	DB	00H, '-', 00H, '>', 00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H
	DB	'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z@4JA DD 0104aH ; `stbi__parse_uncompressed_block'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8@
CONST	SEGMENT
??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8@ DB 'c', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, '8', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4JA DD 01018H ; `stbi__compute_huffman_codes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist@ DB 'bad dist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'[', 00H, 'b', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z@4JA DD 0fabH ; `stbi__zhuffman_decode_slowpath'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5@
CONST	SEGMENT
??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'_', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, '1', 00H, 'U', 00H
	DB	' ', 00H, '<', 00H, '<', 00H, ' ', 00H, 'z', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z@4JA DD 0f98H ; `stbi__fill_bits'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
CONST	SEGMENT
??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '6', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__bit_reverse@@YAHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__bit_reverse@@YAHHH@Z@4JA DD 0f47H ; `stbi__bit_reverse'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp@ DB 'bad req_comp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len@ DB 'bad DNL len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width@ DB '0 width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit@ DB 'only 8-bit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len@ DB 'bad SOF len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS@ DB 'bad SOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff@ DB 'bad AC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff@ DB 'bad DC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len@ DB 'bad SOS len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@ DB 'bad SOS component coun'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len@ DB 'bad APP len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len@ DB 'bad COM len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len@ DB 'bad DRI len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@ DB 'can''t merge dc and ac'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IA@IKCMGFNK@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI@
CONST	SEGMENT
??_C@_1IA@IKCMGFNK@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '(', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H, '(', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '('
	DB	00H, 's', 00H, 't', 00H, 'b', 00H, 'i', 00H, '_', 00H, '_', 00H
	DB	'b', 00H, 'm', 00H, 'a', 00H, 's', 00H, 'k', 00H, ')', 00H, ' '
	DB	00H, '/', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'o', 00H, 'f', 00H, '(', 00H, '*', 00H, 's', 00H, 't', 00H, 'b'
	DB	00H, 'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H
	DB	's', 00H, 'k', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z@4JA DD 07b0H ; `stbi__extend_receive'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
CONST	SEGMENT
??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ DB '('
	DB	00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H
	DB	'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ']'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'h', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '['
	DB	00H, 'c', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z@4JA DD 077aH ; `stbi__jpeg_huff_decode'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__convert_format16@@YAPAGPAGHHII@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__convert_format16@@YAPAGPAGHHII@Z@4JA DD 0661H ; `stbi__convert_format16'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ DB 'r'
	DB	00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__convert_format@@YAPAEPAEHHII@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__convert_format@@YAPAEPAEHHII@Z@4JA DD 0630H ; `stbi__convert_format'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen@ DB 'can''t fopen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
CONST	SEGMENT
??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '8', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z@4JA DD 0478H ; `stbi__load_and_postprocess_16bit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
CONST	SEGMENT
??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, '6', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
CONST	SEGMENT
??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'l', 00H, 'a', 00H, 't', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'C', 00H, 'P', 00H, 'P', 00H, 'G', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, '-', 00H, 'a', 00H, '3', 00H, '8', 00H, 'd', 00H, '0'
	DB	00H, 'd', 00H, 'b', 00H, '7', 00H, '2', 00H, '6', 00H, 'a', 00H
	DB	'b', 00H, '2', 00H, 'f', 00H, 'f', 00H, '8', 00H, '9', 00H, 'a'
	DB	00H, 'f', 00H, 'd', 00H, 'd', 00H, '0', 00H, '2', 00H, 'c', 00H
	DB	'1', 00H, '8', 00H, '3', 00H, '9', 00H, '4', 00H, 'b', 00H, 'd'
	DB	00H, '0', 00H, 'c', 00H, '5', 00H, '8', 00H, '3', 00H, '4', 00H
	DB	'0', 00H, 'c', 00H, '9', 00H, '\', 00H, 'C', 00H, 'P', 00H, 'P'
	DB	00H, 'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '-', 00H, 'a', 00H
	DB	'3', 00H, '8', 00H, 'd', 00H, '0', 00H, 'd', 00H, 'b', 00H, '7'
	DB	00H, '2', 00H, '6', 00H, 'a', 00H, 'b', 00H, '2', 00H, 'f', 00H
	DB	'f', 00H, '8', 00H, '9', 00H, 'a', 00H, 'f', 00H, 'd', 00H, 'd'
	DB	00H, '0', 00H, '2', 00H, 'c', 00H, '1', 00H, '8', 00H, '3', 00H
	DB	'9', 00H, '4', 00H, 'b', 00H, 'd', 00H, '0', 00H, 'c', 00H, '5'
	DB	00H, '8', 00H, '3', 00H, '4', 00H, '0', 00H, 'c', 00H, '9', 00H
	DB	'\', 00H, 'P', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'f', 00H, 'o'
	DB	00H, 'r', 00H, 'm', 00H, 'e', 00H, 'r', 00H, 'G', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'E', 00H, 'n', 00H
	DB	'g', 00H, 'i', 00H, 'n', 00H, 'e', 00H, '\', 00H, 'H', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'V', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, 'o', 00H, 'r', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z@4JA DD 0460H ; `stbi__load_and_postprocess_8bit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem@ DB 'outofmem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type@ DB 'unknown image type', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A DD FLAT:?stbi__stdio_read@@YAHPAXPADH@Z ; stbi__stdio_callbacks
	DD	FLAT:?stbi__stdio_skip@@YAXPAXH@Z
	DD	FLAT:?stbi__stdio_eof@@YAHPAX@Z
?stbi__l2h_gamma@@3MA DD 0400ccccdr		; 2.2	; stbi__l2h_gamma
?stbi__l2h_scale@@3MA DD 03f800000r		; 1	; stbi__l2h_scale
?stbi__h2l_gamma_i@@3MA DD 03ee8ba2er		; 0.454545 ; stbi__h2l_gamma_i
?stbi__h2l_scale_i@@3MA DD 03f800000r		; 1	; stbi__h2l_scale_i
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA DB 'X'
	DB	'XXX PNG chunk not known', 00H		; `stbi__parse_png_file'::`151'::invalid_chunk
	ORG $+3
?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H	; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H ; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '4', 00H, '.', 00H, '2', 00H, '8', 00H, '3', 00H
	DB	'1', 00H, '4', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.24.28314\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 06aH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@ABQAD@std@@YAABQADABQAD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@PAD@std@@YAPAPADAAPAD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Max_value@I@std@@YAABIABI0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Unfancy@D@std@@YAPADPAD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Texture@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$allocator@D@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Min_value@I@std@@YAABIABI0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Container_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Convert_size@I@std@@YAII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@QBDH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?max@?$numeric_limits@H@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??2@YAPAXIPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 664  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 665  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 666  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 667  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Old_ptr$1 = -120					; size = 4
__Raw_new$ = -108					; size = 4
__New_ptr$ = -96					; size = 4
__Al$ = -84						; size = 4
__New_capacity$ = -72					; size = 4
__Old_capacity$ = -60					; size = 4
__New_size$ = -48					; size = 4
__Old_size$ = -36					; size = 4
__My_data$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 4129 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4130 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4131 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4132 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 4133 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 4140 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 4141 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	eax, eax
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	add	ecx, 1
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 4143 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4144 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4145 :         _My_data._Myres       = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4146 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4151 :             _My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4152 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4153 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 4154 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 4155 :         }
; 4156 : 
; 4157 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4158 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN8@Reallocate:
	DD	1
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN6@Reallocate
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$ = ecx

; 3631 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3632 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 3633 :                 });

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 121  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 122  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 123  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 111  : #if _HAS_EXCEPTIONS
; 112  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@sentry

; 113  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 114  :             }
; 115  : #else // _HAS_EXCEPTIONS
; 116  :             this->_Myostr._Osfx();
; 117  : #endif // _HAS_EXCEPTIONS
; 118  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 93   :             if (!_Ostr.good()) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 94   :                 _Ok = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 95   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Tied$[ebp], eax

; 99   :             if (!_Tied || _Tied == &_Ostr) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN4@sentry
	mov	eax, DWORD PTR __Tied$[ebp]
	cmp	eax, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 101  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Tied$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
$LN1@sentry:

; 107  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 80   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN3@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Sentry_bas:

; 82   :             }
; 83   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 73   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN1@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Sentry_bas:

; 75   :             }
; 76   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 87   : _DECLSPEC_ALLOCATOR void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 88   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 90   :     if (_Block_size <= _Bytes) {

	mov	eax, DWORD PTR __Block_size$[ebp]
	cmp	eax, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN8@Allocate_m

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 92   :     }
; 93   : 
; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	eax, DWORD PTR __Block_size$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	je	SHORT $LN7@Allocate_m
	jmp	SHORT $LN2@Allocate_m
$LN7@Allocate_m:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	95					; 0000005fH
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
$LN12@Allocate_m:
	mov	esi, esp
	push	0
	push	95					; 0000005fH
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN2@Allocate_m:
	xor	eax, eax
	jne	SHORT $LN4@Allocate_m

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	eax, DWORD PTR __Ptr_container$[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 98   : 
; 99   : #ifdef _DEBUG
; 100  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 101  : #endif // _DEBUG
; 102  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@ABQAD@std@@YAABQADABQAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@ABQAD@std@@YAABQADABQAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@ABQAD@std@@YAABQADABQAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@PAD@std@@YAPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@PAD@std@@YAPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@PAD@std@@YAPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 994  : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 995  :     // deallocate a plain pointer using an allocator
; 996  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 997  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 998  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 999  :     } else {
; 1000 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1001 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1002 :     }
; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
tv405 = -332						; size = 8
tv290 = -324						; size = 4
tv287 = -324						; size = 8
tv285 = -324						; size = 4
tv324 = -320						; size = 8
tv289 = -320						; size = 4
tv284 = -320						; size = 4
tv286 = -316						; size = 4
tv135 = -316						; size = 4
tv288 = -313						; size = 1
tv283 = -313						; size = 1
$T2 = -308						; size = 4
$T3 = -296						; size = 4
$T4 = -284						; size = 4
$T5 = -272						; size = 4
$T6 = -260						; size = 4
__Ok$ = -56						; size = 8
__Pad$ = -40						; size = 4
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Data$ = 12						; size = 4
__Size$ = 16						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT

; 427  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 428  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 429  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 430  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 431  : 
; 432  :     _SizeT _Pad;
; 433  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv324[ebp], eax
	mov	DWORD PTR tv324[ebp+4], edx
	cmp	DWORD PTR tv324[ebp+4], 0
	jl	SHORT $LN10@Insert_str
	jg	SHORT $LN25@Insert_str
	cmp	DWORD PTR tv324[ebp], 0
	jbe	SHORT $LN10@Insert_str
$LN25@Insert_str:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Size$[ebp]
	ja	SHORT $LN8@Insert_str
$LN10@Insert_str:

; 434  :         _Pad = 0;

	mov	DWORD PTR __Pad$[ebp], 0

; 435  :     } else {

	jmp	SHORT $LN9@Insert_str
$LN8@Insert_str:

; 436  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Pad$[ebp], eax
$LN9@Insert_str:

; 437  :     }
; 438  : 
; 439  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 440  : 
; 441  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@Insert_str

; 442  :         _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 443  :     } else { // state okay, insert characters

	jmp	$LN12@Insert_str
$LN11@Insert_str:

; 444  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 445  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv135[ebp], eax
	mov	eax, DWORD PTR tv135[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN14@Insert_str

; 446  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@Insert_str
$LN2@Insert_str:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN4@Insert_str:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN14@Insert_str

; 447  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv283[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv283[ebp]
	push	eax
	mov	ecx, DWORD PTR tv284[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	ecx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Insert_str

; 448  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 449  :                     break;

	jmp	SHORT $LN14@Insert_str
$LN15@Insert_str:

; 450  :                 }
; 451  :             }

	jmp	$LN2@Insert_str
$LN14@Insert_str:

; 452  :         }
; 453  : 
; 454  :         if (_State == _Ostr_t::goodbit
; 455  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN16@Insert_str
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	eax, DWORD PTR __Size$[ebp]
	xor	ecx, ecx
	mov	esi, esp
	push	ecx
	push	eax
	mov	edx, DWORD PTR __Data$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv286[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	DWORD PTR tv287[ebp+4], edx
	mov	eax, DWORD PTR __Size$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv405[ebp], eax
	mov	DWORD PTR tv405[ebp+4], ecx
	mov	edx, DWORD PTR tv287[ebp]
	cmp	edx, DWORD PTR tv405[ebp]
	jne	SHORT $LN26@Insert_str
	mov	eax, DWORD PTR tv287[ebp+4]
	cmp	eax, DWORD PTR tv405[ebp+4]
	je	SHORT $LN16@Insert_str
$LN26@Insert_str:

; 456  :             _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 457  :         } else {

	jmp	$LN17@Insert_str
$LN16@Insert_str:

; 458  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@Insert_str
$LN5@Insert_str:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN7@Insert_str:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN17@Insert_str

; 459  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv288[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv289[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv288[ebp]
	push	eax
	mov	ecx, DWORD PTR tv289[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Insert_str

; 460  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 461  :                     break;

	jmp	SHORT $LN17@Insert_str
$LN18@Insert_str:

; 462  :                 }
; 463  :             }

	jmp	$LN5@Insert_str
$LN17@Insert_str:

; 464  :         }
; 465  : 
; 466  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN20@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 467  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN24@Insert_str
	ret	0
$LN20@Insert_str:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN12@Insert_str
$LN24@Insert_str:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@Insert_str:

; 468  :     }
; 469  : 
; 470  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 471  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 472  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@Insert_str
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN30@Insert_str:
	DD	1
	DD	$LN29@Insert_str
$LN29@Insert_str:
	DD	-56					; ffffffc8H
	DD	8
	DD	$LN27@Insert_str
$LN27@Insert_str:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1426 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1427 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1428 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 28   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 34   :             if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 35   :                 _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
$LN3@Get_size_o:

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 187  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 196  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 171  : _DECLSPEC_ALLOCATOR void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 172  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 173  : #if defined(_M_IX86) || defined(_M_X64)
; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Allocate

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	cmp	DWORD PTR __Bytes$[ebp], 0
	je	SHORT $LN3@Allocate

; 180  :         return _Traits::_Allocate(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN1@Allocate:

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 28   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 0

; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABQAD@std@@YAABQADABQAD@Z	; std::forward<char * const &>
	add	esp, 4
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 855  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 856  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 857  :         _Left = _Right;
; 858  :     } else {
; 859  :         (void) _Left; // TRANSITION, VSO#486357
; 860  :         (void) _Right; // TRANSITION, VSO#486357
; 861  :     }
; 862  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -120					; size = 4
__Raw_new$ = -108					; size = 4
__New_ptr$ = -96					; size = 4
__Al$ = -84						; size = 4
__New_capacity$ = -72					; size = 4
__Old_capacity$ = -60					; size = 4
__New_size$ = -48					; size = 4
__Old_size$ = -36					; size = 4
__My_data$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4129 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4130 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4131 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4132 :         auto& _My_data            = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 4133 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 4134 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 4135 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4136 :         }
; 4137 : 
; 4138 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], eax

; 4139 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 4140 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 4141 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4142 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	eax, eax
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	add	ecx, 1
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 4143 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4144 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4145 :         _My_data._Myres       = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4146 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 4147 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 4148 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 4149 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4150 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4151 :             _My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4152 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4153 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4154 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 4155 :         }
; 4156 : 
; 4157 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4158 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN8@Reallocate:
	DD	1
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN6@Reallocate
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2778 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2779 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2780 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2781 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2782 :             },

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$ = -60					; size = 4
__Al$ = -48						; size = 4
__New_capacity$ = -36					; size = 4
__Old_capacity$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4103 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4104 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4105 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4106 :         if (_New_size > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __New_size$[ebp], eax
	jbe	SHORT $LN2@Reallocate

; 4107 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 4108 :         }
; 4109 : 
; 4110 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 4111 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 4112 :         auto& _Al                     = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4113 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	eax, eax
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	add	ecx, 1
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 4114 :         _Mypair._Myval2._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4115 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4116 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4117 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()

; 4118 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 4119 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4120 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4121 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4122 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8
$LN4@Reallocate:

; 4123 :         }
; 4124 : 
; 4125 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4126 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Reallocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN8@Reallocate:
	DD	1
	DD	$LN7@Reallocate
$LN7@Reallocate:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN6@Reallocate
$LN6@Reallocate:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2883 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2884 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2886 :             },

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -220						; size = 4
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 36   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Max_value@I@std@@YAABIABI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 37   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Max_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Max_value
$LN3@Max_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Max_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]

; 38   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Max_value@I@std@@YAABIABI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Max_value@I@std@@YAABIABI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 241  : void _Destroy_in_place(_Ty& _Obj) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 242  :     _Obj.~_Ty();
; 243  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 290  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1438 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1440 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 776  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unfancy@D@std@@YAPADPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 290  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Unfancy@D@std@@YAPADPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unfancy@D@std@@YAPADPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1097 :     void _Alloc_proxy(_Alloc&& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1098 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	DWORD PTR __New_proxy$[ebp], eax

; 1099 :         _Construct_in_place(*_New_proxy, this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_proxy$[ebp]
	push	edx
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1100 :         _Myproxy            = _New_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_proxy$[ebp]
	mov	DWORD PTR [eax], ecx

; 1101 :         _New_proxy->_Mycont = this;

	mov	eax, DWORD PTR __New_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 1102 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1295 :     ~_Container_proxy_ptr12() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1296 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Container_

; 1297 :             _Delete_plain_internal(_Al, _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8
$LN3@Container_:

; 1298 :         }
; 1299 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1281 :     _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1282 :         : _Al(_Al_) { // create a new _Container_proxy pointing at _Mycont

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1283 :         _Ptr = _Unfancy(_Al_.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al_$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1284 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	eax, DWORD PTR __Mycont$[ebp]
	push	eax
	call	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1285 :         _Mycont._Myproxy = _Ptr;

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1286 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1022 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1023 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1024 :     using _Ty = typename _Alloc::value_type;
; 1025 :     _Ptr->~_Ty();
; 1026 :     _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 1027 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 785  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1438 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __4877352E_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1439 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1440 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 943  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __094A72D0_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 944  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 945  :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 946  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 947  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4525 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4526 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __Str$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	push	eax
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 12					; 0000000cH

; 4527 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4341 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4342 :     return _STD move(_Left.append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4343 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
_TEXT	SEGMENT
$T2 = -252						; size = 4
__Ans$ = -48						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4263 :     _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4264 :     using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 4265 :     using _Size_type   = typename _String_type::size_type;
; 4266 :     _String_type _Ans;

	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4267 :     _Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 4268 :     _Ans += _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4269 :     _Ans += _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4270 :     return _Ans;

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4271 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-48					; ffffffd0H
	DD	28					; 0000001cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z$0:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4313 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4314 :     return _STD move(_Left.append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4315 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
$T2 = -252						; size = 4
__Ans$ = -48						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4252 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4253 :     // return string + string
; 4254 :     basic_string<_Elem, _Traits, _Alloc> _Ans;

	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4255 :     _Ans.reserve(_Left.size() + _Right.size());

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 4256 :     _Ans += _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4257 :     _Ans += _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4258 :     return _Ans;

	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4259 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-48					; ffffffd0H
	DD	28					; 0000001cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__is_16_main@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?stbi__is_16_main@@YAHPAUstbi__context@@@Z PROC		; stbi__is_16_main, COMDAT

; 7344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7345 : #ifndef STBI_NO_PNG
; 7346 : 	if (stbi__png_is16(s))  return 1;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__png_is16@@YAHPAUstbi__context@@@Z ; stbi__png_is16
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__is_1
	mov	eax, 1
	jmp	SHORT $LN1@stbi__is_1
$LN2@stbi__is_1:

; 7347 : #endif
; 7348 : 
; 7349 : #ifndef STBI_NO_PSD
; 7350 : 	if (stbi__psd_is16(s))  return 1;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__psd_is16@@YAHPAUstbi__context@@@Z ; stbi__psd_is16
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@stbi__is_1
	mov	eax, 1
	jmp	SHORT $LN1@stbi__is_1
$LN3@stbi__is_1:

; 7351 : #endif
; 7352 : 
; 7353 : 	return 0;

	xor	eax, eax
$LN1@stbi__is_1:

; 7354 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__is_16_main@@YAHPAUstbi__context@@@Z ENDP		; stbi__is_16_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__info_main, COMDAT

; 7302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7303 : #ifndef STBI_NO_JPEG
; 7304 : 	if (stbi__jpeg_info(s, x, y, comp)) return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__jpeg_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__jpeg_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN2@stbi__info:

; 7305 : #endif
; 7306 : 
; 7307 : #ifndef STBI_NO_PNG
; 7308 : 	if (stbi__png_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__png_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__png_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN3@stbi__info:

; 7309 : #endif
; 7310 : 
; 7311 : #ifndef STBI_NO_GIF
; 7312 : 	if (stbi__gif_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__gif_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN4@stbi__info:

; 7313 : #endif
; 7314 : 
; 7315 : #ifndef STBI_NO_BMP
; 7316 : 	if (stbi__bmp_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__bmp_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__bmp_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN5@stbi__info:

; 7317 : #endif
; 7318 : 
; 7319 : #ifndef STBI_NO_PSD
; 7320 : 	if (stbi__psd_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__psd_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__psd_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN6@stbi__info:

; 7321 : #endif
; 7322 : 
; 7323 : #ifndef STBI_NO_PIC
; 7324 : 	if (stbi__pic_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__pic_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN7@stbi__info:

; 7325 : #endif
; 7326 : 
; 7327 : #ifndef STBI_NO_PNM
; 7328 : 	if (stbi__pnm_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pnm_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__pnm_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN8@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN8@stbi__info:

; 7329 : #endif
; 7330 : 
; 7331 : #ifndef STBI_NO_HDR
; 7332 : 	if (stbi__hdr_info(s, x, y, comp))  return 1;

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__hdr_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN9@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN9@stbi__info:

; 7333 : #endif
; 7334 : 
; 7335 : 	// test tga last because it's a crappy test!
; 7336 : #ifndef STBI_NO_TGA
; 7337 : 	if (stbi__tga_info(s, x, y, comp))

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__tga_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__tga_info
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@stbi__info

; 7338 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN10@stbi__info:

; 7339 : #endif
; 7340 : 	return stbi__err("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
$LN1@stbi__info:

; 7341 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__info_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z
_TEXT	SEGMENT
_value$ = -8						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 4
?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z PROC	; stbi__pnm_getinteger, COMDAT

; 7251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7252 : 	int value = 0;

	mov	DWORD PTR _value$[ebp], 0
$LN2@stbi__pnm_:

; 7253 : 
; 7254 : 	while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@stbi__pnm_
	mov	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?stbi__pnm_isdigit@@YAHD@Z		; stbi__pnm_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@stbi__pnm_

; 7255 : 		value = value * 10 + (*c - '0');

	imul	eax, DWORD PTR _value$[ebp], 10
	mov	ecx, DWORD PTR _c$[ebp]
	movsx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	DWORD PTR _value$[ebp], eax

; 7256 : 		*c = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [ecx], al

; 7257 : 	}

	jmp	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7258 : 
; 7259 : 	return value;

	mov	eax, DWORD PTR _value$[ebp]

; 7260 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z ENDP	; stbi__pnm_getinteger
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_isdigit@@YAHD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_c$ = 8							; size = 1
?stbi__pnm_isdigit@@YAHD@Z PROC				; stbi__pnm_isdigit, COMDAT

; 7246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7247 : 	return c >= '0' && c <= '9';

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@stbi__pnm_
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN3@stbi__pnm_
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
	mov	DWORD PTR tv68[ebp], 0
$LN4@stbi__pnm_:
	mov	eax, DWORD PTR tv68[ebp]

; 7248 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_isdigit@@YAHD@Z ENDP				; stbi__pnm_isdigit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_c$ = 12						; size = 4
?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z PROC ; stbi__pnm_skip_whitespace, COMDAT

; 7232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
$LN5@stbi__pnm_:

; 7233 : 	for (;;) {
; 7234 : 		while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@stbi__pnm_
	mov	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?stbi__pnm_isspace@@YAHD@Z		; stbi__pnm_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__pnm_

; 7235 : 			* c = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7236 : 
; 7237 : 		if (stbi__at_eof(s) || *c != '#')

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@stbi__pnm_
	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 35					; 00000023H
	je	SHORT $LN7@stbi__pnm_
$LN10@stbi__pnm_:

; 7238 : 			break;

	jmp	SHORT $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7239 : 
; 7240 : 		while (!stbi__at_eof(s) && *c != '\n' && *c != '\r')

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@stbi__pnm_
	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN8@stbi__pnm_
	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@stbi__pnm_

; 7241 : 			* c = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN7@stbi__pnm_
$LN8@stbi__pnm_:

; 7242 : 	}

	jmp	$LN5@stbi__pnm_
$LN1@stbi__pnm_:

; 7243 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z ENDP ; stbi__pnm_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_isspace@@YAHD@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
_c$ = 8							; size = 1
?stbi__pnm_isspace@@YAHD@Z PROC				; stbi__pnm_isspace, COMDAT

; 7227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7228 : 	return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@stbi__pnm_
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 9
	je	SHORT $LN3@stbi__pnm_
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN3@stbi__pnm_
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN3@stbi__pnm_
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN3@stbi__pnm_
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
	mov	DWORD PTR tv76[ebp], 1
$LN4@stbi__pnm_:
	mov	eax, DWORD PTR tv76[ebp]

; 7229 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_isspace@@YAHD@Z ENDP				; stbi__pnm_isspace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_convert@@YAXPAMPAEH@Z
_TEXT	SEGMENT
tv152 = -208						; size = 4
_f1$1 = -8						; size = 4
_output$ = 8						; size = 4
_input$ = 12						; size = 4
_req_comp$ = 16						; size = 4
?stbi__hdr_convert@@YAXPAMPAEH@Z PROC			; stbi__hdr_convert, COMDAT

; 6831 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6832 : 	if (input[3] != 0) {

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN4@stbi__hdr_

; 6833 : 		float f1;
; 6834 : 		// Exponent
; 6835 : 		f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, 136				; 00000088H
	mov	esi, esp
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ldexp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	DWORD PTR _f1$1[ebp]

; 6836 : 		if (req_comp <= 2)

	cmp	DWORD PTR _req_comp$[ebp], 2
	jg	SHORT $LN6@stbi__hdr_

; 6837 : 			output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _input$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	add	eax, ecx
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _input$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _f1$1[ebp]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	jmp	SHORT $LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 6838 : 		else {
; 6839 : 			output[0] = input[0] * f1;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _f1$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _output$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 6840 : 			output[1] = input[1] * f1;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _input$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _f1$1[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 6841 : 			output[2] = input[2] * f1;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _input$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _f1$1[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN7@stbi__hdr_:

; 6842 : 		}
; 6843 : 		if (req_comp == 2) output[1] = 1;

	cmp	DWORD PTR _req_comp$[ebp], 2
	jne	SHORT $LN8@stbi__hdr_
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _output$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0
$LN8@stbi__hdr_:

; 6844 : 		if (req_comp == 4) output[3] = 1;

	cmp	DWORD PTR _req_comp$[ebp], 4
	jne	SHORT $LN9@stbi__hdr_
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _output$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0
$LN9@stbi__hdr_:

; 6845 : 	}

	jmp	$LN2@stbi__hdr_
$LN4@stbi__hdr_:

; 6846 : 	else {
; 6847 : 		switch (req_comp) {

	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv152[ebp], ecx
	cmp	DWORD PTR tv152[ebp], 3
	ja	$LN2@stbi__hdr_
	mov	edx, DWORD PTR tv152[ebp]
	jmp	DWORD PTR $LN15@stbi__hdr_[edx*4]
$LN10@stbi__hdr_:

; 6848 : 		case 4: output[3] = 1; /* fallthrough */

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _output$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0
$LN11@stbi__hdr_:

; 6849 : 		case 3: output[0] = output[1] = output[2] = 0;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 6850 : 			break;

	jmp	SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 6851 : 		case 2: output[1] = 1; /* fallthrough */

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _output$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax], xmm0
$LN13@stbi__hdr_:

; 6852 : 		case 1: output[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
$LN2@stbi__hdr_:

; 6853 : 			break;
; 6854 : 		}
; 6855 : 	}
; 6856 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@stbi__hdr_:
	DD	$LN13@stbi__hdr_
	DD	$LN12@stbi__hdr_
	DD	$LN11@stbi__hdr_
	DD	$LN10@stbi__hdr_
?stbi__hdr_convert@@YAXPAMPAEH@Z ENDP			; stbi__hdr_convert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z
_TEXT	SEGMENT
_c$ = -17						; size = 1
_len$ = -8						; size = 4
_z$ = 8							; size = 4
_buffer$ = 12						; size = 4
?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z PROC	; stbi__hdr_gettoken, COMDAT

; 6809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6810 : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 6811 : 	char c = '\0';

	mov	BYTE PTR _c$[ebp], 0

; 6812 : 
; 6813 : 	c = (char)stbi__get8(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _c$[ebp], al
$LN2@stbi__hdr_:

; 6814 : 
; 6815 : 	while (!stbi__at_eof(z) && c != '\n') {

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@stbi__hdr_
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@stbi__hdr_

; 6816 : 		buffer[len++] = c;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 6817 : 		if (len == STBI__HDR_BUFLEN - 1) {

	cmp	DWORD PTR _len$[ebp], 1023		; 000003ffH
	jne	SHORT $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 6818 : 			// flush to end of line
; 6819 : 			while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@stbi__hdr_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN5@stbi__hdr_

; 6820 : 				;

	jmp	SHORT $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 6821 : 			break;

	jmp	SHORT $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 6822 : 		}
; 6823 : 		c = (char)stbi__get8(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _c$[ebp], al

; 6824 : 	}

	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6825 : 
; 6826 : 	buffer[len] = 0;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 6827 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 6828 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ENDP	; stbi__hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_test_core@@YAHPAUstbi__context@@PBD@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_signature$ = 12					; size = 4
?stbi__hdr_test_core@@YAHPAUstbi__context@@PBD@Z PROC	; stbi__hdr_test_core, COMDAT

; 6787 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6788 : 	int i;
; 6789 : 	for (i = 0; signature[i]; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__hdr_:
	mov	eax, DWORD PTR _signature$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@stbi__hdr_

; 6790 : 		if (stbi__get8(s) != signature[i])

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _signature$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	je	SHORT $LN5@stbi__hdr_

; 6791 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6792 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 6793 : 	return 1;

	mov	eax, 1
$LN1@stbi__hdr_:

; 6794 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__hdr_test_core@@YAHPAUstbi__context@@PBD@Z ENDP	; stbi__hdr_test_core
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_load_next@@YAPAEPAUstbi__context@@PAUstbi__gif@@PAHHPAE@Z
_TEXT	SEGMENT
tv389 = -340						; size = 4
tv301 = -340						; size = 4
tv282 = -340						; size = 4
tv236 = -340						; size = 4
tv218 = -340						; size = 4
tv139 = -340						; size = 4
tv83 = -340						; size = 4
_ext$1 = -140						; size = 4
_len$2 = -128						; size = 4
_o$3 = -116						; size = 4
_h$4 = -104						; size = 4
_w$5 = -92						; size = 4
_y$6 = -80						; size = 4
_x$7 = -68						; size = 4
_tag$8 = -56						; size = 4
_pcount$ = -44						; size = 4
_pi$ = -32						; size = 4
_first_frame$ = -20					; size = 4
_dispose$ = -8						; size = 4
_s$ = 8							; size = 4
_g$ = 12						; size = 4
_comp$ = 16						; size = 4
_req_comp$ = 20						; size = 4
_two_back$ = 24						; size = 4
?stbi__gif_load_next@@YAPAEPAUstbi__context@@PAUstbi__gif@@PAHHPAE@Z PROC ; stbi__gif_load_next, COMDAT

; 6501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6502 : 	int dispose;
; 6503 : 	int first_frame;
; 6504 : 	int pi;
; 6505 : 	int pcount;
; 6506 : 	STBI_NOTUSED(req_comp);
; 6507 : 
; 6508 : 	// on first frame, any non-written pixels get the background colour (non-transparent)
; 6509 : 	first_frame = 0;

	mov	DWORD PTR _first_frame$[ebp], 0

; 6510 : 	if (g->out == 0) {

	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	$LN18@stbi__gif_

; 6511 : 		if (!stbi__gif_header(s, g, comp, 0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

	push	0
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__gif_header@@YAHPAUstbi__context@@PAUstbi__gif@@PAHH@Z ; stbi__gif_header
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN20@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN20@stbi__gif_:

; 6512 : 		if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

	push	0
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	4
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN21@stbi__gif_

; 6513 : 			return stbi__errpuc("too large", "GIF image is too large");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN55@stbi__gif_
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN56@stbi__gif_
$LN55@stbi__gif_:
	mov	DWORD PTR tv83[ebp], 0
$LN56@stbi__gif_:
	mov	eax, DWORD PTR tv83[ebp]
	jmp	$LN1@stbi__gif_
$LN21@stbi__gif_:

; 6514 : 		pcount = g->w * g->h;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pcount$[ebp], edx

; 6515 : 		g->out = (stbi_uc*)stbi__malloc(4 * pcount);

	mov	eax, DWORD PTR _pcount$[ebp]
	shl	eax, 2
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 6516 : 		g->background = (stbi_uc*)stbi__malloc(4 * pcount);

	mov	eax, DWORD PTR _pcount$[ebp]
	shl	eax, 2
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 6517 : 		g->history = (stbi_uc*)stbi__malloc(pcount);

	mov	eax, DWORD PTR _pcount$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 6518 : 		if (!g->out || !g->background || !g->history)

	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN23@stbi__gif_
	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN23@stbi__gif_
	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN22@stbi__gif_
$LN23@stbi__gif_:

; 6519 : 			return stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN57@stbi__gif_
	mov	DWORD PTR tv139[ebp], 0
	jmp	SHORT $LN58@stbi__gif_
$LN57@stbi__gif_:
	mov	DWORD PTR tv139[ebp], 0
$LN58@stbi__gif_:
	mov	eax, DWORD PTR tv139[ebp]
	jmp	$LN1@stbi__gif_
$LN22@stbi__gif_:

; 6520 : 
; 6521 : 		// image is treated as "transparent" at the start - ie, nothing overwrites the current background; 
; 6522 : 		// background colour is only used for pixels that are not rendered first frame, after that "background"
; 6523 : 		// color refers to the color that was there the previous frame. 
; 6524 : 		memset(g->out, 0x00, 4 * pcount);

	mov	eax, DWORD PTR _pcount$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 6525 : 		memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

	mov	eax, DWORD PTR _pcount$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 6526 : 		memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

	mov	eax, DWORD PTR _pcount$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 6527 : 		first_frame = 1;

	mov	DWORD PTR _first_frame$[ebp], 1

; 6528 : 	}

	jmp	$LN19@stbi__gif_
$LN18@stbi__gif_:

; 6529 : 	else {
; 6530 : 		// second frame - how do we dispoase of the previous one?
; 6531 : 		dispose = (g->eflags & 0x1C) >> 2;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 28					; 0000001cH
	sar	ecx, 2
	mov	DWORD PTR _dispose$[ebp], ecx

; 6532 : 		pcount = g->w * g->h;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pcount$[ebp], edx

; 6533 : 
; 6534 : 		if ((dispose == 3) && (two_back == 0)) {

	cmp	DWORD PTR _dispose$[ebp], 3
	jne	SHORT $LN24@stbi__gif_
	cmp	DWORD PTR _two_back$[ebp], 0
	jne	SHORT $LN24@stbi__gif_

; 6535 : 			dispose = 2; // if I don't have an image to revert back to, default to the old background

	mov	DWORD PTR _dispose$[ebp], 2
$LN24@stbi__gif_:

; 6536 : 		}
; 6537 : 
; 6538 : 		if (dispose == 3) { // use previous graphic

	cmp	DWORD PTR _dispose$[ebp], 3
	jne	SHORT $LN25@stbi__gif_

; 6539 : 			for (pi = 0; pi < pcount; ++pi) {

	mov	DWORD PTR _pi$[ebp], 0
	jmp	SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	add	eax, 1
	mov	DWORD PTR _pi$[ebp], eax
$LN4@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	cmp	eax, DWORD PTR _pcount$[ebp]
	jge	SHORT $LN3@stbi__gif_

; 6540 : 				if (g->history[pi]) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _pi$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN27@stbi__gif_

; 6541 : 					memcpy(&g->out[pi * 4], &two_back[pi * 4], 4);

	push	4
	mov	eax, DWORD PTR _pi$[ebp]
	mov	ecx, DWORD PTR _two_back$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pi$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN27@stbi__gif_:

; 6542 : 				}
; 6543 : 			}

	jmp	SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6544 : 		}

	jmp	SHORT $LN26@stbi__gif_
$LN25@stbi__gif_:

; 6545 : 		else if (dispose == 2) {

	cmp	DWORD PTR _dispose$[ebp], 2
	jne	SHORT $LN26@stbi__gif_

; 6546 : 			// restore what was changed last frame to background before that frame; 
; 6547 : 			for (pi = 0; pi < pcount; ++pi) {

	mov	DWORD PTR _pi$[ebp], 0
	jmp	SHORT $LN7@stbi__gif_
$LN5@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	add	eax, 1
	mov	DWORD PTR _pi$[ebp], eax
$LN7@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	cmp	eax, DWORD PTR _pcount$[ebp]
	jge	SHORT $LN26@stbi__gif_

; 6548 : 				if (g->history[pi]) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _pi$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN30@stbi__gif_

; 6549 : 					memcpy(&g->out[pi * 4], &g->background[pi * 4], 4);

	push	4
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _pi$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pi$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN30@stbi__gif_:

; 6550 : 				}
; 6551 : 			}

	jmp	SHORT $LN5@stbi__gif_
$LN26@stbi__gif_:

; 6552 : 		}
; 6553 : 		else {
; 6554 : 			// This is a non-disposal case eithe way, so just 
; 6555 : 			// leave the pixels as is, and they will become the new background
; 6556 : 			// 1: do not dispose
; 6557 : 			// 0:  not specified.
; 6558 : 		}
; 6559 : 
; 6560 : 		// background is what out is after the undoing of the previou frame; 
; 6561 : 		memcpy(g->background, g->out, 4 * g->w * g->h);

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	mov	edx, DWORD PTR _g$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN19@stbi__gif_:

; 6562 : 	}
; 6563 : 
; 6564 : 	// clear my history; 
; 6565 : 	memset(g->history, 0x00, g->w * g->h);        // pixels that were affected previous frame

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@stbi__gif_:

; 6566 : 
; 6567 : 	for (;;) {
; 6568 : 		int tag = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tag$8[ebp], ecx

; 6569 : 		switch (tag) {

	mov	eax, DWORD PTR _tag$8[ebp]
	mov	DWORD PTR tv218[ebp], eax
	cmp	DWORD PTR tv218[ebp], 33		; 00000021H
	je	$LN44@stbi__gif_
	cmp	DWORD PTR tv218[ebp], 44		; 0000002cH
	je	SHORT $LN31@stbi__gif_
	cmp	DWORD PTR tv218[ebp], 59		; 0000003bH
	je	$LN52@stbi__gif_
	jmp	$LN53@stbi__gif_
$LN31@stbi__gif_:

; 6570 : 		case 0x2C: /* Image Descriptor */
; 6571 : 		{
; 6572 : 			stbi__int32 x, y, w, h;
; 6573 : 			stbi_uc* o;
; 6574 : 
; 6575 : 			x = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _x$7[ebp], eax

; 6576 : 			y = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _y$6[ebp], eax

; 6577 : 			w = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _w$5[ebp], eax

; 6578 : 			h = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _h$4[ebp], eax

; 6579 : 			if (((x + w) > (g->w)) || ((y + h) > (g->h)))

	mov	eax, DWORD PTR _x$7[ebp]
	add	eax, DWORD PTR _w$5[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jg	SHORT $LN33@stbi__gif_
	mov	eax, DWORD PTR _y$6[ebp]
	add	eax, DWORD PTR _h$4[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jle	SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 6580 : 				return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

	push	OFFSET ??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN59@stbi__gif_
	mov	DWORD PTR tv236[ebp], 0
	jmp	SHORT $LN60@stbi__gif_
$LN59@stbi__gif_:
	mov	DWORD PTR tv236[ebp], 0
$LN60@stbi__gif_:
	mov	eax, DWORD PTR tv236[ebp]
	jmp	$LN1@stbi__gif_
$LN32@stbi__gif_:

; 6581 : 
; 6582 : 			g->line_size = g->w * 4;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34896], ecx

; 6583 : 			g->start_x = x * 4;

	mov	eax, DWORD PTR _x$7[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+34872], eax

; 6584 : 			g->start_y = y * g->line_size;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _y$6[ebp]
	imul	ecx, DWORD PTR [eax+34896]
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34876], ecx

; 6585 : 			g->max_x = g->start_x + w * 4;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34872]
	mov	edx, DWORD PTR _w$5[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+34880], eax

; 6586 : 			g->max_y = g->start_y + h * g->line_size;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _h$4[ebp]
	imul	ecx, DWORD PTR [eax+34896]
	mov	edx, DWORD PTR _g$[ebp]
	add	ecx, DWORD PTR [edx+34876]
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+34884], ecx

; 6587 : 			g->cur_x = g->start_x;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+34872]
	mov	DWORD PTR [eax+34888], edx

; 6588 : 			g->cur_y = g->start_y;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+34876]
	mov	DWORD PTR [eax+34892], edx

; 6589 : 
; 6590 : 			// if the width of the specified rectangle is 0, that means
; 6591 : 			// we may not see *any* pixels or the image is malformed;
; 6592 : 			// to make sure this is caught, move the current y down to
; 6593 : 			// max_y (which is what out_gif_code checks).
; 6594 : 			if (w == 0)

	cmp	DWORD PTR _w$5[ebp], 0
	jne	SHORT $LN34@stbi__gif_

; 6595 : 				g->cur_y = g->max_y;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+34884]
	mov	DWORD PTR [eax+34892], edx
$LN34@stbi__gif_:

; 6596 : 
; 6597 : 			g->lflags = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34868], ecx

; 6598 : 
; 6599 : 			if (g->lflags & 0x40) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34868]
	and	ecx, 64					; 00000040H
	je	SHORT $LN35@stbi__gif_

; 6600 : 				g->step = 8 * g->line_size; // first interlaced spacing

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34896]
	shl	ecx, 3
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34864], ecx

; 6601 : 				g->parse = 3;

	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+34860], 3

; 6602 : 			}

	jmp	SHORT $LN36@stbi__gif_
$LN35@stbi__gif_:

; 6603 : 			else {
; 6604 : 				g->step = g->line_size;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+34896]
	mov	DWORD PTR [eax+34864], edx

; 6605 : 				g->parse = 0;

	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+34860], 0
$LN36@stbi__gif_:

; 6606 : 			}
; 6607 : 
; 6608 : 			if (g->lflags & 0x80) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34868]
	and	ecx, 128				; 00000080H
	je	SHORT $LN37@stbi__gif_

; 6609 : 				stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN61@stbi__gif_
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR tv282[ebp], eax
	jmp	SHORT $LN62@stbi__gif_
$LN61@stbi__gif_:
	mov	DWORD PTR tv282[ebp], -1
$LN62@stbi__gif_:
	mov	ecx, DWORD PTR tv282[ebp]
	push	ecx
	mov	edx, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [edx+34868]
	and	ecx, 7
	mov	eax, 2
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	add	ecx, 1064				; 00000428H
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__gif_parse_colortable@@YAXPAUstbi__context@@QAY03EHH@Z ; stbi__gif_parse_colortable
	add	esp, 16					; 00000010H

; 6610 : 				g->color_table = (stbi_uc*)g->lpal;

	mov	eax, DWORD PTR _g$[ebp]
	add	eax, 1064				; 00000428H
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+34856], eax

; 6611 : 			}

	jmp	SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 6612 : 			else if (g->flags & 0x80) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 128				; 00000080H
	je	SHORT $LN39@stbi__gif_

; 6613 : 				g->color_table = (stbi_uc*)g->pal;

	mov	eax, DWORD PTR _g$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+34856], eax

; 6614 : 			}

	jmp	SHORT $LN38@stbi__gif_
$LN39@stbi__gif_:

; 6615 : 			else
; 6616 : 				return stbi__errpuc("missing color table", "Corrupt GIF");

	push	OFFSET ??_C@_0BE@NAMJKDNF@missing?5color?5table@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN63@stbi__gif_
	mov	DWORD PTR tv301[ebp], 0
	jmp	SHORT $LN64@stbi__gif_
$LN63@stbi__gif_:
	mov	DWORD PTR tv301[ebp], 0
$LN64@stbi__gif_:
	mov	eax, DWORD PTR tv301[ebp]
	jmp	$LN1@stbi__gif_
$LN38@stbi__gif_:

; 6617 : 
; 6618 : 			o = stbi__process_gif_raster(s, g);

	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__process_gif_raster@@YAPAEPAUstbi__context@@PAUstbi__gif@@@Z ; stbi__process_gif_raster
	add	esp, 8
	mov	DWORD PTR _o$3[ebp], eax

; 6619 : 			if (!o) return NULL;

	cmp	DWORD PTR _o$3[ebp], 0
	jne	SHORT $LN41@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN41@stbi__gif_:

; 6620 : 
; 6621 : 			// if this was the first frame, 
; 6622 : 			pcount = g->w * g->h;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pcount$[ebp], edx

; 6623 : 			if (first_frame && (g->bgindex > 0)) {

	cmp	DWORD PTR _first_frame$[ebp], 0
	je	SHORT $LN42@stbi__gif_
	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jle	SHORT $LN42@stbi__gif_

; 6624 : 				// if first frame, any pixel not drawn to gets the background color
; 6625 : 				for (pi = 0; pi < pcount; ++pi) {

	mov	DWORD PTR _pi$[ebp], 0
	jmp	SHORT $LN15@stbi__gif_
$LN13@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	add	eax, 1
	mov	DWORD PTR _pi$[ebp], eax
$LN15@stbi__gif_:
	mov	eax, DWORD PTR _pi$[ebp]
	cmp	eax, DWORD PTR _pcount$[ebp]
	jge	SHORT $LN42@stbi__gif_

; 6626 : 					if (g->history[pi] == 0) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _pi$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	jne	SHORT $LN43@stbi__gif_

; 6627 : 						g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be; 

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _g$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR [eax+edx], 255			; 000000ffH

; 6628 : 						memcpy(&g->out[pi * 4], &g->pal[g->bgindex], 4);

	push	4
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _g$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pi$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN43@stbi__gif_:

; 6629 : 					}
; 6630 : 				}

	jmp	SHORT $LN13@stbi__gif_
$LN42@stbi__gif_:

; 6631 : 			}
; 6632 : 
; 6633 : 			return o;

	mov	eax, DWORD PTR _o$3[ebp]
	jmp	$LN1@stbi__gif_
$LN44@stbi__gif_:

; 6634 : 		}
; 6635 : 
; 6636 : 		case 0x21: // Comment Extension.
; 6637 : 		{
; 6638 : 			int len;
; 6639 : 			int ext = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _ext$1[ebp], ecx

; 6640 : 			if (ext == 0xF9) { // Graphic Control Extension.

	cmp	DWORD PTR _ext$1[ebp], 249		; 000000f9H
	jne	$LN16@stbi__gif_

; 6641 : 				len = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$2[ebp], ecx

; 6642 : 				if (len == 4) {

	cmp	DWORD PTR _len$2[ebp], 4
	jne	$LN46@stbi__gif_

; 6643 : 					g->eflags = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 6644 : 					g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34900], ecx

; 6645 : 
; 6646 : 					// unset old transparent
; 6647 : 					if (g->transparent >= 0) {

	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jl	SHORT $LN48@stbi__gif_

; 6648 : 						g->pal[g->transparent][3] = 255;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _g$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR [eax+edx], 255			; 000000ffH
$LN48@stbi__gif_:

; 6649 : 					}
; 6650 : 					if (g->eflags & 0x01) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN49@stbi__gif_

; 6651 : 						g->transparent = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 6652 : 						if (g->transparent >= 0) {

	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jl	SHORT $LN51@stbi__gif_

; 6653 : 							g->pal[g->transparent][3] = 0;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _g$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR [eax+edx], 0
$LN51@stbi__gif_:

; 6654 : 						}
; 6655 : 					}

	jmp	SHORT $LN50@stbi__gif_
$LN49@stbi__gif_:

; 6656 : 					else {
; 6657 : 						// don't need transparent
; 6658 : 						stbi__skip(s, 1);

	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 6659 : 						g->transparent = -1;

	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+32], -1
$LN50@stbi__gif_:

; 6660 : 					}
; 6661 : 				}

	jmp	SHORT $LN16@stbi__gif_
$LN46@stbi__gif_:

; 6662 : 				else {
; 6663 : 					stbi__skip(s, len);

	mov	eax, DWORD PTR _len$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 6664 : 					break;

	jmp	SHORT $LN11@stbi__gif_
$LN16@stbi__gif_:

; 6665 : 				}
; 6666 : 			}
; 6667 : 			while ((len = stbi__get8(s)) != 0) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$2[ebp], ecx
	cmp	DWORD PTR _len$2[ebp], 0
	je	SHORT $LN17@stbi__gif_

; 6668 : 				stbi__skip(s, len);

	mov	eax, DWORD PTR _len$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 6669 : 			}

	jmp	SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 6670 : 			break;

	jmp	SHORT $LN11@stbi__gif_
$LN52@stbi__gif_:

; 6671 : 		}
; 6672 : 
; 6673 : 		case 0x3B: // gif stream termination code
; 6674 : 			return (stbi_uc*)s; // using '1' causes warning on some compilers

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@stbi__gif_
$LN53@stbi__gif_:

; 6675 : 
; 6676 : 		default:
; 6677 : 			return stbi__errpuc("unknown code", "Corrupt GIF");

	push	OFFSET ??_C@_0N@DJABBOOH@unknown?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN65@stbi__gif_
	mov	DWORD PTR tv389[ebp], 0
	jmp	SHORT $LN66@stbi__gif_
$LN65@stbi__gif_:
	mov	DWORD PTR tv389[ebp], 0
$LN66@stbi__gif_:
	mov	eax, DWORD PTR tv389[ebp]
	jmp	SHORT $LN1@stbi__gif_
$LN11@stbi__gif_:

; 6678 : 		}
; 6679 : 	}

	jmp	$LN10@stbi__gif_
$LN1@stbi__gif_:

; 6680 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_load_next@@YAPAEPAUstbi__context@@PAUstbi__gif@@PAHHPAE@Z ENDP ; stbi__gif_load_next
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__process_gif_raster@@YAPAEPAUstbi__context@@PAUstbi__gif@@@Z
_TEXT	SEGMENT
tv201 = -352						; size = 4
tv189 = -352						; size = 4
tv170 = -352						; size = 4
tv160 = -352						; size = 4
tv184 = -349						; size = 1
_code$1 = -152						; size = 4
_p$ = -140						; size = 4
_clear$ = -128						; size = 4
_valid_bits$ = -116					; size = 4
_bits$ = -104						; size = 4
_oldcode$ = -92						; size = 4
_avail$ = -80						; size = 4
_codemask$ = -68					; size = 4
_codesize$ = -56					; size = 4
_first$ = -44						; size = 4
_init_code$ = -32					; size = 4
_len$ = -20						; size = 4
_lzw_cs$ = -5						; size = 1
_s$ = 8							; size = 4
_g$ = 12						; size = 4
?stbi__process_gif_raster@@YAPAEPAUstbi__context@@PAUstbi__gif@@@Z PROC ; stbi__process_gif_raster, COMDAT

; 6409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6410 : 	stbi_uc lzw_cs;
; 6411 : 	stbi__int32 len, init_code;
; 6412 : 	stbi__uint32 first;
; 6413 : 	stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6414 : 	stbi__gif_lzw* p;
; 6415 : 
; 6416 : 	lzw_cs = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _lzw_cs$[ebp], al

; 6417 : 	if (lzw_cs > 12) return NULL;

	movzx	eax, BYTE PTR _lzw_cs$[ebp]
	cmp	eax, 12					; 0000000cH
	jle	SHORT $LN10@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN10@stbi__proc:

; 6418 : 	clear = 1 << lzw_cs;

	movzx	ecx, BYTE PTR _lzw_cs$[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _clear$[ebp], eax

; 6419 : 	first = 1;

	mov	DWORD PTR _first$[ebp], 1

; 6420 : 	codesize = lzw_cs + 1;

	movzx	eax, BYTE PTR _lzw_cs$[ebp]
	add	eax, 1
	mov	DWORD PTR _codesize$[ebp], eax

; 6421 : 	codemask = (1 << codesize) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _codesize$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	DWORD PTR _codemask$[ebp], eax

; 6422 : 	bits = 0;

	mov	DWORD PTR _bits$[ebp], 0

; 6423 : 	valid_bits = 0;

	mov	DWORD PTR _valid_bits$[ebp], 0

; 6424 : 	for (init_code = 0; init_code < clear; init_code++) {

	mov	DWORD PTR _init_code$[ebp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR _init_code$[ebp]
	add	eax, 1
	mov	DWORD PTR _init_code$[ebp], eax
$LN4@stbi__proc:
	mov	eax, DWORD PTR _init_code$[ebp]
	cmp	eax, DWORD PTR _clear$[ebp]
	jge	SHORT $LN3@stbi__proc

; 6425 : 		g->codes[init_code].prefix = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _init_code$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	mov	WORD PTR [edx+ecx*4+2088], ax

; 6426 : 		g->codes[init_code].first = (stbi_uc)init_code;

	mov	eax, DWORD PTR _init_code$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	dl, BYTE PTR _init_code$[ebp]
	mov	BYTE PTR [ecx+eax*4+2090], dl

; 6427 : 		g->codes[init_code].suffix = (stbi_uc)init_code;

	mov	eax, DWORD PTR _init_code$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	dl, BYTE PTR _init_code$[ebp]
	mov	BYTE PTR [ecx+eax*4+2091], dl

; 6428 : 	}

	jmp	SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 6429 : 
; 6430 : 	// support no starting clear code
; 6431 : 	avail = clear + 2;

	mov	eax, DWORD PTR _clear$[ebp]
	add	eax, 2
	mov	DWORD PTR _avail$[ebp], eax

; 6432 : 	oldcode = -1;

	mov	DWORD PTR _oldcode$[ebp], -1

; 6433 : 
; 6434 : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0
$LN7@stbi__proc:

; 6435 : 	for (;;) {
; 6436 : 		if (valid_bits < codesize) {

	mov	eax, DWORD PTR _valid_bits$[ebp]
	cmp	eax, DWORD PTR _codesize$[ebp]
	jge	SHORT $LN11@stbi__proc

; 6437 : 			if (len == 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN13@stbi__proc

; 6438 : 				len = stbi__get8(s); // start new block

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$[ebp], ecx

; 6439 : 				if (len == 0)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN13@stbi__proc

; 6440 : 					return g->out;

	mov	eax, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN1@stbi__proc
$LN13@stbi__proc:

; 6441 : 			}
; 6442 : 			--len;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 6443 : 			bits |= (stbi__int32)stbi__get8(s) << valid_bits;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	ecx, DWORD PTR _valid_bits$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _bits$[ebp], edx

; 6444 : 			valid_bits += 8;

	mov	eax, DWORD PTR _valid_bits$[ebp]
	add	eax, 8
	mov	DWORD PTR _valid_bits$[ebp], eax

; 6445 : 		}

	jmp	$LN12@stbi__proc
$LN11@stbi__proc:

; 6446 : 		else {
; 6447 : 			stbi__int32 code = bits & codemask;

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, DWORD PTR _codemask$[ebp]
	mov	DWORD PTR _code$1[ebp], eax

; 6448 : 			bits >>= codesize;

	mov	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR _codesize$[ebp]
	sar	eax, cl
	mov	DWORD PTR _bits$[ebp], eax

; 6449 : 			valid_bits -= codesize;

	mov	eax, DWORD PTR _valid_bits$[ebp]
	sub	eax, DWORD PTR _codesize$[ebp]
	mov	DWORD PTR _valid_bits$[ebp], eax

; 6450 : 			// @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6451 : 			if (code == clear) {  // clear code

	mov	eax, DWORD PTR _code$1[ebp]
	cmp	eax, DWORD PTR _clear$[ebp]
	jne	SHORT $LN15@stbi__proc

; 6452 : 				codesize = lzw_cs + 1;

	movzx	eax, BYTE PTR _lzw_cs$[ebp]
	add	eax, 1
	mov	DWORD PTR _codesize$[ebp], eax

; 6453 : 				codemask = (1 << codesize) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _codesize$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	DWORD PTR _codemask$[ebp], eax

; 6454 : 				avail = clear + 2;

	mov	eax, DWORD PTR _clear$[ebp]
	add	eax, 2
	mov	DWORD PTR _avail$[ebp], eax

; 6455 : 				oldcode = -1;

	mov	DWORD PTR _oldcode$[ebp], -1

; 6456 : 				first = 0;

	mov	DWORD PTR _first$[ebp], 0

; 6457 : 			}

	jmp	$LN12@stbi__proc
$LN15@stbi__proc:

; 6458 : 			else if (code == clear + 1) { // end of stream code

	mov	eax, DWORD PTR _clear$[ebp]
	add	eax, 1
	cmp	DWORD PTR _code$1[ebp], eax
	jne	SHORT $LN17@stbi__proc

; 6459 : 				stbi__skip(s, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8
$LN8@stbi__proc:

; 6460 : 				while ((len = stbi__get8(s)) > 0)

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$[ebp], ecx
	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN9@stbi__proc

; 6461 : 					stbi__skip(s, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8
	jmp	SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 6462 : 				return g->out;

	mov	eax, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN1@stbi__proc

; 6463 : 			}

	jmp	$LN12@stbi__proc
$LN17@stbi__proc:

; 6464 : 			else if (code <= avail) {

	mov	eax, DWORD PTR _code$1[ebp]
	cmp	eax, DWORD PTR _avail$[ebp]
	jg	$LN19@stbi__proc

; 6465 : 				if (first) {

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN21@stbi__proc

; 6466 : 					return stbi__errpuc("no clear code", "Corrupt GIF");

	push	OFFSET ??_C@_0O@MGDACKOJ@no?5clear?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@stbi__proc
	mov	DWORD PTR tv160[ebp], 0
	jmp	SHORT $LN29@stbi__proc
$LN28@stbi__proc:
	mov	DWORD PTR tv160[ebp], 0
$LN29@stbi__proc:
	mov	eax, DWORD PTR tv160[ebp]
	jmp	$LN1@stbi__proc
$LN21@stbi__proc:

; 6467 : 				}
; 6468 : 
; 6469 : 				if (oldcode >= 0) {

	cmp	DWORD PTR _oldcode$[ebp], 0
	jl	$LN22@stbi__proc

; 6470 : 					p = &g->codes[avail++];

	mov	eax, DWORD PTR _avail$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+2088]
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _avail$[ebp]
	add	eax, 1
	mov	DWORD PTR _avail$[ebp], eax

; 6471 : 					if (avail > 8192) {

	cmp	DWORD PTR _avail$[ebp], 8192		; 00002000H
	jle	SHORT $LN24@stbi__proc

; 6472 : 						return stbi__errpuc("too many codes", "Corrupt GIF");

	push	OFFSET ??_C@_0P@GJNJCPDJ@too?5many?5codes@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN30@stbi__proc
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN31@stbi__proc
$LN30@stbi__proc:
	mov	DWORD PTR tv170[ebp], 0
$LN31@stbi__proc:
	mov	eax, DWORD PTR tv170[ebp]
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:

; 6473 : 					}
; 6474 : 
; 6475 : 					p->prefix = (stbi__int16)oldcode;

	mov	eax, DWORD PTR _p$[ebp]
	mov	cx, WORD PTR _oldcode$[ebp]
	mov	WORD PTR [eax], cx

; 6476 : 					p->first = g->codes[oldcode].first;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _oldcode$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+2090]
	mov	BYTE PTR [eax+2], cl

; 6477 : 					p->suffix = (code == avail) ? p->first : g->codes[code].first;

	mov	eax, DWORD PTR _code$1[ebp]
	cmp	eax, DWORD PTR _avail$[ebp]
	jne	SHORT $LN32@stbi__proc
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR tv184[ebp], dl
	jmp	SHORT $LN33@stbi__proc
$LN32@stbi__proc:
	mov	eax, DWORD PTR _code$1[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	dl, BYTE PTR [ecx+eax*4+2090]
	mov	BYTE PTR tv184[ebp], dl
$LN33@stbi__proc:
	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR tv184[ebp]
	mov	BYTE PTR [eax+3], cl

; 6478 : 				}

	jmp	SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 6479 : 				else if (code == avail)

	mov	eax, DWORD PTR _code$1[ebp]
	cmp	eax, DWORD PTR _avail$[ebp]
	jne	SHORT $LN23@stbi__proc

; 6480 : 					return stbi__errpuc("illegal code in raster", "Corrupt GIF");

	push	OFFSET ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN34@stbi__proc
	mov	DWORD PTR tv189[ebp], 0
	jmp	SHORT $LN35@stbi__proc
$LN34@stbi__proc:
	mov	DWORD PTR tv189[ebp], 0
$LN35@stbi__proc:
	mov	eax, DWORD PTR tv189[ebp]
	jmp	SHORT $LN1@stbi__proc
$LN23@stbi__proc:

; 6481 : 
; 6482 : 				stbi__out_gif_code(g, (stbi__uint16)code);

	movzx	eax, WORD PTR _code$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	call	?stbi__out_gif_code@@YAXPAUstbi__gif@@G@Z ; stbi__out_gif_code
	add	esp, 8

; 6483 : 
; 6484 : 				if ((avail & codemask) == 0 && avail <= 0x0FFF) {

	mov	eax, DWORD PTR _avail$[ebp]
	and	eax, DWORD PTR _codemask$[ebp]
	jne	SHORT $LN26@stbi__proc
	cmp	DWORD PTR _avail$[ebp], 4095		; 00000fffH
	jg	SHORT $LN26@stbi__proc

; 6485 : 					codesize++;

	mov	eax, DWORD PTR _codesize$[ebp]
	add	eax, 1
	mov	DWORD PTR _codesize$[ebp], eax

; 6486 : 					codemask = (1 << codesize) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _codesize$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	DWORD PTR _codemask$[ebp], eax
$LN26@stbi__proc:

; 6487 : 				}
; 6488 : 
; 6489 : 				oldcode = code;

	mov	eax, DWORD PTR _code$1[ebp]
	mov	DWORD PTR _oldcode$[ebp], eax

; 6490 : 			}

	jmp	SHORT $LN12@stbi__proc
$LN19@stbi__proc:

; 6491 : 			else {
; 6492 : 				return stbi__errpuc("illegal code in raster", "Corrupt GIF");

	push	OFFSET ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@stbi__proc
	mov	DWORD PTR tv201[ebp], 0
	jmp	SHORT $LN37@stbi__proc
$LN36@stbi__proc:
	mov	DWORD PTR tv201[ebp], 0
$LN37@stbi__proc:
	mov	eax, DWORD PTR tv201[ebp]
	jmp	SHORT $LN1@stbi__proc
$LN12@stbi__proc:

; 6493 : 			}
; 6494 : 		}
; 6495 : 	}

	jmp	$LN7@stbi__proc
$LN1@stbi__proc:

; 6496 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__process_gif_raster@@YAPAEPAUstbi__context@@PAUstbi__gif@@@Z ENDP ; stbi__process_gif_raster
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__out_gif_code@@YAXPAUstbi__gif@@G@Z
_TEXT	SEGMENT
_idx$ = -32						; size = 4
_c$ = -20						; size = 4
_p$ = -8						; size = 4
_g$ = 8							; size = 4
_code$ = 12						; size = 2
?stbi__out_gif_code@@YAXPAUstbi__gif@@G@Z PROC		; stbi__out_gif_code, COMDAT

; 6372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6373 : 	stbi_uc* p, * c;
; 6374 : 	int idx;
; 6375 : 
; 6376 : 	// recurse to decode the prefixes, since the linked-list is backwards,
; 6377 : 	// and working backwards through an interleaved image would be nasty
; 6378 : 	if (g->codes[code].prefix >= 0)

	movzx	eax, WORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+2088]
	test	edx, edx
	jl	SHORT $LN4@stbi__out_

; 6379 : 		stbi__out_gif_code(g, g->codes[code].prefix);

	movzx	eax, WORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4+2088]
	push	edx
	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	call	?stbi__out_gif_code@@YAXPAUstbi__gif@@G@Z ; stbi__out_gif_code
	add	esp, 8
$LN4@stbi__out_:

; 6380 : 
; 6381 : 	if (g->cur_y >= g->max_y) return;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax+34892]
	cmp	edx, DWORD PTR [ecx+34884]
	jl	SHORT $LN5@stbi__out_
	jmp	$LN1@stbi__out_
$LN5@stbi__out_:

; 6382 : 
; 6383 : 	idx = g->cur_x + g->cur_y;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34888]
	mov	edx, DWORD PTR _g$[ebp]
	add	ecx, DWORD PTR [edx+34892]
	mov	DWORD PTR _idx$[ebp], ecx

; 6384 : 	p = &g->out[idx];

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _idx$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 6385 : 	g->history[idx / 4] = 1;

	mov	eax, DWORD PTR _idx$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	BYTE PTR [edx+eax], 1

; 6386 : 
; 6387 : 	c = &g->color_table[g->codes[code].suffix * 4];

	movzx	eax, WORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2091]
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34856]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _c$[ebp], edx

; 6388 : 	if (c[3] > 128) { // don't render transparent pixels; 

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN6@stbi__out_

; 6389 : 		p[0] = c[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 6390 : 		p[1] = c[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 6391 : 		p[2] = c[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 6392 : 		p[3] = c[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
$LN6@stbi__out_:

; 6393 : 	}
; 6394 : 	g->cur_x += 4;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34888]
	add	ecx, 4
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34888], ecx

; 6395 : 
; 6396 : 	if (g->cur_x >= g->max_x) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax+34888]
	cmp	edx, DWORD PTR [ecx+34880]
	jl	$LN1@stbi__out_

; 6397 : 		g->cur_x = g->start_x;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+34872]
	mov	DWORD PTR [eax+34888], edx

; 6398 : 		g->cur_y += g->step;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34892]
	mov	edx, DWORD PTR _g$[ebp]
	add	ecx, DWORD PTR [edx+34864]
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+34892], ecx
$LN2@stbi__out_:

; 6399 : 
; 6400 : 		while (g->cur_y >= g->max_y && g->parse > 0) {

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax+34892]
	cmp	edx, DWORD PTR [ecx+34884]
	jl	SHORT $LN1@stbi__out_
	mov	eax, DWORD PTR _g$[ebp]
	cmp	DWORD PTR [eax+34860], 0
	jle	SHORT $LN1@stbi__out_

; 6401 : 			g->step = (1 << g->parse) * g->line_size;

	mov	eax, DWORD PTR _g$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+34860]
	shl	edx, cl
	mov	eax, DWORD PTR _g$[ebp]
	imul	edx, DWORD PTR [eax+34896]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+34864], edx

; 6402 : 			g->cur_y = g->start_y + (g->step >> 1);

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34864]
	sar	ecx, 1
	mov	edx, DWORD PTR _g$[ebp]
	add	ecx, DWORD PTR [edx+34876]
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+34892], ecx

; 6403 : 			--g->parse;

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+34860]
	sub	ecx, 1
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+34860], ecx

; 6404 : 		}

	jmp	SHORT $LN2@stbi__out_
$LN1@stbi__out_:

; 6405 : 	}
; 6406 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__out_gif_code@@YAXPAUstbi__gif@@G@Z ENDP		; stbi__out_gif_code
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_info_raw@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_g$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__gif_info_raw@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__gif_info_raw, COMDAT

; 6358 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6359 : 	stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));

	push	34904					; 00008858H
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _g$[ebp], eax

; 6360 : 	if (!stbi__gif_header(s, g, comp, 1)) {

	push	1
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__gif_header@@YAHPAUstbi__context@@PAUstbi__gif@@PAHH@Z ; stbi__gif_header
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@stbi__gif_

; 6361 : 		STBI_FREE(g);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6362 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 6363 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6364 : 	}
; 6365 : 	if (x)* x = g->w;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@stbi__gif_:

; 6366 : 	if (y)* y = g->h;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@stbi__gif_
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN4@stbi__gif_:

; 6367 : 	STBI_FREE(g);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6368 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 6369 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_info_raw@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__gif_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_header@@YAHPAUstbi__context@@PAUstbi__gif@@PAHH@Z
_TEXT	SEGMENT
_version$ = -5						; size = 1
_s$ = 8							; size = 4
_g$ = 12						; size = 4
_comp$ = 16						; size = 4
_is_info$ = 20						; size = 4
?stbi__gif_header@@YAHPAUstbi__context@@PAUstbi__gif@@PAHH@Z PROC ; stbi__gif_header, COMDAT

; 6330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6331 : 	stbi_uc version;
; 6332 : 	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 71					; 00000047H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 73					; 00000049H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 56					; 00000038H
	je	SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6333 : 		return stbi__err("not GIF", "Corrupt GIF");

	push	OFFSET ??_C@_07KMJLPAII@not?5GIF@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__gif_
$LN2@stbi__gif_:

; 6334 : 
; 6335 : 	version = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _version$[ebp], al

; 6336 : 	if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

	movzx	eax, BYTE PTR _version$[ebp]
	cmp	eax, 55					; 00000037H
	je	SHORT $LN4@stbi__gif_
	movzx	eax, BYTE PTR _version$[ebp]
	cmp	eax, 57					; 00000039H
	je	SHORT $LN4@stbi__gif_
	push	OFFSET ??_C@_07KMJLPAII@not?5GIF@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__gif_
$LN4@stbi__gif_:

; 6337 : 	if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 97					; 00000061H
	je	SHORT $LN5@stbi__gif_
	push	OFFSET ??_C@_07KMJLPAII@not?5GIF@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__gif_
$LN5@stbi__gif_:

; 6338 : 
; 6339 : 	stbi__g_failure_reason = "";

	mov	DWORD PTR ?stbi__g_failure_reason@@3PBDB, OFFSET ??_C@_00CNPNBAHC@@

; 6340 : 	g->w = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx], eax

; 6341 : 	g->h = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 6342 : 	g->flags = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 6343 : 	g->bgindex = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 6344 : 	g->ratio = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 6345 : 	g->transparent = -1;

	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+32], -1

; 6346 : 
; 6347 : 	if (comp != 0)* comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN6@stbi__gif_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax], 4
$LN6@stbi__gif_:

; 6348 : 
; 6349 : 	if (is_info) return 1;

	cmp	DWORD PTR _is_info$[ebp], 0
	je	SHORT $LN7@stbi__gif_
	mov	eax, 1
	jmp	SHORT $LN1@stbi__gif_
$LN7@stbi__gif_:

; 6350 : 
; 6351 : 	if (g->flags & 0x80)

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 128				; 00000080H
	je	SHORT $LN8@stbi__gif_

; 6352 : 		stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

	push	-1
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 7
	mov	edx, 2
	shl	edx, cl
	push	edx
	mov	eax, DWORD PTR _g$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__gif_parse_colortable@@YAXPAUstbi__context@@QAY03EHH@Z ; stbi__gif_parse_colortable
	add	esp, 16					; 00000010H
$LN8@stbi__gif_:

; 6353 : 
; 6354 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 6355 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_header@@YAHPAUstbi__context@@PAUstbi__gif@@PAHH@Z ENDP ; stbi__gif_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_parse_colortable@@YAXPAUstbi__context@@QAY03EHH@Z
_TEXT	SEGMENT
tv89 = -208						; size = 4
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_pal$ = 12						; size = 4
_num_entries$ = 16					; size = 4
_transp$ = 20						; size = 4
?stbi__gif_parse_colortable@@YAXPAUstbi__context@@QAY03EHH@Z PROC ; stbi__gif_parse_colortable, COMDAT

; 6319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6320 : 	int i;
; 6321 : 	for (i = 0; i < num_entries; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__gif_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_entries$[ebp]
	jge	$LN1@stbi__gif_

; 6322 : 		pal[i][2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR [ecx+edx], al

; 6323 : 		pal[i][1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR [ecx+edx], al

; 6324 : 		pal[i][0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	imul	edx, edx, 0
	mov	BYTE PTR [ecx+edx], al

; 6325 : 		pal[i][3] = transp == i ? 0 : 255;

	mov	eax, DWORD PTR _transp$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN6@stbi__gif_
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
	mov	DWORD PTR tv89[ebp], 255		; 000000ffH
$LN7@stbi__gif_:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	cl, BYTE PTR tv89[ebp]
	mov	BYTE PTR [eax+edx], cl

; 6326 : 	}

	jmp	$LN2@stbi__gif_
$LN1@stbi__gif_:

; 6327 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_parse_colortable@@YAXPAUstbi__context@@QAY03EHH@Z ENDP ; stbi__gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_test_raw@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_sz$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__gif_test_raw@@YAHPAUstbi__context@@@Z PROC	; stbi__gif_test_raw, COMDAT

; 6302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6303 : 	int sz;
; 6304 : 	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 71					; 00000047H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 73					; 00000049H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN3@stbi__gif_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 56					; 00000038H
	je	SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6305 : 	sz = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 6306 : 	if (sz != '9' && sz != '7') return 0;

	cmp	DWORD PTR _sz$[ebp], 57			; 00000039H
	je	SHORT $LN4@stbi__gif_
	cmp	DWORD PTR _sz$[ebp], 55			; 00000037H
	je	SHORT $LN4@stbi__gif_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6307 : 	if (stbi__get8(s) != 'a') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 97					; 00000061H
	je	SHORT $LN5@stbi__gif_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6308 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 6309 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_test_raw@@YAHPAUstbi__context@@@Z ENDP	; stbi__gif_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_load_core@@YAPAEPAUstbi__context@@HHPAHPAE@Z
_TEXT	SEGMENT
tv234 = -444						; size = 4
tv213 = -444						; size = 4
tv203 = -444						; size = 4
tv172 = -444						; size = 4
tv152 = -444						; size = 4
tv148 = -444						; size = 4
tv136 = -444						; size = 4
tv132 = -444						; size = 4
tv93 = -444						; size = 4
tv68 = -444						; size = 4
_value$1 = -244						; size = 4
_i$2 = -232						; size = 4
_count$3 = -220						; size = 4
_left$4 = -208						; size = 4
_value$5 = -196						; size = 4
_count$6 = -181						; size = 1
_i$7 = -172						; size = 4
_left$8 = -160						; size = 4
_x$9 = -148						; size = 4
_dest$10 = -136						; size = 4
_packet$11 = -124					; size = 4
_packet_idx$12 = -112					; size = 4
_packet$13 = -100					; size = 4
_packets$ = -88						; size = 30
_chained$ = -48						; size = 4
_y$ = -36						; size = 4
_num_packets$ = -24					; size = 4
_act_comp$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_comp$ = 20						; size = 4
_result$ = 24						; size = 4
?stbi__pic_load_core@@YAPAEPAUstbi__context@@HHPAHPAE@Z PROC ; stbi__pic_load_core, COMDAT

; 6116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6117 : 	int act_comp = 0, num_packets = 0, y, chained;

	mov	DWORD PTR _act_comp$[ebp], 0
	mov	DWORD PTR _num_packets$[ebp], 0
$LN4@stbi__pic_:

; 6118 : 	stbi__pic_packet packets[10];
; 6119 : 
; 6120 : 	// this will (should...) cater for even some bizarre stuff like having data
; 6121 : 	 // for the same channel in multiple packets.
; 6122 : 	do {
; 6123 : 		stbi__pic_packet* packet;
; 6124 : 
; 6125 : 		if (num_packets == sizeof(packets) / sizeof(packets[0]))

	cmp	DWORD PTR _num_packets$[ebp], 10	; 0000000aH
	jne	SHORT $LN29@stbi__pic_

; 6126 : 			return stbi__errpuc("bad format", "too many packets");

	push	OFFSET ??_C@_0L@DMAPJJO@bad?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN50@stbi__pic_
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
	mov	DWORD PTR tv68[ebp], 0
$LN51@stbi__pic_:
	mov	eax, DWORD PTR tv68[ebp]
	jmp	$LN1@stbi__pic_
$LN29@stbi__pic_:

; 6127 : 
; 6128 : 		packet = &packets[num_packets++];

	imul	eax, DWORD PTR _num_packets$[ebp], 3
	lea	ecx, DWORD PTR _packets$[ebp+eax]
	mov	DWORD PTR _packet$13[ebp], ecx
	mov	edx, DWORD PTR _num_packets$[ebp]
	add	edx, 1
	mov	DWORD PTR _num_packets$[ebp], edx

; 6129 : 
; 6130 : 		chained = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _chained$[ebp], ecx

; 6131 : 		packet->size = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$13[ebp]
	mov	BYTE PTR [ecx], al

; 6132 : 		packet->type = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$13[ebp]
	mov	BYTE PTR [ecx+1], al

; 6133 : 		packet->channel = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$13[ebp]
	mov	BYTE PTR [ecx+2], al

; 6134 : 
; 6135 : 		act_comp |= packet->channel;

	mov	eax, DWORD PTR _packet$13[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	or	ecx, DWORD PTR _act_comp$[ebp]
	mov	DWORD PTR _act_comp$[ebp], ecx

; 6136 : 
; 6137 : 		if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN30@stbi__pic_
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN52@stbi__pic_
	mov	DWORD PTR tv93[ebp], 0
	jmp	SHORT $LN53@stbi__pic_
$LN52@stbi__pic_:
	mov	DWORD PTR tv93[ebp], 0
$LN53@stbi__pic_:
	mov	eax, DWORD PTR tv93[ebp]
	jmp	$LN1@stbi__pic_
$LN30@stbi__pic_:

; 6138 : 		if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");

	mov	eax, DWORD PTR _packet$13[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 8
	je	SHORT $LN2@stbi__pic_
	push	OFFSET ??_C@_0L@DMAPJJO@bad?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN54@stbi__pic_
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $LN55@stbi__pic_
$LN54@stbi__pic_:
	mov	DWORD PTR tv132[ebp], 0
$LN55@stbi__pic_:
	mov	eax, DWORD PTR tv132[ebp]
	jmp	$LN1@stbi__pic_
$LN2@stbi__pic_:

; 6139 : 	} while (chained);

	cmp	DWORD PTR _chained$[ebp], 0
	jne	$LN4@stbi__pic_

; 6140 : 
; 6141 : 	*comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	mov	eax, DWORD PTR _act_comp$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN56@stbi__pic_
	mov	DWORD PTR tv136[ebp], 4
	jmp	SHORT $LN57@stbi__pic_
$LN56@stbi__pic_:
	mov	DWORD PTR tv136[ebp], 3
$LN57@stbi__pic_:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR [ecx], edx

; 6142 : 
; 6143 : 	for (y = 0; y < height; ++y) {

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN7@stbi__pic_:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	$LN6@stbi__pic_

; 6144 : 		int packet_idx;
; 6145 : 
; 6146 : 		for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {

	mov	DWORD PTR _packet_idx$12[ebp], 0
	jmp	SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
	mov	eax, DWORD PTR _packet_idx$12[ebp]
	add	eax, 1
	mov	DWORD PTR _packet_idx$12[ebp], eax
$LN10@stbi__pic_:
	mov	eax, DWORD PTR _packet_idx$12[ebp]
	cmp	eax, DWORD PTR _num_packets$[ebp]
	jge	$LN9@stbi__pic_

; 6147 : 			stbi__pic_packet* packet = &packets[packet_idx];

	imul	eax, DWORD PTR _packet_idx$12[ebp], 3
	lea	ecx, DWORD PTR _packets$[ebp+eax]
	mov	DWORD PTR _packet$11[ebp], ecx

; 6148 : 			stbi_uc* dest = result + y * width * 4;

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dest$10[ebp], edx

; 6149 : 
; 6150 : 			switch (packet->type) {

	mov	eax, DWORD PTR _packet$11[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv148[ebp], cl
	cmp	BYTE PTR tv148[ebp], 0
	je	SHORT $LN33@stbi__pic_
	cmp	BYTE PTR tv148[ebp], 1
	je	$LN35@stbi__pic_
	cmp	BYTE PTR tv148[ebp], 2
	je	$LN39@stbi__pic_

; 6151 : 			default:
; 6152 : 				return stbi__errpuc("bad format", "packet has bad compression type");

	push	OFFSET ??_C@_0L@DMAPJJO@bad?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN58@stbi__pic_
	mov	DWORD PTR tv152[ebp], 0
	jmp	SHORT $LN59@stbi__pic_
$LN58@stbi__pic_:
	mov	DWORD PTR tv152[ebp], 0
$LN59@stbi__pic_:
	mov	eax, DWORD PTR tv152[ebp]
	jmp	$LN1@stbi__pic_
$LN33@stbi__pic_:

; 6153 : 
; 6154 : 			case 0: {//uncompressed
; 6155 : 				int x;
; 6156 : 
; 6157 : 				for (x = 0; x < width; ++x, dest += 4)

	mov	DWORD PTR _x$9[ebp], 0
	jmp	SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
	mov	eax, DWORD PTR _x$9[ebp]
	add	eax, 1
	mov	DWORD PTR _x$9[ebp], eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	add	ecx, 4
	mov	DWORD PTR _dest$10[ebp], ecx
$LN15@stbi__pic_:
	mov	eax, DWORD PTR _x$9[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jge	SHORT $LN14@stbi__pic_

; 6158 : 					if (!stbi__readval(s, packet->channel, dest))

	mov	eax, DWORD PTR _dest$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$11[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z ; stbi__readval
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@stbi__pic_

; 6159 : 						return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN34@stbi__pic_:
	jmp	SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 6160 : 				break;

	jmp	$LN11@stbi__pic_
$LN35@stbi__pic_:

; 6161 : 			}
; 6162 : 
; 6163 : 			case 1://Pure RLE
; 6164 : 			{
; 6165 : 				int left = width, i;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _left$8[ebp], eax
$LN16@stbi__pic_:

; 6166 : 
; 6167 : 				while (left > 0) {

	cmp	DWORD PTR _left$8[ebp], 0
	jle	$LN17@stbi__pic_

; 6168 : 					stbi_uc count, value[4];
; 6169 : 
; 6170 : 					count = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _count$6[ebp], al

; 6171 : 					if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@stbi__pic_
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN60@stbi__pic_
	mov	DWORD PTR tv172[ebp], 0
	jmp	SHORT $LN61@stbi__pic_
$LN60@stbi__pic_:
	mov	DWORD PTR tv172[ebp], 0
$LN61@stbi__pic_:
	mov	eax, DWORD PTR tv172[ebp]
	jmp	$LN1@stbi__pic_
$LN36@stbi__pic_:

; 6172 : 
; 6173 : 					if (count > left)

	movzx	eax, BYTE PTR _count$6[ebp]
	cmp	eax, DWORD PTR _left$8[ebp]
	jle	SHORT $LN37@stbi__pic_

; 6174 : 						count = (stbi_uc)left;

	mov	al, BYTE PTR _left$8[ebp]
	mov	BYTE PTR _count$6[ebp], al
$LN37@stbi__pic_:

; 6175 : 
; 6176 : 					if (!stbi__readval(s, packet->channel, value))  return 0;

	lea	eax, DWORD PTR _value$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$11[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z ; stbi__readval
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN38@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN38@stbi__pic_:

; 6177 : 
; 6178 : 					for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	add	ecx, 4
	mov	DWORD PTR _dest$10[ebp], ecx
$LN20@stbi__pic_:
	movzx	eax, BYTE PTR _count$6[ebp]
	cmp	DWORD PTR _i$7[ebp], eax
	jge	SHORT $LN19@stbi__pic_

; 6179 : 						stbi__copyval(packet->channel, dest, value);

	lea	eax, DWORD PTR _value$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$11[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	?stbi__copyval@@YAXHPAEPBE@Z		; stbi__copyval
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 6180 : 					left -= count;

	movzx	eax, BYTE PTR _count$6[ebp]
	mov	ecx, DWORD PTR _left$8[ebp]
	sub	ecx, eax
	mov	DWORD PTR _left$8[ebp], ecx

; 6181 : 				}

	jmp	$LN16@stbi__pic_
$LN17@stbi__pic_:

; 6182 : 			}
; 6183 : 			break;

	jmp	$LN11@stbi__pic_
$LN39@stbi__pic_:

; 6184 : 
; 6185 : 			case 2: {//Mixed RLE
; 6186 : 				int left = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _left$4[ebp], eax
$LN21@stbi__pic_:

; 6187 : 				while (left > 0) {

	cmp	DWORD PTR _left$4[ebp], 0
	jle	$LN11@stbi__pic_

; 6188 : 					int count = stbi__get8(s), i;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _count$3[ebp], ecx

; 6189 : 					if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN40@stbi__pic_
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@stbi__pic_
	mov	DWORD PTR tv203[ebp], 0
	jmp	SHORT $LN63@stbi__pic_
$LN62@stbi__pic_:
	mov	DWORD PTR tv203[ebp], 0
$LN63@stbi__pic_:
	mov	eax, DWORD PTR tv203[ebp]
	jmp	$LN1@stbi__pic_
$LN40@stbi__pic_:

; 6190 : 
; 6191 : 					if (count >= 128) { // Repeated

	cmp	DWORD PTR _count$3[ebp], 128		; 00000080H
	jl	$LN41@stbi__pic_

; 6192 : 						stbi_uc value[4];
; 6193 : 
; 6194 : 						if (count == 128)

	cmp	DWORD PTR _count$3[ebp], 128		; 00000080H
	jne	SHORT $LN43@stbi__pic_

; 6195 : 							count = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _count$3[ebp], eax
	jmp	SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6196 : 						else
; 6197 : 							count -= 127;

	mov	eax, DWORD PTR _count$3[ebp]
	sub	eax, 127				; 0000007fH
	mov	DWORD PTR _count$3[ebp], eax
$LN44@stbi__pic_:

; 6198 : 						if (count > left)

	mov	eax, DWORD PTR _count$3[ebp]
	cmp	eax, DWORD PTR _left$4[ebp]
	jle	SHORT $LN45@stbi__pic_

; 6199 : 							return stbi__errpuc("bad file", "scanline overrun");

	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN64@stbi__pic_
	mov	DWORD PTR tv213[ebp], 0
	jmp	SHORT $LN65@stbi__pic_
$LN64@stbi__pic_:
	mov	DWORD PTR tv213[ebp], 0
$LN65@stbi__pic_:
	mov	eax, DWORD PTR tv213[ebp]
	jmp	$LN1@stbi__pic_
$LN45@stbi__pic_:

; 6200 : 
; 6201 : 						if (!stbi__readval(s, packet->channel, value))

	lea	eax, DWORD PTR _value$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$11[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z ; stbi__readval
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN46@stbi__pic_

; 6202 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN46@stbi__pic_:

; 6203 : 
; 6204 : 						for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	add	ecx, 4
	mov	DWORD PTR _dest$10[ebp], ecx
$LN25@stbi__pic_:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _count$3[ebp]
	jge	SHORT $LN24@stbi__pic_

; 6205 : 							stbi__copyval(packet->channel, dest, value);

	lea	eax, DWORD PTR _value$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$11[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	?stbi__copyval@@YAXHPAEPBE@Z		; stbi__copyval
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 6206 : 					}

	jmp	$LN42@stbi__pic_
$LN41@stbi__pic_:

; 6207 : 					else { // Raw
; 6208 : 						++count;

	mov	eax, DWORD PTR _count$3[ebp]
	add	eax, 1
	mov	DWORD PTR _count$3[ebp], eax

; 6209 : 						if (count > left) return stbi__errpuc("bad file", "scanline overrun");

	mov	eax, DWORD PTR _count$3[ebp]
	cmp	eax, DWORD PTR _left$4[ebp]
	jle	SHORT $LN47@stbi__pic_
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@stbi__pic_
	mov	DWORD PTR tv234[ebp], 0
	jmp	SHORT $LN67@stbi__pic_
$LN66@stbi__pic_:
	mov	DWORD PTR tv234[ebp], 0
$LN67@stbi__pic_:
	mov	eax, DWORD PTR tv234[ebp]
	jmp	$LN1@stbi__pic_
$LN47@stbi__pic_:

; 6210 : 
; 6211 : 						for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
	mov	ecx, DWORD PTR _dest$10[ebp]
	add	ecx, 4
	mov	DWORD PTR _dest$10[ebp], ecx
$LN28@stbi__pic_:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _count$3[ebp]
	jge	SHORT $LN42@stbi__pic_

; 6212 : 							if (!stbi__readval(s, packet->channel, dest))

	mov	eax, DWORD PTR _dest$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$11[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z ; stbi__readval
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN48@stbi__pic_

; 6213 : 								return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
	jmp	SHORT $LN26@stbi__pic_
$LN42@stbi__pic_:

; 6214 : 					}
; 6215 : 					left -= count;

	mov	eax, DWORD PTR _left$4[ebp]
	sub	eax, DWORD PTR _count$3[ebp]
	mov	DWORD PTR _left$4[ebp], eax

; 6216 : 				}

	jmp	$LN21@stbi__pic_
$LN11@stbi__pic_:

; 6217 : 				break;
; 6218 : 			}
; 6219 : 			}
; 6220 : 		}

	jmp	$LN8@stbi__pic_
$LN9@stbi__pic_:

; 6221 : 	}

	jmp	$LN5@stbi__pic_
$LN6@stbi__pic_:

; 6222 : 
; 6223 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi__pic_:

; 6224 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN72@stbi__pic_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@stbi__pic_:
	DD	3
	DD	$LN71@stbi__pic_
$LN71@stbi__pic_:
	DD	-88					; ffffffa8H
	DD	30					; 0000001eH
	DD	$LN68@stbi__pic_
	DD	-196					; ffffff3cH
	DD	4
	DD	$LN69@stbi__pic_
	DD	-244					; ffffff0cH
	DD	4
	DD	$LN70@stbi__pic_
$LN70@stbi__pic_:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN69@stbi__pic_:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN68@stbi__pic_:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?stbi__pic_load_core@@YAPAEPAUstbi__context@@HHPAHPAE@Z ENDP ; stbi__pic_load_core
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__copyval@@YAXHPAEPBE@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_mask$ = -8						; size = 4
_channel$ = 8						; size = 4
_dest$ = 12						; size = 4
_src$ = 16						; size = 4
?stbi__copyval@@YAXHPAEPBE@Z PROC			; stbi__copyval, COMDAT

; 6107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6108 : 	int mask = 0x80, i;

	mov	DWORD PTR _mask$[ebp], 128		; 00000080H

; 6109 : 
; 6110 : 	for (i = 0; i < 4; ++i, mask >>= 1)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__copy
$LN2@stbi__copy:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mask$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx
$LN4@stbi__copy:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN1@stbi__copy

; 6111 : 		if (channel & mask)

	mov	eax, DWORD PTR _channel$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	je	SHORT $LN5@stbi__copy

; 6112 : 			dest[i] = src[i];

	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN5@stbi__copy:
	jmp	SHORT $LN2@stbi__copy
$LN1@stbi__copy:

; 6113 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__copyval@@YAXHPAEPBE@Z ENDP			; stbi__copyval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z
_TEXT	SEGMENT
tv75 = -220						; size = 4
_i$ = -20						; size = 4
_mask$ = -8						; size = 4
_s$ = 8							; size = 4
_channel$ = 12						; size = 4
_dest$ = 16						; size = 4
?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z PROC	; stbi__readval, COMDAT

; 6093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6094 : 	int mask = 0x80, i;

	mov	DWORD PTR _mask$[ebp], 128		; 00000080H

; 6095 : 
; 6096 : 	for (i = 0; i < 4; ++i, mask >>= 1) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__read
$LN2@stbi__read:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mask$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx
$LN4@stbi__read:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@stbi__read

; 6097 : 		if (channel & mask) {

	mov	eax, DWORD PTR _channel$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	je	SHORT $LN5@stbi__read

; 6098 : 			if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__read
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@stbi__read
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN9@stbi__read
$LN8@stbi__read:
	mov	DWORD PTR tv75[ebp], 0
$LN9@stbi__read:
	mov	eax, DWORD PTR tv75[ebp]
	jmp	SHORT $LN1@stbi__read
$LN6@stbi__read:

; 6099 : 			dest[i] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
$LN5@stbi__read:

; 6100 : 		}
; 6101 : 	}

	jmp	SHORT $LN2@stbi__read
$LN3@stbi__read:

; 6102 : 
; 6103 : 	return dest;

	mov	eax, DWORD PTR _dest$[ebp]
$LN1@stbi__read:

; 6104 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__readval@@YAPAEPAUstbi__context@@HPAE@Z ENDP	; stbi__readval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_test_core@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__pic_test_core@@YAHPAUstbi__context@@@Z PROC	; stbi__pic_test_core, COMDAT

; 6072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6073 : 	int i;
; 6074 : 
; 6075 : 	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))

	push	OFFSET ??_C@_04KBFEPHFH@S?$IA?v4@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z ; stbi__pic_is4
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@stbi__pic_

; 6076 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:

; 6077 : 
; 6078 : 	for (i = 0; i < 84; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR _i$[ebp], 84			; 00000054H
	jge	SHORT $LN3@stbi__pic_

; 6079 : 		stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6080 : 
; 6081 : 	if (!stbi__pic_is4(s, "PICT"))

	push	OFFSET ??_C@_04ELNJHLFH@PICT@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z ; stbi__pic_is4
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@stbi__pic_

; 6082 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6083 : 
; 6084 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 6085 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pic_test_core@@YAHPAUstbi__context@@@Z ENDP	; stbi__pic_test_core
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_str$ = 12						; size = 4
?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z PROC		; stbi__pic_is4, COMDAT

; 6062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6063 : 	int i;
; 6064 : 	for (i = 0; i < 4; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@stbi__pic_

; 6065 : 		if (stbi__get8(s) != (stbi_uc)str[i])

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	je	SHORT $LN5@stbi__pic_

; 6066 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6067 : 
; 6068 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 6069 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z ENDP		; stbi__pic_is4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__psd_decode_rle@@YAHPAUstbi__context@@PAEH@Z
_TEXT	SEGMENT
_val$1 = -41						; size = 1
_len$ = -32						; size = 4
_nleft$ = -20						; size = 4
_count$ = -8						; size = 4
_s$ = 8							; size = 4
_p$ = 12						; size = 4
_pixelCount$ = 16					; size = 4
?stbi__psd_decode_rle@@YAHPAUstbi__context@@PAEH@Z PROC	; stbi__psd_decode_rle, COMDAT

; 5807 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5808 : 	int count, nleft, len;
; 5809 : 
; 5810 : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0
$LN2@stbi__psd_:

; 5811 : 	while ((nleft = pixelCount - count) > 0) {

	mov	eax, DWORD PTR _pixelCount$[ebp]
	sub	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _nleft$[ebp], eax
	cmp	DWORD PTR _nleft$[ebp], 0
	jle	$LN3@stbi__psd_

; 5812 : 		len = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$[ebp], ecx

; 5813 : 		if (len == 128) {

	cmp	DWORD PTR _len$[ebp], 128		; 00000080H
	jne	SHORT $LN8@stbi__psd_

; 5814 : 			// No-op.
; 5815 : 		}

	jmp	$LN9@stbi__psd_
$LN8@stbi__psd_:

; 5816 : 		else if (len < 128) {

	cmp	DWORD PTR _len$[ebp], 128		; 00000080H
	jge	SHORT $LN10@stbi__psd_

; 5817 : 			// Copy next len+1 bytes literally.
; 5818 : 			len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 5819 : 			if (len > nleft) return 0; // corrupt data

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _nleft$[ebp]
	jle	SHORT $LN12@stbi__psd_
	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN12@stbi__psd_:

; 5820 : 			count += len;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN4@stbi__psd_:

; 5821 : 			while (len) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN5@stbi__psd_

; 5822 : 				*p = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx], al

; 5823 : 				p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 5824 : 				len--;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 5825 : 			}

	jmp	SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 5826 : 		}

	jmp	SHORT $LN9@stbi__psd_
$LN10@stbi__psd_:

; 5827 : 		else if (len > 128) {

	cmp	DWORD PTR _len$[ebp], 128		; 00000080H
	jle	SHORT $LN9@stbi__psd_

; 5828 : 			stbi_uc   val;
; 5829 : 			// Next -len+1 bytes in the dest are replicated from next source byte.
; 5830 : 			// (Interpret len as a negative 8-bit int.)
; 5831 : 			len = 257 - len;

	mov	eax, 257				; 00000101H
	sub	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 5832 : 			if (len > nleft) return 0; // corrupt data

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _nleft$[ebp]
	jle	SHORT $LN14@stbi__psd_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN14@stbi__psd_:

; 5833 : 			val = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _val$1[ebp], al

; 5834 : 			count += len;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN6@stbi__psd_:

; 5835 : 			while (len) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN9@stbi__psd_

; 5836 : 				*p = val;

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR _val$1[ebp]
	mov	BYTE PTR [eax], cl

; 5837 : 				p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 5838 : 				len--;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 5839 : 			}

	jmp	SHORT $LN6@stbi__psd_
$LN9@stbi__psd_:

; 5840 : 		}
; 5841 : 	}

	jmp	$LN2@stbi__psd_
$LN3@stbi__psd_:

; 5842 : 
; 5843 : 	return 1;

	mov	eax, 1
$LN1@stbi__psd_:

; 5844 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__psd_decode_rle@@YAHPAUstbi__context@@PAEH@Z ENDP	; stbi__psd_decode_rle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__tga_read_rgb16@@YAXPAUstbi__context@@PAE@Z
_TEXT	SEGMENT
_b$ = -56						; size = 4
_g$ = -44						; size = 4
_r$ = -32						; size = 4
_fiveBitMask$ = -20					; size = 2
_px$ = -8						; size = 2
_s$ = 8							; size = 4
_out$ = 12						; size = 4
?stbi__tga_read_rgb16@@YAXPAUstbi__context@@PAE@Z PROC	; stbi__tga_read_rgb16, COMDAT

; 5576 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5577 : 	stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	WORD PTR _px$[ebp], ax

; 5578 : 	stbi__uint16 fiveBitMask = 31;

	mov	eax, 31					; 0000001fH
	mov	WORD PTR _fiveBitMask$[ebp], ax

; 5579 : 	// we have 3 channels with 5bits each
; 5580 : 	int r = (px >> 10) & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	sar	eax, 10					; 0000000aH
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _r$[ebp], eax

; 5581 : 	int g = (px >> 5) & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	sar	eax, 5
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _g$[ebp], eax

; 5582 : 	int b = px & fiveBitMask;

	movzx	eax, WORD PTR _px$[ebp]
	movzx	ecx, WORD PTR _fiveBitMask$[ebp]
	and	eax, ecx
	mov	DWORD PTR _b$[ebp], eax

; 5583 : 	// Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5584 : 	out[0] = (stbi_uc)((r * 255) / 31);

	imul	eax, DWORD PTR _r$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 5585 : 	out[1] = (stbi_uc)((g * 255) / 31);

	imul	eax, DWORD PTR _g$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5586 : 	out[2] = (stbi_uc)((b * 255) / 31);

	imul	eax, DWORD PTR _b$[ebp], 255
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 5587 : 
; 5588 : 	// some people claim that the most significant bit might be used for alpha
; 5589 : 	// (possibly if an alpha-bit is set in the "image descriptor byte")
; 5590 : 	// but that only made 16bit test images completely translucent..
; 5591 : 	// so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5592 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__tga_read_rgb16@@YAXPAUstbi__context@@PAE@Z ENDP	; stbi__tga_read_rgb16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__tga_get_comp@@YAHHHPAH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_bits_per_pixel$ = 8					; size = 4
_is_grey$ = 12						; size = 4
_is_rgb16$ = 16						; size = 4
?stbi__tga_get_comp@@YAHHHPAH@Z PROC			; stbi__tga_get_comp, COMDAT

; 5460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5461 : 	// only RGB or RGBA (incl. 16bit) or grey allowed
; 5462 : 	if (is_rgb16)* is_rgb16 = 0;

	cmp	DWORD PTR _is_rgb16$[ebp], 0
	je	SHORT $LN4@stbi__tga_
	mov	eax, DWORD PTR _is_rgb16$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@stbi__tga_:

; 5463 : 	switch (bits_per_pixel) {

	mov	eax, DWORD PTR _bits_per_pixel$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 8
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 24			; 00000018H
	ja	SHORT $LN11@stbi__tga_
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN13@stbi__tga_[edx]
	jmp	DWORD PTR $LN14@stbi__tga_[eax*4]
$LN5@stbi__tga_:

; 5464 : 	case 8:  return STBI_grey;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5465 : 	case 16: if (is_grey) return STBI_grey_alpha;

	cmp	DWORD PTR _is_grey$[ebp], 0
	je	SHORT $LN8@stbi__tga_
	mov	eax, 2
	jmp	SHORT $LN1@stbi__tga_
$LN8@stbi__tga_:

; 5466 : 		// fallthrough
; 5467 : 	case 15: if (is_rgb16) * is_rgb16 = 1;

	cmp	DWORD PTR _is_rgb16$[ebp], 0
	je	SHORT $LN9@stbi__tga_
	mov	eax, DWORD PTR _is_rgb16$[ebp]
	mov	DWORD PTR [eax], 1
$LN9@stbi__tga_:

; 5468 : 		return STBI_rgb;

	mov	eax, 3
	jmp	SHORT $LN1@stbi__tga_
$LN10@stbi__tga_:

; 5469 : 	case 24: // fallthrough
; 5470 : 	case 32: return bits_per_pixel / 8;

	mov	eax, DWORD PTR _bits_per_pixel$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	jmp	SHORT $LN1@stbi__tga_
$LN11@stbi__tga_:

; 5471 : 	default: return 0;

	xor	eax, eax
$LN1@stbi__tga_:

; 5472 : 	}
; 5473 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@stbi__tga_:
	DD	$LN5@stbi__tga_
	DD	$LN8@stbi__tga_
	DD	$LN6@stbi__tga_
	DD	$LN10@stbi__tga_
	DD	$LN11@stbi__tga_
$LN13@stbi__tga_:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?stbi__tga_get_comp@@YAHHHPAH@Z ENDP			; stbi__tga_get_comp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bmp_parse_header@@YAPAXPAUstbi__context@@PAUstbi__bmp_data@@@Z
_TEXT	SEGMENT
tv218 = -232						; size = 4
tv212 = -232						; size = 4
tv208 = -232						; size = 4
tv161 = -232						; size = 4
tv149 = -232						; size = 4
tv129 = -232						; size = 4
tv75 = -232						; size = 4
_i$1 = -32						; size = 4
_compress$2 = -20					; size = 4
_hsz$ = -8						; size = 4
_s$ = 8							; size = 4
_info$ = 12						; size = 4
?stbi__bmp_parse_header@@YAPAXPAUstbi__context@@PAUstbi__bmp_data@@@Z PROC ; stbi__bmp_parse_header, COMDAT

; 5184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5185 : 	int hsz;
; 5186 : 	if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN6@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN5@stbi__bmp_
$LN6@stbi__bmp_:
	push	OFFSET ??_C@_07IANEBNLB@not?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN30@stbi__bmp_
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN31@stbi__bmp_
$LN30@stbi__bmp_:
	mov	DWORD PTR tv75[ebp], 0
$LN31@stbi__bmp_:
	mov	eax, DWORD PTR tv75[ebp]
	jmp	$LN1@stbi__bmp_
$LN5@stbi__bmp_:

; 5187 : 	stbi__get32le(s); // discard filesize

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5188 : 	stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4

; 5189 : 	stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4

; 5190 : 	info->offset = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5191 : 	info->hsz = hsz = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	DWORD PTR _hsz$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _hsz$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 5192 : 	info->mr = info->mg = info->mb = info->ma = 0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 0

; 5193 : 
; 5194 : 	if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	je	SHORT $LN7@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 40		; 00000028H
	je	SHORT $LN7@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	je	SHORT $LN7@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 108		; 0000006cH
	je	SHORT $LN7@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	je	SHORT $LN7@stbi__bmp_
	push	OFFSET ??_C@_0M@KHBIBJBG@unknown?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@stbi__bmp_
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN33@stbi__bmp_
$LN32@stbi__bmp_:
	mov	DWORD PTR tv129[ebp], 0
$LN33@stbi__bmp_:
	mov	eax, DWORD PTR tv129[ebp]
	jmp	$LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 5195 : 	if (hsz == 12) {

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	jne	SHORT $LN8@stbi__bmp_

; 5196 : 		s->img_x = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 5197 : 		s->img_y = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5198 : 	}

	jmp	SHORT $LN9@stbi__bmp_
$LN8@stbi__bmp_:

; 5199 : 	else {
; 5200 : 		s->img_x = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax

; 5201 : 		s->img_y = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN9@stbi__bmp_:

; 5202 : 	}
; 5203 : 	if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN10@stbi__bmp_
	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN34@stbi__bmp_
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN35@stbi__bmp_
$LN34@stbi__bmp_:
	mov	DWORD PTR tv149[ebp], 0
$LN35@stbi__bmp_:
	mov	eax, DWORD PTR tv149[ebp]
	jmp	$LN1@stbi__bmp_
$LN10@stbi__bmp_:

; 5204 : 	info->bpp = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], eax

; 5205 : 	if (hsz != 12) {

	cmp	DWORD PTR _hsz$[ebp], 12		; 0000000cH
	je	$LN11@stbi__bmp_

; 5206 : 		int compress = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	DWORD PTR _compress$2[ebp], eax

; 5207 : 		if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

	cmp	DWORD PTR _compress$2[ebp], 1
	je	SHORT $LN13@stbi__bmp_
	cmp	DWORD PTR _compress$2[ebp], 2
	jne	SHORT $LN12@stbi__bmp_
$LN13@stbi__bmp_:
	push	OFFSET ??_C@_07IMHMNOIB@BMP?5RLE@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@stbi__bmp_
	mov	DWORD PTR tv161[ebp], 0
	jmp	SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:
	mov	DWORD PTR tv161[ebp], 0
$LN37@stbi__bmp_:
	mov	eax, DWORD PTR tv161[ebp]
	jmp	$LN1@stbi__bmp_
$LN12@stbi__bmp_:

; 5208 : 		stbi__get32le(s); // discard sizeof

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5209 : 		stbi__get32le(s); // discard hres

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5210 : 		stbi__get32le(s); // discard vres

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5211 : 		stbi__get32le(s); // discard colorsused

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5212 : 		stbi__get32le(s); // discard max important

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5213 : 		if (hsz == 40 || hsz == 56) {

	cmp	DWORD PTR _hsz$[ebp], 40		; 00000028H
	je	SHORT $LN16@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	jne	$LN14@stbi__bmp_
$LN16@stbi__bmp_:

; 5214 : 			if (hsz == 56) {

	cmp	DWORD PTR _hsz$[ebp], 56		; 00000038H
	jne	SHORT $LN17@stbi__bmp_

; 5215 : 				stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5216 : 				stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5217 : 				stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5218 : 				stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
$LN17@stbi__bmp_:

; 5219 : 			}
; 5220 : 			if (info->bpp == 16 || info->bpp == 32) {

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	je	SHORT $LN19@stbi__bmp_
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	$LN18@stbi__bmp_
$LN19@stbi__bmp_:

; 5221 : 				if (compress == 0) {

	cmp	DWORD PTR _compress$2[ebp], 0
	jne	SHORT $LN20@stbi__bmp_

; 5222 : 					if (info->bpp == 32) {

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	SHORT $LN22@stbi__bmp_

; 5223 : 						info->mr = 0xffu << 16;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 16711680		; 00ff0000H

; 5224 : 						info->mg = 0xffu << 8;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], 65280		; 0000ff00H

; 5225 : 						info->mb = 0xffu << 0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+20], 255			; 000000ffH

; 5226 : 						info->ma = 0xffu << 24;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+24], -16777216		; ff000000H

; 5227 : 						info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+28], 0

; 5228 : 					}

	jmp	SHORT $LN23@stbi__bmp_
$LN22@stbi__bmp_:

; 5229 : 					else {
; 5230 : 						info->mr = 31u << 10;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 31744		; 00007c00H

; 5231 : 						info->mg = 31u << 5;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], 992			; 000003e0H

; 5232 : 						info->mb = 31u << 0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+20], 31			; 0000001fH
$LN23@stbi__bmp_:

; 5233 : 					}
; 5234 : 				}

	jmp	$LN18@stbi__bmp_
$LN20@stbi__bmp_:

; 5235 : 				else if (compress == 3) {

	cmp	DWORD PTR _compress$2[ebp], 3
	jne	$LN24@stbi__bmp_

; 5236 : 					info->mr = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5237 : 					info->mg = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 5238 : 					info->mb = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5239 : 					// not documented, but generated by photoshop and handled by mspaint
; 5240 : 					if (info->mr == info->mg && info->mg == info->mb) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN26@stbi__bmp_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN26@stbi__bmp_

; 5241 : 						// ?!?!?
; 5242 : 						return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN38@stbi__bmp_
	mov	DWORD PTR tv208[ebp], 0
	jmp	SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:
	mov	DWORD PTR tv208[ebp], 0
$LN39@stbi__bmp_:
	mov	eax, DWORD PTR tv208[ebp]
	jmp	$LN1@stbi__bmp_
$LN26@stbi__bmp_:

; 5243 : 					}
; 5244 : 				}

	jmp	SHORT $LN18@stbi__bmp_
$LN24@stbi__bmp_:

; 5245 : 				else
; 5246 : 					return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN40@stbi__bmp_
	mov	DWORD PTR tv212[ebp], 0
	jmp	SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:
	mov	DWORD PTR tv212[ebp], 0
$LN41@stbi__bmp_:
	mov	eax, DWORD PTR tv212[ebp]
	jmp	$LN1@stbi__bmp_
$LN18@stbi__bmp_:

; 5247 : 			}
; 5248 : 		}

	jmp	$LN11@stbi__bmp_
$LN14@stbi__bmp_:

; 5249 : 		else {
; 5250 : 			int i;
; 5251 : 			if (hsz != 108 && hsz != 124)

	cmp	DWORD PTR _hsz$[ebp], 108		; 0000006cH
	je	SHORT $LN27@stbi__bmp_
	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	je	SHORT $LN27@stbi__bmp_

; 5252 : 				return stbi__errpuc("bad BMP", "bad BMP");

	push	OFFSET ??_C@_07IEJCHBDI@bad?5BMP@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN42@stbi__bmp_
	mov	DWORD PTR tv218[ebp], 0
	jmp	SHORT $LN43@stbi__bmp_
$LN42@stbi__bmp_:
	mov	DWORD PTR tv218[ebp], 0
$LN43@stbi__bmp_:
	mov	eax, DWORD PTR tv218[ebp]
	jmp	$LN1@stbi__bmp_
$LN27@stbi__bmp_:

; 5253 : 			info->mr = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5254 : 			info->mg = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 5255 : 			info->mb = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 5256 : 			info->ma = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 5257 : 			stbi__get32le(s); // discard color space

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5258 : 			for (i = 0; i < 12; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@stbi__bmp_:
	cmp	DWORD PTR _i$1[ebp], 12			; 0000000cH
	jge	SHORT $LN3@stbi__bmp_

; 5259 : 				stbi__get32le(s); // discard color space parameters

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	jmp	SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5260 : 			if (hsz == 124) {

	cmp	DWORD PTR _hsz$[ebp], 124		; 0000007cH
	jne	SHORT $LN11@stbi__bmp_

; 5261 : 				stbi__get32le(s); // discard rendering intent

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5262 : 				stbi__get32le(s); // discard offset of profile data

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5263 : 				stbi__get32le(s); // discard size of profile data

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5264 : 				stbi__get32le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
$LN11@stbi__bmp_:

; 5265 : 			}
; 5266 : 		}
; 5267 : 	}
; 5268 : 	return (void*)1;

	mov	eax, 1
$LN1@stbi__bmp_:

; 5269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bmp_parse_header@@YAPAXPAUstbi__context@@PAUstbi__bmp_data@@@Z ENDP ; stbi__bmp_parse_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__shiftsigned@@YAHIHH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_shift$ = 12						; size = 4
_bits$ = 16						; size = 4
?stbi__shiftsigned@@YAHIHH@Z PROC			; stbi__shiftsigned, COMDAT

; 5158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5159 : 	static unsigned int mul_table[9] = {
; 5160 : 	   0,
; 5161 : 	   0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5162 : 	   0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5163 : 	};
; 5164 : 	static unsigned int shift_table[9] = {
; 5165 : 	   0, 0,0,1,0,2,4,6,0,
; 5166 : 	};
; 5167 : 	if (shift < 0)

	cmp	DWORD PTR _shift$[ebp], 0
	jge	SHORT $LN2@stbi__shif

; 5168 : 		v <<= -shift;

	mov	ecx, DWORD PTR _shift$[ebp]
	neg	ecx
	mov	eax, DWORD PTR _v$[ebp]
	shl	eax, cl
	mov	DWORD PTR _v$[ebp], eax
	jmp	SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 5169 : 	else
; 5170 : 		v >>= shift;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shr	eax, cl
	mov	DWORD PTR _v$[ebp], eax
$LN3@stbi__shif:

; 5171 : 	STBI_ASSERT(v >= 0 && v < 256);

	cmp	DWORD PTR _v$[ebp], 0
	jb	SHORT $LN5@stbi__shif
	cmp	DWORD PTR _v$[ebp], 256			; 00000100H
	jb	SHORT $LN6@stbi__shif
$LN5@stbi__shif:
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__shiftsigned@@YAHIHH@Z@4JA
	add	eax, 13					; 0000000dH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CE@LIEKLNBF@?$AAv?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@stbi__shif:

; 5172 : 	v >>= (8 - bits);

	mov	ecx, 8
	sub	ecx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	shr	eax, cl
	mov	DWORD PTR _v$[ebp], eax

; 5173 : 	STBI_ASSERT(bits >= 0 && bits <= 8);

	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $LN7@stbi__shif
	cmp	DWORD PTR _bits$[ebp], 8
	jle	SHORT $LN8@stbi__shif
$LN7@stbi__shif:
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__shiftsigned@@YAHIHH@Z@4JA
	add	eax, 15					; 0000000fH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@stbi__shif:

; 5174 : 	return (int)((unsigned)v * mul_table[bits]) >> shift_table[bits];

	mov	eax, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	imul	edx, DWORD PTR ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[eax*4]
	mov	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA[eax*4]
	sar	edx, cl
	mov	eax, edx

; 5175 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__shiftsigned@@YAHIHH@Z ENDP			; stbi__shiftsigned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bitcount@@YAHI@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?stbi__bitcount@@YAHI@Z PROC				; stbi__bitcount, COMDAT

; 5145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5146 : 	a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 1431655765				; 55555555H
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 1
	and	ecx, 1431655765				; 55555555H
	add	eax, ecx
	mov	DWORD PTR _a$[ebp], eax

; 5147 : 	a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 858993459				; 33333333H
	mov	ecx, DWORD PTR _a$[ebp]
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	eax, ecx
	mov	DWORD PTR _a$[ebp], eax

; 5148 : 	a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 4
	add	eax, DWORD PTR _a$[ebp]
	and	eax, 252645135				; 0f0f0f0fH
	mov	DWORD PTR _a$[ebp], eax

; 5149 : 	a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 5150 : 	a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, DWORD PTR _a$[ebp]
	shr	eax, 16					; 00000010H
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 5151 : 	return a & 0xff;

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 255				; 000000ffH

; 5152 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bitcount@@YAHI@Z ENDP				; stbi__bitcount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__high_bit@@YAHI@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_z$ = 8							; size = 4
?stbi__high_bit@@YAHI@Z PROC				; stbi__high_bit, COMDAT

; 5133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5134 : 	int n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 5135 : 	if (z == 0) return -1;

	cmp	DWORD PTR _z$[ebp], 0
	jne	SHORT $LN2@stbi__high
	or	eax, -1
	jmp	$LN1@stbi__high
$LN2@stbi__high:

; 5136 : 	if (z >= 0x10000) { n += 16; z >>= 16; }

	cmp	DWORD PTR _z$[ebp], 65536		; 00010000H
	jb	SHORT $LN3@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _z$[ebp]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _z$[ebp], eax
$LN3@stbi__high:

; 5137 : 	if (z >= 0x00100) { n += 8; z >>= 8; }

	cmp	DWORD PTR _z$[ebp], 256			; 00000100H
	jb	SHORT $LN4@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 8
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _z$[ebp]
	shr	eax, 8
	mov	DWORD PTR _z$[ebp], eax
$LN4@stbi__high:

; 5138 : 	if (z >= 0x00010) { n += 4; z >>= 4; }

	cmp	DWORD PTR _z$[ebp], 16			; 00000010H
	jb	SHORT $LN5@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 4
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _z$[ebp]
	shr	eax, 4
	mov	DWORD PTR _z$[ebp], eax
$LN5@stbi__high:

; 5139 : 	if (z >= 0x00004) { n += 2; z >>= 2; }

	cmp	DWORD PTR _z$[ebp], 4
	jb	SHORT $LN6@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 2
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _z$[ebp]
	shr	eax, 2
	mov	DWORD PTR _z$[ebp], eax
$LN6@stbi__high:

; 5140 : 	if (z >= 0x00002) { n += 1; z >>= 1; }

	cmp	DWORD PTR _z$[ebp], 2
	jb	SHORT $LN7@stbi__high
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _z$[ebp]
	shr	eax, 1
	mov	DWORD PTR _z$[ebp], eax
$LN7@stbi__high:

; 5141 : 	return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN1@stbi__high:

; 5142 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__high_bit@@YAHI@Z ENDP				; stbi__high_bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bmp_test_raw@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
tv83 = -220						; size = 4
_sz$ = -20						; size = 4
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__bmp_test_raw@@YAHPAUstbi__context@@@Z PROC	; stbi__bmp_test_raw, COMDAT

; 5109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5110 : 	int r;
; 5111 : 	int sz;
; 5112 : 	if (stbi__get8(s) != 'B') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN2@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5113 : 	if (stbi__get8(s) != 'M') return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN3@stbi__bmp_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5114 : 	stbi__get32le(s); // discard filesize

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5115 : 	stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4

; 5116 : 	stbi__get16le(s); // discard reserved

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4

; 5117 : 	stbi__get32le(s); // discard data offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4

; 5118 : 	sz = stbi__get32le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	DWORD PTR _sz$[ebp], eax

; 5119 : 	r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	DWORD PTR _sz$[ebp], 12			; 0000000cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 40			; 00000028H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 56			; 00000038H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 108		; 0000006cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _sz$[ebp], 124		; 0000007cH
	je	SHORT $LN5@stbi__bmp_
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
	mov	DWORD PTR tv83[ebp], 1
$LN6@stbi__bmp_:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _r$[ebp], eax

; 5120 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]
$LN1@stbi__bmp_:

; 5121 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bmp_test_raw@@YAHPAUstbi__context@@@Z ENDP	; stbi__bmp_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__png_info_raw@@YAHPAUstbi__png@@PAH11@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__png_info_raw@@YAHPAUstbi__png@@PAH11@Z PROC	; stbi__png_info_raw, COMDAT

; 5073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5074 : 	if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

	push	0
	push	2
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z ; stbi__parse_png_file
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@stbi__png_

; 5075 : 		stbi__rewind(p->s);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5076 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5077 : 	}
; 5078 : 	if (x)* x = p->s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN3@stbi__png_:

; 5079 : 	if (y)* y = p->s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@stbi__png_:

; 5080 : 	if (comp)* comp = p->s->img_n;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN5@stbi__png_
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN5@stbi__png_:

; 5081 : 	return 1;

	mov	eax, 1
$LN1@stbi__png_:

; 5082 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__png_info_raw@@YAHPAUstbi__png@@PAH11@Z ENDP	; stbi__png_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__do_png@@YAPAXPAUstbi__png@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_result$ = -8						; size = 4
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_n$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__do_png@@YAPAXPAUstbi__png@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__do_png, COMDAT

; 5028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5029 : 	void* result = NULL;

	mov	DWORD PTR _result$[ebp], 0

; 5030 : 	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR _req_comp$[ebp], 0
	jl	SHORT $LN3@stbi__do_p
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
	push	OFFSET ??_C@_0N@KBPNPPBJ@bad?5req_comp@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@stbi__do_p
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN14@stbi__do_p
$LN13@stbi__do_p:
	mov	DWORD PTR tv69[ebp], 0
$LN14@stbi__do_p:
	mov	eax, DWORD PTR tv69[ebp]
	jmp	$LN1@stbi__do_p
$LN2@stbi__do_p:

; 5031 : 	if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z ; stbi__parse_png_file
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@stbi__do_p

; 5032 : 		if (p->depth < 8)

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+16], 8
	jge	SHORT $LN5@stbi__do_p

; 5033 : 			ri->bits_per_channel = 8;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax], 8
	jmp	SHORT $LN6@stbi__do_p
$LN5@stbi__do_p:

; 5034 : 		else
; 5035 : 			ri->bits_per_channel = p->depth;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx
$LN6@stbi__do_p:

; 5036 : 		result = p->out;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _result$[ebp], ecx

; 5037 : 		p->out = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0

; 5038 : 		if (req_comp && req_comp != p->s->img_out_n) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	$LN7@stbi__do_p
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _req_comp$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN7@stbi__do_p

; 5039 : 			if (ri->bits_per_channel == 8)

	mov	eax, DWORD PTR _ri$[ebp]
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN8@stbi__do_p

; 5040 : 				result = stbi__convert_format((unsigned char*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	jmp	SHORT $LN9@stbi__do_p
$LN8@stbi__do_p:

; 5041 : 			else
; 5042 : 				result = stbi__convert_format16((stbi__uint16*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	?stbi__convert_format16@@YAPAGPAGHHII@Z	; stbi__convert_format16
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
$LN9@stbi__do_p:

; 5043 : 			p->s->img_out_n = req_comp;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 5044 : 			if (result == NULL) return result;

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN7@stbi__do_p
	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@stbi__do_p
$LN7@stbi__do_p:

; 5045 : 		}
; 5046 : 		*x = p->s->img_x;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5047 : 		*y = p->s->img_y;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 5048 : 		if (n)* n = p->s->img_n;

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN4@stbi__do_p
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN4@stbi__do_p:

; 5049 : 	}
; 5050 : 	STBI_FREE(p->out);      p->out = NULL;

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+12], 0

; 5051 : 	STBI_FREE(p->expanded); p->expanded = NULL;

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], 0

; 5052 : 	STBI_FREE(p->idata);    p->idata = NULL;

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], 0

; 5053 : 
; 5054 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi__do_p:

; 5055 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__do_png@@YAPAXPAUstbi__png@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__do_png
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z
_TEXT	SEGMENT
tv196 = -1896						; size = 4
tv375 = -1892						; size = 4
tv328 = -1892						; size = 4
tv193 = -1892						; size = 4
tv77 = -1892						; size = 4
$T1 = -1884						; size = 8
_bpl$2 = -1292						; size = 4
_raw_len$3 = -1280					; size = 4
_p$4 = -1268						; size = 4
_idata_limit_old$5 = -1256				; size = 4
_filter$6 = -1244					; size = 4
_comp$7 = -1232						; size = 4
_c$8 = -1220						; size = 8
_s$ = -1204						; size = 4
_is_iphone$ = -1192					; size = 4
_color$ = -1180						; size = 4
_interlace$ = -1168					; size = 4
_k$ = -1156						; size = 4
_first$ = -1144						; size = 4
_pal_len$ = -1132					; size = 4
_i$ = -1120						; size = 4
_idata_limit$ = -1108					; size = 4
_ioff$ = -1096						; size = 4
_tc16$ = -1084						; size = 6
_tc$ = -1068						; size = 3
_has_trans$ = -1053					; size = 1
_pal_img_n$ = -1041					; size = 1
_palette$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
_req_comp$ = 16						; size = 4
?stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z PROC	; stbi__parse_png_file, COMDAT

; 4851 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1896				; 00000768H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1896]
	mov	ecx, 474				; 000001daH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4852 : 	stbi_uc palette[1024], pal_img_n = 0;

	mov	BYTE PTR _pal_img_n$[ebp], 0

; 4853 : 	stbi_uc has_trans = 0, tc[3] = { 0 };

	mov	BYTE PTR _has_trans$[ebp], 0
	xor	eax, eax
	mov	WORD PTR _tc$[ebp], ax
	mov	BYTE PTR _tc$[ebp+2], al

; 4854 : 	stbi__uint16 tc16[3];
; 4855 : 	stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;

	mov	DWORD PTR _ioff$[ebp], 0
	mov	DWORD PTR _idata_limit$[ebp], 0
	mov	DWORD PTR _pal_len$[ebp], 0

; 4856 : 	int first = 1, k, interlace = 0, color = 0, is_iphone = 0;

	mov	DWORD PTR _first$[ebp], 1
	mov	DWORD PTR _interlace$[ebp], 0
	mov	DWORD PTR _color$[ebp], 0
	mov	DWORD PTR _is_iphone$[ebp], 0

; 4857 : 	stbi__context* s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4858 : 
; 4859 : 	z->expanded = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4860 : 	z->idata = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4861 : 	z->out = NULL;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], 0

; 4862 : 
; 4863 : 	if (!stbi__check_png_header(s)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__check_png_header@@YAHPAUstbi__context@@@Z ; stbi__check_png_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN21@stbi__pars:

; 4864 : 
; 4865 : 	if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR _scan$[ebp], 1
	jne	SHORT $LN4@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN4@stbi__pars:

; 4866 : 
; 4867 : 	for (;;) {
; 4868 : 		stbi__pngchunk c = stbi__get_chunk_header(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PAUstbi__context@@@Z ; stbi__get_chunk_header
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _c$8[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _c$8[ebp+4], edx

; 4869 : 		switch (c.type) {

	mov	eax, DWORD PTR _c$8[ebp+4]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 1229472850		; 49484452H
	ja	SHORT $LN103@stbi__pars
	cmp	DWORD PTR tv77[ebp], 1229472850		; 49484452H
	je	SHORT $LN24@stbi__pars
	cmp	DWORD PTR tv77[ebp], 1130840649		; 43674249H
	je	SHORT $LN23@stbi__pars
	cmp	DWORD PTR tv77[ebp], 1229209940		; 49444154H
	je	$LN61@stbi__pars
	cmp	DWORD PTR tv77[ebp], 1229278788		; 49454e44H
	je	$LN70@stbi__pars
	jmp	$LN91@stbi__pars
$LN103@stbi__pars:
	cmp	DWORD PTR tv77[ebp], 1347179589		; 504c5445H
	je	$LN45@stbi__pars
	cmp	DWORD PTR tv77[ebp], 1951551059		; 74524e53H
	je	$LN49@stbi__pars
	jmp	$LN91@stbi__pars
$LN23@stbi__pars:

; 4870 : 		case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
; 4871 : 			is_iphone = 1;

	mov	DWORD PTR _is_iphone$[ebp], 1

; 4872 : 			stbi__skip(s, c.length);

	mov	eax, DWORD PTR _c$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 4873 : 			break;

	jmp	$LN5@stbi__pars
$LN24@stbi__pars:

; 4874 : 		case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
; 4875 : 			int comp, filter;
; 4876 : 			if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	jne	SHORT $LN25@stbi__pars
	push	OFFSET ??_C@_0O@KBHBNJOK@multiple?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN25@stbi__pars:

; 4877 : 			first = 0;

	mov	DWORD PTR _first$[ebp], 0

; 4878 : 			if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");

	cmp	DWORD PTR _c$8[ebp], 13			; 0000000dH
	je	SHORT $LN26@stbi__pars
	push	OFFSET ??_C@_0N@POJLKMKK@bad?5IHDR?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN26@stbi__pars:

; 4879 : 			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 16777216		; 01000000H
	jbe	SHORT $LN27@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN27@stbi__pars:

; 4880 : 			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 16777216		; 01000000H
	jbe	SHORT $LN28@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN28@stbi__pars:

; 4881 : 			z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only", "PNG not supported: 1/2/4/8/16-bit only");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 1
	je	SHORT $LN29@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 2
	je	SHORT $LN29@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 4
	je	SHORT $LN29@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 8
	je	SHORT $LN29@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	je	SHORT $LN29@stbi__pars
	push	OFFSET ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN29@stbi__pars:

; 4882 : 			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _color$[ebp], ecx
	cmp	DWORD PTR _color$[ebp], 6
	jle	SHORT $LN30@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN30@stbi__pars:

; 4883 : 			if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype", "Corrupt PNG");

	cmp	DWORD PTR _color$[ebp], 3
	jne	SHORT $LN31@stbi__pars
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN31@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN31@stbi__pars:

; 4884 : 			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");

	cmp	DWORD PTR _color$[ebp], 3
	jne	SHORT $LN32@stbi__pars
	mov	BYTE PTR _pal_img_n$[ebp], 3
	jmp	SHORT $LN33@stbi__pars
$LN32@stbi__pars:
	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 1
	je	SHORT $LN33@stbi__pars
	push	OFFSET ??_C@_09MBBNGCKB@bad?5ctype@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN33@stbi__pars:

; 4885 : 			comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _comp$7[ebp], ecx
	cmp	DWORD PTR _comp$7[ebp], 0
	je	SHORT $LN35@stbi__pars
	push	OFFSET ??_C@_0BA@MDMBDDFG@bad?5comp?5method@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN35@stbi__pars:

; 4886 : 			filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _filter$6[ebp], ecx
	cmp	DWORD PTR _filter$6[ebp], 0
	je	SHORT $LN36@stbi__pars
	push	OFFSET ??_C@_0BC@GHLIKKMD@bad?5filter?5method@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN36@stbi__pars:

; 4887 : 			interlace = stbi__get8(s); if (interlace > 1) return stbi__err("bad interlace method", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _interlace$[ebp], ecx
	cmp	DWORD PTR _interlace$[ebp], 1
	jle	SHORT $LN37@stbi__pars
	push	OFFSET ??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN37@stbi__pars:

; 4888 : 			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN39@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN38@stbi__pars
$LN39@stbi__pars:
	push	OFFSET ??_C@_0O@FNFBHCOO@0?9pixel?5image@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN38@stbi__pars:

; 4889 : 			if (!pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	jne	$LN40@stbi__pars

; 4890 : 				s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 2
	je	SHORT $LN95@stbi__pars
	mov	DWORD PTR tv193[ebp], 3
	jmp	SHORT $LN96@stbi__pars
$LN95@stbi__pars:
	mov	DWORD PTR tv193[ebp], 1
$LN96@stbi__pars:
	mov	ecx, DWORD PTR _color$[ebp]
	and	ecx, 4
	je	SHORT $LN97@stbi__pars
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $LN98@stbi__pars
$LN97@stbi__pars:
	mov	DWORD PTR tv196[ebp], 0
$LN98@stbi__pars:
	mov	edx, DWORD PTR tv193[ebp]
	add	edx, DWORD PTR tv196[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], edx

; 4891 : 				if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, 1073741824				; 40000000H
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN42@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN42@stbi__pars:

; 4892 : 				if (scan == STBI__SCAN_header) return 1;

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN43@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN43@stbi__pars:

; 4893 : 			}

	jmp	SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 4894 : 			else {
; 4895 : 				// if paletted, then pal_n is our final components, and
; 4896 : 				// img_n is # components to decompress/filter.
; 4897 : 				s->img_n = 1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], 1

; 4898 : 				if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");

	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, 1073741824				; 40000000H
	xor	edx, edx
	div	DWORD PTR [ecx]
	shr	eax, 2
	mov	edx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN41@stbi__pars
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN41@stbi__pars:

; 4899 : 				// if SCAN_header, have to scan to see if we have a tRNS
; 4900 : 			}
; 4901 : 			break;

	jmp	$LN5@stbi__pars
$LN45@stbi__pars:

; 4902 : 		}
; 4903 : 
; 4904 : 		case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {
; 4905 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN46@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN46@stbi__pars:

; 4906 : 			if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");

	cmp	DWORD PTR _c$8[ebp], 768		; 00000300H
	jbe	SHORT $LN47@stbi__pars
	push	OFFSET ??_C@_0N@JCPAJAKB@invalid?5PLTE@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN47@stbi__pars:

; 4907 : 			pal_len = c.length / 3;

	mov	eax, DWORD PTR _c$8[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR _pal_len$[ebp], eax

; 4908 : 			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");

	imul	eax, DWORD PTR _pal_len$[ebp], 3
	cmp	eax, DWORD PTR _c$8[ebp]
	je	SHORT $LN48@stbi__pars
	push	OFFSET ??_C@_0N@JCPAJAKB@invalid?5PLTE@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN48@stbi__pars:

; 4909 : 			for (i = 0; i < pal_len; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@stbi__pars
$LN7@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pal_len$[ebp]
	jae	SHORT $LN8@stbi__pars

; 4910 : 				palette[i * 4 + 0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4], al

; 4911 : 				palette[i * 4 + 1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+1], al

; 4912 : 				palette[i * 4 + 2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+2], al

; 4913 : 				palette[i * 4 + 3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+eax*4+3], 255	; 000000ffH

; 4914 : 			}

	jmp	$LN7@stbi__pars
$LN8@stbi__pars:

; 4915 : 			break;

	jmp	$LN5@stbi__pars
$LN49@stbi__pars:

; 4916 : 		}
; 4917 : 
; 4918 : 		case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
; 4919 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN50@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN50@stbi__pars:

; 4920 : 			if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN51@stbi__pars
	push	OFFSET ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN51@stbi__pars:

; 4921 : 			if (pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	$LN52@stbi__pars

; 4922 : 				if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN54@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], 4
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN54@stbi__pars:

; 4923 : 				if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");

	cmp	DWORD PTR _pal_len$[ebp], 0
	jne	SHORT $LN55@stbi__pars
	push	OFFSET ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN55@stbi__pars:

; 4924 : 				if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");

	mov	eax, DWORD PTR _c$8[ebp]
	cmp	eax, DWORD PTR _pal_len$[ebp]
	jbe	SHORT $LN56@stbi__pars
	push	OFFSET ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN56@stbi__pars:

; 4925 : 				pal_img_n = 4;

	mov	BYTE PTR _pal_img_n$[ebp], 4

; 4926 : 				for (i = 0; i < c.length; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@stbi__pars
$LN10@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@stbi__pars:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$8[ebp]
	jae	SHORT $LN11@stbi__pars

; 4927 : 					palette[i * 4 + 3] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _palette$[ebp+ecx*4+3], al
	jmp	SHORT $LN10@stbi__pars
$LN11@stbi__pars:

; 4928 : 			}

	jmp	$LN53@stbi__pars
$LN52@stbi__pars:

; 4929 : 			else {
; 4930 : 				if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	jne	SHORT $LN57@stbi__pars
	push	OFFSET ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN57@stbi__pars:

; 4931 : 				if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	cmp	DWORD PTR _c$8[ebp], ecx
	je	SHORT $LN58@stbi__pars
	push	OFFSET ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN58@stbi__pars:

; 4932 : 				has_trans = 1;

	mov	BYTE PTR _has_trans$[ebp], 1

; 4933 : 				if (z->depth == 16) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN59@stbi__pars

; 4934 : 					for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN15@stbi__pars
$LN13@stbi__pars:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN15@stbi__pars:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN14@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _k$[ebp]
	mov	WORD PTR _tc16$[ebp+ecx*2], ax
	jmp	SHORT $LN13@stbi__pars
$LN14@stbi__pars:

; 4935 : 				}

	jmp	SHORT $LN53@stbi__pars
$LN59@stbi__pars:

; 4936 : 				else {
; 4937 : 					for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN18@stbi__pars
$LN16@stbi__pars:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN18@stbi__pars:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN53@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR ?stbi__depth_scale_table@@3QBEB[eax]
	imul	ecx, edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR _tc$[ebp+eax], cl
	jmp	SHORT $LN16@stbi__pars
$LN53@stbi__pars:

; 4938 : 				}
; 4939 : 			}
; 4940 : 			break;

	jmp	$LN5@stbi__pars
$LN61@stbi__pars:

; 4941 : 		}
; 4942 : 
; 4943 : 		case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
; 4944 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN62@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN62@stbi__pars:

; 4945 : 			if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN63@stbi__pars
	cmp	DWORD PTR _pal_len$[ebp], 0
	jne	SHORT $LN63@stbi__pars
	push	OFFSET ??_C@_07CKIELOEH@no?5PLTE@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN63@stbi__pars:

; 4946 : 			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }

	cmp	DWORD PTR _scan$[ebp], 2
	jne	SHORT $LN64@stbi__pars
	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN64@stbi__pars:

; 4947 : 			if ((int)(ioff + c.length) < (int)ioff) return 0;

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$8[ebp]
	cmp	eax, DWORD PTR _ioff$[ebp]
	jge	SHORT $LN65@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN65@stbi__pars:

; 4948 : 			if (ioff + c.length > idata_limit) {

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$8[ebp]
	cmp	eax, DWORD PTR _idata_limit$[ebp]
	jbe	$LN66@stbi__pars

; 4949 : 				stbi__uint32 idata_limit_old = idata_limit;

	mov	eax, DWORD PTR _idata_limit$[ebp]
	mov	DWORD PTR _idata_limit_old$5[ebp], eax

; 4950 : 				stbi_uc* p;
; 4951 : 				if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

	cmp	DWORD PTR _idata_limit$[ebp], 0
	jne	SHORT $LN19@stbi__pars
	cmp	DWORD PTR _c$8[ebp], 4096		; 00001000H
	jbe	SHORT $LN99@stbi__pars
	mov	eax, DWORD PTR _c$8[ebp]
	mov	DWORD PTR tv328[ebp], eax
	jmp	SHORT $LN100@stbi__pars
$LN99@stbi__pars:
	mov	DWORD PTR tv328[ebp], 4096		; 00001000H
$LN100@stbi__pars:
	mov	ecx, DWORD PTR tv328[ebp]
	mov	DWORD PTR _idata_limit$[ebp], ecx
$LN19@stbi__pars:

; 4952 : 				while (ioff + c.length > idata_limit)

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$8[ebp]
	cmp	eax, DWORD PTR _idata_limit$[ebp]
	jbe	SHORT $LN20@stbi__pars

; 4953 : 					idata_limit *= 2;

	mov	eax, DWORD PTR _idata_limit$[ebp]
	shl	eax, 1
	mov	DWORD PTR _idata_limit$[ebp], eax
	jmp	SHORT $LN19@stbi__pars
$LN20@stbi__pars:

; 4954 : 				STBI_NOTUSED(idata_limit_old);
; 4955 : 				p = (stbi_uc*)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

	mov	esi, esp
	mov	eax, DWORD PTR _idata_limit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _p$4[ebp], eax
	cmp	DWORD PTR _p$4[ebp], 0
	jne	SHORT $LN68@stbi__pars
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN68@stbi__pars:

; 4956 : 				z->idata = p;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _p$4[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN66@stbi__pars:

; 4957 : 			}
; 4958 : 			if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");

	mov	eax, DWORD PTR _c$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _ioff$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ; stbi__getn
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN69@stbi__pars
	push	OFFSET ??_C@_09MNNCNKEO@outofdata@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN69@stbi__pars:

; 4959 : 			ioff += c.length;

	mov	eax, DWORD PTR _ioff$[ebp]
	add	eax, DWORD PTR _c$8[ebp]
	mov	DWORD PTR _ioff$[ebp], eax

; 4960 : 			break;

	jmp	$LN5@stbi__pars
$LN70@stbi__pars:

; 4961 : 		}
; 4962 : 
; 4963 : 		case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
; 4964 : 			stbi__uint32 raw_len, bpl;
; 4965 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN71@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN71@stbi__pars:

; 4966 : 			if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR _scan$[ebp], 0
	je	SHORT $LN72@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN72@stbi__pars:

; 4967 : 			if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN73@stbi__pars
	push	OFFSET ??_C@_07MLPECBNA@no?5IDAT@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN73@stbi__pars:

; 4968 : 			// initial guess for decoded data size to avoid unnecessary reallocs
; 4969 : 			bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+16]
	add	edx, 7
	shr	edx, 3
	mov	DWORD PTR _bpl$2[ebp], edx

; 4970 : 			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _bpl$2[ebp]
	imul	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _raw_len$3[ebp], ecx

; 4971 : 			z->expanded = (stbi_uc*)stbi_zlib_decode_malloc_guesssize_headerflag((char*)z->idata, ioff, raw_len, (int*)& raw_len, !is_iphone);

	cmp	DWORD PTR _is_iphone$[ebp], 0
	jne	SHORT $LN101@stbi__pars
	mov	DWORD PTR tv375[ebp], 1
	jmp	SHORT $LN102@stbi__pars
$LN101@stbi__pars:
	mov	DWORD PTR tv375[ebp], 0
$LN102@stbi__pars:
	mov	eax, DWORD PTR tv375[ebp]
	push	eax
	lea	ecx, DWORD PTR _raw_len$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _raw_len$3[ebp]
	push	edx
	mov	eax, DWORD PTR _ioff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_stbi_zlib_decode_malloc_guesssize_headerflag
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 4972 : 			if (z->expanded == NULL) return 0; // zlib should set error

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN74@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN74@stbi__pars:

; 4973 : 			STBI_FREE(z->idata); z->idata = NULL;

	mov	esi, esp
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4974 : 			if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	cmp	DWORD PTR _req_comp$[ebp], ecx
	jne	SHORT $LN78@stbi__pars
	cmp	DWORD PTR _req_comp$[ebp], 3
	je	SHORT $LN78@stbi__pars
	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN77@stbi__pars
$LN78@stbi__pars:
	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN75@stbi__pars
$LN77@stbi__pars:

; 4975 : 				s->img_out_n = s->img_n + 1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN76@stbi__pars
$LN75@stbi__pars:

; 4976 : 			else
; 4977 : 				s->img_out_n = s->img_n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx
$LN76@stbi__pars:

; 4978 : 			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

	mov	eax, DWORD PTR _interlace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _raw_len$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__create_png_image@@YAHPAUstbi__png@@PAEIHHHH@Z ; stbi__create_png_image
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN79@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN79@stbi__pars:

; 4979 : 			if (has_trans) {

	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN80@stbi__pars

; 4980 : 				if (z->depth == 16) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+16], 16			; 00000010H
	jne	SHORT $LN81@stbi__pars

; 4981 : 					if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _tc16$[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z ; stbi__compute_transparency16
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN83@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN83@stbi__pars:

; 4982 : 				}

	jmp	SHORT $LN80@stbi__pars
$LN81@stbi__pars:

; 4983 : 				else {
; 4984 : 					if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _tc$[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z ; stbi__compute_transparency
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN80@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN80@stbi__pars:

; 4985 : 				}
; 4986 : 			}
; 4987 : 			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

	cmp	DWORD PTR _is_iphone$[ebp], 0
	je	SHORT $LN85@stbi__pars
	cmp	DWORD PTR ?stbi__de_iphone_flag@@3HA, 0
	je	SHORT $LN85@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jle	SHORT $LN85@stbi__pars

; 4988 : 				stbi__de_iphone(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__de_iphone@@YAXPAUstbi__png@@@Z	; stbi__de_iphone
	add	esp, 4
$LN85@stbi__pars:

; 4989 : 			if (pal_img_n) {

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	test	eax, eax
	je	SHORT $LN86@stbi__pars

; 4990 : 				// pal_img_n == 3 or 4
; 4991 : 				s->img_n = pal_img_n; // record the actual colors we had

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 4992 : 				s->img_out_n = pal_img_n;

	movzx	eax, BYTE PTR _pal_img_n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4993 : 				if (req_comp >= 3) s->img_out_n = req_comp;

	cmp	DWORD PTR _req_comp$[ebp], 3
	jl	SHORT $LN88@stbi__pars
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN88@stbi__pars:

; 4994 : 				if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pal_len$[ebp]
	push	edx
	lea	eax, DWORD PTR _palette$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	?stbi__expand_png_palette@@YAHPAUstbi__png@@PAEHH@Z ; stbi__expand_png_palette
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN89@stbi__pars

; 4995 : 					return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN89@stbi__pars:

; 4996 : 			}

	jmp	SHORT $LN87@stbi__pars
$LN86@stbi__pars:

; 4997 : 			else if (has_trans) {

	movzx	eax, BYTE PTR _has_trans$[ebp]
	test	eax, eax
	je	SHORT $LN87@stbi__pars

; 4998 : 				// non-paletted image with tRNS -> source image has (constant) alpha
; 4999 : 				++s->img_n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN87@stbi__pars:

; 5000 : 			}
; 5001 : 			STBI_FREE(z->expanded); z->expanded = NULL;

	mov	esi, esp
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+8], 0

; 5002 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN91@stbi__pars:

; 5003 : 		}
; 5004 : 
; 5005 : 		default:
; 5006 : 			// if critical, fail
; 5007 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN92@stbi__pars
	push	OFFSET ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN92@stbi__pars:

; 5008 : 			if ((c.type & (1 << 29)) == 0) {

	mov	eax, DWORD PTR _c$8[ebp+4]
	and	eax, 536870912				; 20000000H
	jne	SHORT $LN93@stbi__pars

; 5009 : #ifndef STBI_NO_FAILURE_STRINGS
; 5010 : 				// not threadsafe
; 5011 : 				static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5012 : 				invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

	mov	eax, DWORD PTR _c$8[ebp+4]
	shr	eax, 24					; 00000018H
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA[edx], al

; 5013 : 				invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

	mov	eax, DWORD PTR _c$8[ebp+4]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA[ecx], al

; 5014 : 				invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);

	mov	eax, DWORD PTR _c$8[ebp+4]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA[ecx], al

; 5015 : 				invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);

	mov	eax, DWORD PTR _c$8[ebp+4]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA[edx], al

; 5016 : #endif
; 5017 : 				return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

	push	OFFSET ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z@4PADA
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pars
$LN93@stbi__pars:

; 5018 : 			}
; 5019 : 			stbi__skip(s, c.length);

	mov	eax, DWORD PTR _c$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8
$LN5@stbi__pars:

; 5020 : 			break;
; 5021 : 		}
; 5022 : 		// end of PNG chunk, read and skip CRC
; 5023 : 		stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4

; 5024 : 	}

	jmp	$LN4@stbi__pars
$LN1@stbi__pars:

; 5025 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN110@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1896				; 00000768H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN110@stbi__pars:
	DD	5
	DD	$LN109@stbi__pars
$LN109@stbi__pars:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN104@stbi__pars
	DD	-1068					; fffffbd4H
	DD	3
	DD	$LN105@stbi__pars
	DD	-1084					; fffffbc4H
	DD	6
	DD	$LN106@stbi__pars
	DD	-1220					; fffffb3cH
	DD	8
	DD	$LN107@stbi__pars
	DD	-1280					; fffffb00H
	DD	4
	DD	$LN108@stbi__pars
$LN108@stbi__pars:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN107@stbi__pars:
	DB	99					; 00000063H
	DB	0
$LN106@stbi__pars:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN105@stbi__pars:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	0
$LN104@stbi__pars:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
?stbi__parse_png_file@@YAHPAUstbi__png@@HH@Z ENDP	; stbi__parse_png_file
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__de_iphone@@YAXPAUstbi__png@@@Z
_TEXT	SEGMENT
_t$1 = -101						; size = 1
_half$2 = -89						; size = 1
_t$3 = -77						; size = 1
_a$4 = -65						; size = 1
_t$5 = -53						; size = 1
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
?stbi__de_iphone@@YAXPAUstbi__png@@@Z PROC		; stbi__de_iphone, COMDAT

; 4803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4804 : 	stbi__context* s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4805 : 	stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4806 : 	stbi_uc* p = z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4807 : 
; 4808 : 	if (s->img_out_n == 3) {  // convert bgr to rgb

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 3
	jne	SHORT $LN11@stbi__de_i

; 4809 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN3@stbi__de_i

; 4810 : 			stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$5[ebp], al

; 4811 : 			p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4812 : 			p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$5[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4813 : 			p += 3;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 4814 : 		}

	jmp	SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 4815 : 	}

	jmp	$LN1@stbi__de_i
$LN11@stbi__de_i:

; 4816 : 	else {
; 4817 : 		STBI_ASSERT(s->img_out_n == 4);

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+12], 4
	je	SHORT $LN18@stbi__de_i
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__de_iphone@@YAXPAUstbi__png@@@Z@4JA
	add	ecx, 14					; 0000000eH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@stbi__de_i:

; 4818 : 		if (stbi__unpremultiply_on_load) {

	cmp	DWORD PTR ?stbi__unpremultiply_on_load@@3HA, 0
	je	$LN13@stbi__de_i

; 4819 : 			// convert bgr to rgb and unpremultiply
; 4820 : 			for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN6@stbi__de_i

; 4821 : 				stbi_uc a = p[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _a$4[ebp], al

; 4822 : 				stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$3[ebp], al

; 4823 : 				if (a) {

	movzx	eax, BYTE PTR _a$4[ebp]
	test	eax, eax
	je	$LN15@stbi__de_i

; 4824 : 					stbi_uc half = a / 2;

	movzx	eax, BYTE PTR _a$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _half$2[ebp], al

; 4825 : 					p[0] = (p[2] * 255 + half) / a;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 4826 : 					p[1] = (p[1] * 255 + half) / a;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, edx, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 4827 : 					p[2] = (t * 255 + half) / a;

	movzx	eax, BYTE PTR _t$3[ebp]
	imul	eax, eax, 255
	movzx	ecx, BYTE PTR _half$2[ebp]
	add	eax, ecx
	movzx	ecx, BYTE PTR _a$4[ebp]
	cdq
	idiv	ecx
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 4828 : 				}

	jmp	SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 4829 : 				else {
; 4830 : 					p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4831 : 					p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$3[ebp]
	mov	BYTE PTR [ecx+eax], dl
$LN16@stbi__de_i:

; 4832 : 				}
; 4833 : 				p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4834 : 			}

	jmp	$LN5@stbi__de_i
$LN6@stbi__de_i:

; 4835 : 		}

	jmp	SHORT $LN1@stbi__de_i
$LN13@stbi__de_i:

; 4836 : 		else {
; 4837 : 			// convert bgr to rgb
; 4838 : 			for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__de_i:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN1@stbi__de_i

; 4839 : 				stbi_uc t = p[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _t$1[ebp], al

; 4840 : 				p[0] = p[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 4841 : 				p[2] = t;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR _t$1[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4842 : 				p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4843 : 			}

	jmp	SHORT $LN8@stbi__de_i
$LN1@stbi__de_i:

; 4844 : 		}
; 4845 : 	}
; 4846 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__de_iphone@@YAXPAUstbi__png@@@Z ENDP		; stbi__de_iphone
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__expand_png_palette@@YAHPAUstbi__png@@PAEHH@Z
_TEXT	SEGMENT
_n$1 = -80						; size = 4
_n$2 = -68						; size = 4
_orig$ = -56						; size = 4
_temp_out$ = -44					; size = 4
_p$ = -32						; size = 4
_pixel_count$ = -20					; size = 4
_i$ = -8						; size = 4
_a$ = 8							; size = 4
_palette$ = 12						; size = 4
_len$ = 16						; size = 4
_pal_img_n$ = 20					; size = 4
?stbi__expand_png_palette@@YAHPAUstbi__png@@PAEHH@Z PROC ; stbi__expand_png_palette, COMDAT

; 4752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4753 : 	stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pixel_count$[ebp], ecx

; 4754 : 	stbi_uc* p, * temp_out, * orig = a->out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _orig$[ebp], ecx

; 4755 : 
; 4756 : 	p = (stbi_uc*)stbi__malloc_mad2(pixel_count, pal_img_n, 0);

	push	0
	mov	eax, DWORD PTR _pal_img_n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pixel_count$[ebp]
	push	ecx
	call	?stbi__malloc_mad2@@YAPAXHHH@Z		; stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], eax

; 4757 : 	if (p == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN8@stbi__expa
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__expa
$LN8@stbi__expa:

; 4758 : 
; 4759 : 	// between here and free(out) below, exitting would leak
; 4760 : 	temp_out = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _temp_out$[ebp], eax

; 4761 : 
; 4762 : 	if (pal_img_n == 3) {

	cmp	DWORD PTR _pal_img_n$[ebp], 3
	jne	SHORT $LN9@stbi__expa

; 4763 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__expa
$LN2@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN3@stbi__expa

; 4764 : 			int n = orig[i] * 4;

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 2
	mov	DWORD PTR _n$2[ebp], ecx

; 4765 : 			p[0] = palette[n];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$2[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 4766 : 			p[1] = palette[n + 1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$2[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx+eax], cl

; 4767 : 			p[2] = palette[n + 2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$2[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+eax], cl

; 4768 : 			p += 3;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 4769 : 		}

	jmp	SHORT $LN2@stbi__expa
$LN3@stbi__expa:

; 4770 : 	}

	jmp	$LN10@stbi__expa
$LN9@stbi__expa:

; 4771 : 	else {
; 4772 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__expa
$LN5@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__expa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN10@stbi__expa

; 4773 : 			int n = orig[i] * 4;

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 2
	mov	DWORD PTR _n$1[ebp], ecx

; 4774 : 			p[0] = palette[n];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$1[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 4775 : 			p[1] = palette[n + 1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$1[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx+eax], cl

; 4776 : 			p[2] = palette[n + 2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _palette$[ebp]
	add	ecx, DWORD PTR _n$1[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+eax], cl

; 4777 : 			p[3] = palette[n + 3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _palette$[ebp]
	add	edx, DWORD PTR _n$1[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [edx+3]
	mov	BYTE PTR [eax+ecx], dl

; 4778 : 			p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4779 : 		}

	jmp	$LN5@stbi__expa
$LN10@stbi__expa:

; 4780 : 	}
; 4781 : 	STBI_FREE(a->out);

	mov	esi, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4782 : 	a->out = temp_out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _temp_out$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4783 : 
; 4784 : 	STBI_NOTUSED(len);
; 4785 : 
; 4786 : 	return 1;

	mov	eax, 1
$LN1@stbi__expa:

; 4787 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__expand_png_palette@@YAHPAUstbi__png@@PAEHH@Z ENDP ; stbi__expand_png_palette
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z
_TEXT	SEGMENT
tv88 = -244						; size = 4
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_tc$ = 12						; size = 4
_out_n$ = 16						; size = 4
?stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z PROC ; stbi__compute_transparency16, COMDAT

; 4726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4727 : 	stbi__context* s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4728 : 	stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4729 : 	stbi__uint16* p = (stbi__uint16*)z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4730 : 
; 4731 : 	// compute color-based transparency, assuming we've
; 4732 : 	// already got 65535 as the alpha value in the output
; 4733 : 	STBI_ASSERT(out_n == 2 || out_n == 4);

	cmp	DWORD PTR _out_n$[ebp], 2
	je	SHORT $LN12@stbi__comp
	cmp	DWORD PTR _out_n$[ebp], 4
	je	SHORT $LN12@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z@4JA
	add	eax, 7
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@stbi__comp:

; 4734 : 
; 4735 : 	if (out_n == 2) {

	cmp	DWORD PTR _out_n$[ebp], 2
	jne	SHORT $LN8@stbi__comp

; 4736 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__comp
$LN2@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN3@stbi__comp

; 4737 : 			p[1] = (p[0] == tc[0] ? 0 : 65535);

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, WORD PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN13@stbi__comp
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN14@stbi__comp
$LN13@stbi__comp:
	mov	DWORD PTR tv88[ebp], 65535		; 0000ffffH
$LN14@stbi__comp:
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dx, WORD PTR tv88[ebp]
	mov	WORD PTR [ecx+eax], dx

; 4738 : 			p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4739 : 		}

	jmp	SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4740 : 	}

	jmp	$LN9@stbi__comp
$LN8@stbi__comp:

; 4741 : 	else {
; 4742 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__comp
$LN5@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN9@stbi__comp

; 4743 : 			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, WORD PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN10@stbi__comp
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, WORD PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN10@stbi__comp
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, WORD PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN10@stbi__comp

; 4744 : 				p[3] = 0;

	mov	eax, 2
	imul	ecx, eax, 3
	xor	edx, edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	WORD PTR [eax+ecx], dx
$LN10@stbi__comp:

; 4745 : 			p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
	mov	DWORD PTR _p$[ebp], eax

; 4746 : 		}

	jmp	$LN5@stbi__comp
$LN9@stbi__comp:

; 4747 : 	}
; 4748 : 	return 1;

	mov	eax, 1

; 4749 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__compute_transparency16@@YAHPAUstbi__png@@QAGH@Z ENDP ; stbi__compute_transparency16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z
_TEXT	SEGMENT
tv88 = -244						; size = 4
_p$ = -44						; size = 4
_pixel_count$ = -32					; size = 4
_i$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_tc$ = 12						; size = 4
_out_n$ = 16						; size = 4
?stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z PROC ; stbi__compute_transparency, COMDAT

; 4700 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4701 : 	stbi__context* s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4702 : 	stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pixel_count$[ebp], edx

; 4703 : 	stbi_uc* p = z->out;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _p$[ebp], ecx

; 4704 : 
; 4705 : 	// compute color-based transparency, assuming we've
; 4706 : 	// already got 255 as the alpha value in the output
; 4707 : 	STBI_ASSERT(out_n == 2 || out_n == 4);

	cmp	DWORD PTR _out_n$[ebp], 2
	je	SHORT $LN12@stbi__comp
	cmp	DWORD PTR _out_n$[ebp], 4
	je	SHORT $LN12@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z@4JA
	add	eax, 7
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@stbi__comp:

; 4708 : 
; 4709 : 	if (out_n == 2) {

	cmp	DWORD PTR _out_n$[ebp], 2
	jne	SHORT $LN8@stbi__comp

; 4710 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__comp
$LN2@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	SHORT $LN3@stbi__comp

; 4711 : 			p[1] = (p[0] == tc[0] ? 0 : 255);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN13@stbi__comp
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN14@stbi__comp
$LN13@stbi__comp:
	mov	DWORD PTR tv88[ebp], 255		; 000000ffH
$LN14@stbi__comp:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR tv88[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 4712 : 			p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 4713 : 		}

	jmp	SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4714 : 	}

	jmp	$LN9@stbi__comp
$LN8@stbi__comp:

; 4715 : 	else {
; 4716 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__comp
$LN5@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixel_count$[ebp]
	jae	$LN9@stbi__comp

; 4717 : 			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	jne	SHORT $LN10@stbi__comp
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN10@stbi__comp
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tc$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	jne	SHORT $LN10@stbi__comp

; 4718 : 				p[3] = 0;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN10@stbi__comp:

; 4719 : 			p += 4;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 4720 : 		}

	jmp	$LN5@stbi__comp
$LN9@stbi__comp:

; 4721 : 	}
; 4722 : 	return 1;

	mov	eax, 1

; 4723 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__compute_transparency@@YAHPAUstbi__png@@QAEH@Z ENDP ; stbi__compute_transparency
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__create_png_image@@YAHPAUstbi__png@@PAEIHHHH@Z
_TEXT	SEGMENT
tv65 = -472						; size = 4
_out_x$1 = -272						; size = 4
_out_y$2 = -260						; size = 4
_img_len$3 = -248					; size = 4
_y$4 = -236						; size = 4
_x$5 = -224						; size = 4
_j$6 = -212						; size = 4
_i$7 = -200						; size = 4
_yspc$8 = -188						; size = 28
_xspc$9 = -152						; size = 28
_yorig$10 = -116					; size = 28
_xorig$11 = -80						; size = 28
_p$ = -44						; size = 4
_final$ = -32						; size = 4
_out_bytes$ = -20					; size = 4
_bytes$ = -8						; size = 4
_a$ = 8							; size = 4
_image_data$ = 12					; size = 4
_image_data_len$ = 16					; size = 4
_out_n$ = 20						; size = 4
_depth$ = 24						; size = 4
_color$ = 28						; size = 4
_interlaced$ = 32					; size = 4
?stbi__create_png_image@@YAHPAUstbi__png@@PAEIHHHH@Z PROC ; stbi__create_png_image, COMDAT

; 4656 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 472				; 000001d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-472]
	mov	ecx, 118				; 00000076H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4657 : 	int bytes = (depth == 16 ? 2 : 1);

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN15@stbi__crea
	mov	DWORD PTR tv65[ebp], 2
	jmp	SHORT $LN16@stbi__crea
$LN15@stbi__crea:
	mov	DWORD PTR tv65[ebp], 1
$LN16@stbi__crea:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 4658 : 	int out_bytes = out_n * bytes;

	mov	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _out_bytes$[ebp], eax

; 4659 : 	stbi_uc* final;
; 4660 : 	int p;
; 4661 : 	if (!interlaced)

	cmp	DWORD PTR _interlaced$[ebp], 0
	jne	SHORT $LN11@stbi__crea

; 4662 : 		return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _out_n$[ebp]
	push	edx
	mov	eax, DWORD PTR _image_data_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image_data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z ; stbi__create_png_image_raw
	add	esp, 32					; 00000020H
	jmp	$LN1@stbi__crea
$LN11@stbi__crea:

; 4663 : 
; 4664 : 	// de-interlacing
; 4665 : 	final = (stbi_uc*)stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

	push	0
	mov	eax, DWORD PTR _out_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _final$[ebp], eax

; 4666 : 	for (p = 0; p < 7; ++p) {

	mov	DWORD PTR _p$[ebp], 0
	jmp	SHORT $LN4@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN4@stbi__crea:
	cmp	DWORD PTR _p$[ebp], 7
	jge	$LN3@stbi__crea

; 4667 : 		int xorig[] = { 0,4,0,2,0,1,0 };

	mov	DWORD PTR _xorig$11[ebp], 0
	mov	DWORD PTR _xorig$11[ebp+4], 4
	mov	DWORD PTR _xorig$11[ebp+8], 0
	mov	DWORD PTR _xorig$11[ebp+12], 2
	mov	DWORD PTR _xorig$11[ebp+16], 0
	mov	DWORD PTR _xorig$11[ebp+20], 1
	mov	DWORD PTR _xorig$11[ebp+24], 0

; 4668 : 		int yorig[] = { 0,0,4,0,2,0,1 };

	mov	DWORD PTR _yorig$10[ebp], 0
	mov	DWORD PTR _yorig$10[ebp+4], 0
	mov	DWORD PTR _yorig$10[ebp+8], 4
	mov	DWORD PTR _yorig$10[ebp+12], 0
	mov	DWORD PTR _yorig$10[ebp+16], 2
	mov	DWORD PTR _yorig$10[ebp+20], 0
	mov	DWORD PTR _yorig$10[ebp+24], 1

; 4669 : 		int xspc[] = { 8,8,4,4,2,2,1 };

	mov	DWORD PTR _xspc$9[ebp], 8
	mov	DWORD PTR _xspc$9[ebp+4], 8
	mov	DWORD PTR _xspc$9[ebp+8], 4
	mov	DWORD PTR _xspc$9[ebp+12], 4
	mov	DWORD PTR _xspc$9[ebp+16], 2
	mov	DWORD PTR _xspc$9[ebp+20], 2
	mov	DWORD PTR _xspc$9[ebp+24], 1

; 4670 : 		int yspc[] = { 8,8,8,4,4,2,2 };

	mov	DWORD PTR _yspc$8[ebp], 8
	mov	DWORD PTR _yspc$8[ebp+4], 8
	mov	DWORD PTR _yspc$8[ebp+8], 8
	mov	DWORD PTR _yspc$8[ebp+12], 4
	mov	DWORD PTR _yspc$8[ebp+16], 4
	mov	DWORD PTR _yspc$8[ebp+20], 2
	mov	DWORD PTR _yspc$8[ebp+24], 2

; 4671 : 		int i, j, x, y;
; 4672 : 		// pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4673 : 		x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR _xorig$11[ebp+edx*4]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _xspc$9[ebp+ecx*4]
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, DWORD PTR _p$[ebp]
	xor	edx, edx
	div	DWORD PTR _xspc$9[ebp+ecx*4]
	mov	DWORD PTR _x$5[ebp], eax

; 4674 : 		y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR _yorig$10[ebp+edx*4]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _yspc$8[ebp+ecx*4]
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, DWORD PTR _p$[ebp]
	xor	edx, edx
	div	DWORD PTR _yspc$8[ebp+ecx*4]
	mov	DWORD PTR _y$4[ebp], eax

; 4675 : 		if (x && y) {

	cmp	DWORD PTR _x$5[ebp], 0
	je	$LN12@stbi__crea
	cmp	DWORD PTR _y$4[ebp], 0
	je	$LN12@stbi__crea

; 4676 : 			stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, DWORD PTR _x$5[ebp]
	imul	edx, DWORD PTR _depth$[ebp]
	add	edx, 7
	sar	edx, 3
	add	edx, 1
	imul	edx, DWORD PTR _y$4[ebp]
	mov	DWORD PTR _img_len$3[ebp], edx

; 4677 : 			if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$4[ebp]
	push	edx
	mov	eax, DWORD PTR _x$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image_data_len$[ebp]
	push	edx
	mov	eax, DWORD PTR _image_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z ; stbi__create_png_image_raw
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN13@stbi__crea

; 4678 : 				STBI_FREE(final);

	mov	esi, esp
	mov	eax, DWORD PTR _final$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4679 : 				return 0;

	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN13@stbi__crea:

; 4680 : 			}
; 4681 : 			for (j = 0; j < y; ++j) {

	mov	DWORD PTR _j$6[ebp], 0
	jmp	SHORT $LN7@stbi__crea
$LN5@stbi__crea:
	mov	eax, DWORD PTR _j$6[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
$LN7@stbi__crea:
	mov	eax, DWORD PTR _j$6[ebp]
	cmp	eax, DWORD PTR _y$4[ebp]
	jge	$LN6@stbi__crea

; 4682 : 				for (i = 0; i < x; ++i) {

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN10@stbi__crea
$LN8@stbi__crea:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN10@stbi__crea:
	mov	eax, DWORD PTR _i$7[ebp]
	cmp	eax, DWORD PTR _x$5[ebp]
	jge	$LN9@stbi__crea

; 4683 : 					int out_y = j * yspc[p] + yorig[p];

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _j$6[ebp]
	imul	ecx, DWORD PTR _yspc$8[ebp+eax*4]
	mov	edx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _yorig$10[ebp+edx*4]
	mov	DWORD PTR _out_y$2[ebp], ecx

; 4684 : 					int out_x = i * xspc[p] + xorig[p];

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _i$7[ebp]
	imul	ecx, DWORD PTR _xspc$9[ebp+eax*4]
	mov	edx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _xorig$11[ebp+edx*4]
	mov	DWORD PTR _out_x$1[ebp], ecx

; 4685 : 					memcpy(final + out_y * a->s->img_x * out_bytes + out_x * out_bytes,

	mov	eax, DWORD PTR _out_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$6[ebp]
	imul	ecx, DWORD PTR _x$5[ebp]
	add	ecx, DWORD PTR _i$7[ebp]
	imul	ecx, DWORD PTR _out_bytes$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	add	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_y$2[ebp]
	imul	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _out_bytes$[ebp]
	add	edx, DWORD PTR _final$[ebp]
	mov	eax, DWORD PTR _out_x$1[ebp]
	imul	eax, DWORD PTR _out_bytes$[ebp]
	add	edx, eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4686 : 						a->out + (j * x + i) * out_bytes, out_bytes);
; 4687 : 				}

	jmp	$LN8@stbi__crea
$LN9@stbi__crea:

; 4688 : 			}

	jmp	$LN5@stbi__crea
$LN6@stbi__crea:

; 4689 : 			STBI_FREE(a->out);

	mov	esi, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4690 : 			image_data += img_len;

	mov	eax, DWORD PTR _image_data$[ebp]
	add	eax, DWORD PTR _img_len$3[ebp]
	mov	DWORD PTR _image_data$[ebp], eax

; 4691 : 			image_data_len -= img_len;

	mov	eax, DWORD PTR _image_data_len$[ebp]
	sub	eax, DWORD PTR _img_len$3[ebp]
	mov	DWORD PTR _image_data_len$[ebp], eax
$LN12@stbi__crea:

; 4692 : 		}
; 4693 : 	}

	jmp	$LN2@stbi__crea
$LN3@stbi__crea:

; 4694 : 	a->out = final;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _final$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4695 : 
; 4696 : 	return 1;

	mov	eax, 1
$LN1@stbi__crea:

; 4697 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@stbi__crea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 472				; 000001d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@stbi__crea:
	DD	4
	DD	$LN21@stbi__crea
$LN21@stbi__crea:
	DD	-80					; ffffffb0H
	DD	28					; 0000001cH
	DD	$LN17@stbi__crea
	DD	-116					; ffffff8cH
	DD	28					; 0000001cH
	DD	$LN18@stbi__crea
	DD	-152					; ffffff68H
	DD	28					; 0000001cH
	DD	$LN19@stbi__crea
	DD	-188					; ffffff44H
	DD	28					; 0000001cH
	DD	$LN20@stbi__crea
$LN20@stbi__crea:
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	0
$LN19@stbi__crea:
	DB	120					; 00000078H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	0
$LN18@stbi__crea:
	DB	121					; 00000079H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN17@stbi__crea:
	DB	120					; 00000078H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
?stbi__create_png_image@@YAHPAUstbi__png@@PAEIHHHH@Z ENDP ; stbi__create_png_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z
_TEXT	SEGMENT
tv559 = -460						; size = 4
tv365 = -460						; size = 4
tv248 = -460						; size = 4
tv168 = -460						; size = 4
tv65 = -460						; size = 4
_cur16$1 = -260						; size = 4
_cur$2 = -248						; size = 4
_q$3 = -236						; size = 4
_scale$4 = -221						; size = 1
_in$5 = -212						; size = 4
_cur$6 = -200						; size = 4
_nk$7 = -188						; size = 4
_filter$8 = -176					; size = 4
_prior$9 = -164						; size = 4
_cur$10 = -152						; size = 4
_width$ = -140						; size = 4
_filter_bytes$ = -128					; size = 4
_output_bytes$ = -116					; size = 4
_img_n$ = -104						; size = 4
_k$ = -92						; size = 4
_img_width_bytes$ = -80					; size = 4
_img_len$ = -68						; size = 4
_stride$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_s$ = -20						; size = 4
_bytes$ = -8						; size = 4
_a$ = 8							; size = 4
_raw$ = 12						; size = 4
_raw_len$ = 16						; size = 4
_out_n$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
_depth$ = 32						; size = 4
_color$ = 36						; size = 4
?stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z PROC ; stbi__create_png_image_raw, COMDAT

; 4437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4438 : 	int bytes = (depth == 16 ? 2 : 1);

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN158@stbi__crea
	mov	DWORD PTR tv65[ebp], 2
	jmp	SHORT $LN159@stbi__crea
$LN158@stbi__crea:
	mov	DWORD PTR tv65[ebp], 1
$LN159@stbi__crea:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 4439 : 	stbi__context* s = a->s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 4440 : 	stbi__uint32 i, j, stride = x * out_n * bytes;

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _stride$[ebp], eax

; 4441 : 	stbi__uint32 img_len, img_width_bytes;
; 4442 : 	int k;
; 4443 : 	int img_n = s->img_n; // copy it into a local for later

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _img_n$[ebp], ecx

; 4444 : 
; 4445 : 	int output_bytes = out_n * bytes;

	mov	eax, DWORD PTR _out_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _output_bytes$[ebp], eax

; 4446 : 	int filter_bytes = img_n * bytes;

	mov	eax, DWORD PTR _img_n$[ebp]
	imul	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _filter_bytes$[ebp], eax

; 4447 : 	int width = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 4448 : 
; 4449 : 	STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _out_n$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN160@stbi__crea
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	cmp	DWORD PTR _out_n$[ebp], eax
	je	SHORT $LN160@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA
	add	ecx, 12					; 0000000cH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1FG@LGPEHEPM@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN160@stbi__crea:

; 4450 : 	a->out = (stbi_uc*)stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

	push	0
	mov	eax, DWORD PTR _output_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4451 : 	if (!a->out) return stbi__err("outofmem", "Out of memory");

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN98@stbi__crea
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__crea
$LN98@stbi__crea:

; 4452 : 
; 4453 : 	if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

	push	7
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _img_n$[ebp]
	push	edx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN99@stbi__crea
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__crea
$LN99@stbi__crea:

; 4454 : 	img_width_bytes = (((img_n * x * depth) + 7) >> 3);

	mov	eax, DWORD PTR _img_n$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	add	eax, 7
	shr	eax, 3
	mov	DWORD PTR _img_width_bytes$[ebp], eax

; 4455 : 	img_len = (img_width_bytes + 1) * y;

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 4456 : 
; 4457 : 	// we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4458 : 	// but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4459 : 	// so just check for raw_len < img_len always.
; 4460 : 	if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");

	mov	eax, DWORD PTR _raw_len$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jae	SHORT $LN100@stbi__crea
	push	OFFSET ??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__crea
$LN100@stbi__crea:

; 4461 : 
; 4462 : 	for (j = 0; j < y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jae	$LN3@stbi__crea

; 4463 : 		stbi_uc* cur = a->out + stride * j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$10[ebp], eax

; 4464 : 		stbi_uc* prior;
; 4465 : 		int filter = *raw++;

	mov	eax, DWORD PTR _raw$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _filter$8[ebp], ecx
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, 1
	mov	DWORD PTR _raw$[ebp], edx

; 4466 : 
; 4467 : 		if (filter > 4)

	cmp	DWORD PTR _filter$8[ebp], 4
	jle	SHORT $LN101@stbi__crea

; 4468 : 			return stbi__err("invalid filter", "Corrupt PNG");

	push	OFFSET ??_C@_0P@FBBCPGMN@invalid?5filter@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__crea
$LN101@stbi__crea:

; 4469 : 
; 4470 : 		if (depth < 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jge	SHORT $LN102@stbi__crea

; 4471 : 			STBI_ASSERT(img_width_bytes <= x);

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	cmp	eax, DWORD PTR _x$[ebp]
	jbe	SHORT $LN161@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA
	add	ecx, 34					; 00000022H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CK@EJKIMPDL@?$AAi?$AAm?$AAg?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA_?$AAb?$AAy?$AAt?$AAe?$AAs@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN161@stbi__crea:

; 4472 : 			cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	sub	eax, DWORD PTR _img_width_bytes$[ebp]
	add	eax, DWORD PTR _cur$10[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4473 : 			filter_bytes = 1;

	mov	DWORD PTR _filter_bytes$[ebp], 1

; 4474 : 			width = img_width_bytes;

	mov	eax, DWORD PTR _img_width_bytes$[ebp]
	mov	DWORD PTR _width$[ebp], eax
$LN102@stbi__crea:

; 4475 : 		}
; 4476 : 		prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

	mov	eax, DWORD PTR _cur$10[ebp]
	sub	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax

; 4477 : 
; 4478 : 		// if first row, use special filter that doesn't sample previous row
; 4479 : 		if (j == 0) filter = first_row_filter[filter];

	cmp	DWORD PTR _j$[ebp], 0
	jne	SHORT $LN103@stbi__crea
	mov	eax, DWORD PTR _filter$8[ebp]
	movzx	ecx, BYTE PTR ?first_row_filter@@3PAEA[eax]
	mov	DWORD PTR _filter$8[ebp], ecx
$LN103@stbi__crea:

; 4480 : 
; 4481 : 		// handle first byte explicitly
; 4482 : 		for (k = 0; k < filter_bytes; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@stbi__crea
$LN5@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	$LN6@stbi__crea

; 4483 : 			switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv168[ebp], eax
	cmp	DWORD PTR tv168[ebp], 6
	ja	$LN8@stbi__crea
	mov	ecx, DWORD PTR tv168[ebp]
	jmp	DWORD PTR $LN166@stbi__crea[ecx*4]
$LN104@stbi__crea:

; 4484 : 			case STBI__F_none: cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	$LN8@stbi__crea
$LN105@stbi__crea:

; 4485 : 			case STBI__F_sub: cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	$LN8@stbi__crea
$LN106@stbi__crea:

; 4486 : 			case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	$LN8@stbi__crea
$LN107@stbi__crea:

; 4487 : 			case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN8@stbi__crea
$LN108@stbi__crea:

; 4488 : 			case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	0
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN8@stbi__crea
$LN109@stbi__crea:

; 4489 : 			case STBI__F_avg_first: cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN8@stbi__crea
$LN110@stbi__crea:

; 4490 : 			case STBI__F_paeth_first: cur[k] = raw[k]; break;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN8@stbi__crea:

; 4491 : 			}
; 4492 : 		}

	jmp	$LN5@stbi__crea
$LN6@stbi__crea:

; 4493 : 
; 4494 : 		if (depth == 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jne	SHORT $LN111@stbi__crea

; 4495 : 			if (img_n != out_n)

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN113@stbi__crea

; 4496 : 				cur[img_n] = 255; // first pixel

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _img_n$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
$LN113@stbi__crea:

; 4497 : 			raw += img_n;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4498 : 			cur += out_n;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _out_n$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4499 : 			prior += out_n;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, DWORD PTR _out_n$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax

; 4500 : 		}

	jmp	SHORT $LN112@stbi__crea
$LN111@stbi__crea:

; 4501 : 		else if (depth == 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN114@stbi__crea

; 4502 : 			if (img_n != out_n) {

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN116@stbi__crea

; 4503 : 				cur[filter_bytes] = 255; // first pixel top byte

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH

; 4504 : 				cur[filter_bytes + 1] = 255; // first pixel bottom byte

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
$LN116@stbi__crea:

; 4505 : 			}
; 4506 : 			raw += filter_bytes;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4507 : 			cur += output_bytes;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax

; 4508 : 			prior += output_bytes;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], eax

; 4509 : 		}

	jmp	SHORT $LN112@stbi__crea
$LN114@stbi__crea:

; 4510 : 		else {
; 4511 : 			raw += 1;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, 1
	mov	DWORD PTR _raw$[ebp], eax

; 4512 : 			cur += 1;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$10[ebp], eax

; 4513 : 			prior += 1;

	mov	eax, DWORD PTR _prior$9[ebp]
	add	eax, 1
	mov	DWORD PTR _prior$9[ebp], eax
$LN112@stbi__crea:

; 4514 : 		}
; 4515 : 
; 4516 : 		// this is a little gross, so that we don't switch per-pixel or per-component
; 4517 : 		if (depth < 8 || img_n == out_n) {

	cmp	DWORD PTR _depth$[ebp], 8
	jl	SHORT $LN119@stbi__crea
	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	jne	$LN117@stbi__crea
$LN119@stbi__crea:

; 4518 : 			int nk = (width - 1) * filter_bytes;

	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _nk$7[ebp], eax

; 4519 : #define STBI__CASE(f) \
; 4520 :              case f:     \
; 4521 :                 for (k=0; k < nk; ++k)
; 4522 : 			switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv248[ebp], eax
	cmp	DWORD PTR tv248[ebp], 6
	ja	$LN10@stbi__crea
	mov	ecx, DWORD PTR tv248[ebp]
	jmp	DWORD PTR $LN167@stbi__crea[ecx*4]
$LN120@stbi__crea:

; 4523 : 				// "none" filter turns into a memcpy here; make that explicit.
; 4524 : 			case STBI__F_none:         memcpy(cur, raw, nk); break;

	mov	eax, DWORD PTR _nk$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$10[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	$LN10@stbi__crea
$LN121@stbi__crea:

; 4525 : 				STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN14@stbi__crea
$LN12@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN14@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN13@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN12@stbi__crea
$LN13@stbi__crea:
	jmp	$LN10@stbi__crea
$LN122@stbi__crea:

; 4526 : 				STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN17@stbi__crea
$LN15@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN17@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN16@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN15@stbi__crea
$LN16@stbi__crea:
	jmp	$LN10@stbi__crea
$LN123@stbi__crea:

; 4527 : 				STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN20@stbi__crea
$LN18@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN20@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN19@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	esi, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	add	eax, edx
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN18@stbi__crea
$LN19@stbi__crea:
	jmp	$LN10@stbi__crea
$LN124@stbi__crea:

; 4528 : 				STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN23@stbi__crea
$LN21@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN23@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN22@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	edx, DWORD PTR _prior$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _filter_bytes$[ebp]
	mov	ecx, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN21@stbi__crea
$LN22@stbi__crea:
	jmp	$LN10@stbi__crea
$LN125@stbi__crea:

; 4529 : 				STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN26@stbi__crea
$LN24@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN26@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN25@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _filter_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sar	edx, 1
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN24@stbi__crea
$LN25@stbi__crea:
	jmp	SHORT $LN10@stbi__crea
$LN126@stbi__crea:

; 4530 : 				STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); } break;

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN29@stbi__crea
$LN27@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN29@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nk$7[ebp]
	jge	SHORT $LN10@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	edx, DWORD PTR _cur$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx], bl
	jmp	SHORT $LN27@stbi__crea
$LN10@stbi__crea:

; 4531 : 			}
; 4532 : #undef STBI__CASE
; 4533 : 			raw += nk;

	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _nk$7[ebp]
	mov	DWORD PTR _raw$[ebp], eax

; 4534 : 		}

	jmp	$LN118@stbi__crea
$LN117@stbi__crea:

; 4535 : 		else {
; 4536 : 			STBI_ASSERT(img_n + 1 == out_n);

	mov	eax, DWORD PTR _img_n$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	SHORT $LN162@stbi__crea
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA
	add	ecx, 99					; 00000063H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CG@MFAHHIFB@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN162@stbi__crea:

; 4537 : #define STBI__CASE(f) \
; 4538 :              case f:     \
; 4539 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4540 :                    for (k=0; k < filter_bytes; ++k)
; 4541 : 			switch (filter) {

	mov	eax, DWORD PTR _filter$8[ebp]
	mov	DWORD PTR tv365[ebp], eax
	cmp	DWORD PTR tv365[ebp], 6
	ja	$LN30@stbi__crea
	mov	ecx, DWORD PTR tv365[ebp]
	jmp	DWORD PTR $LN168@stbi__crea[ecx*4]
$LN127@stbi__crea:

; 4542 : 				STBI__CASE(STBI__F_none) { cur[k] = raw[k]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN34@stbi__crea
$LN32@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN34@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN33@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN37@stbi__crea
$LN35@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN37@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN36@stbi__crea
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _raw$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN35@stbi__crea
$LN36@stbi__crea:
	jmp	SHORT $LN32@stbi__crea
$LN33@stbi__crea:
	jmp	$LN30@stbi__crea
$LN128@stbi__crea:

; 4543 : 				STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN40@stbi__crea
$LN38@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN40@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN39@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN43@stbi__crea
$LN41@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN43@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN42@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN41@stbi__crea
$LN42@stbi__crea:
	jmp	$LN38@stbi__crea
$LN39@stbi__crea:
	jmp	$LN30@stbi__crea
$LN129@stbi__crea:

; 4544 : 				STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN46@stbi__crea
$LN44@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN46@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN45@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN49@stbi__crea
$LN47@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN49@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN48@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _cur$10[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN47@stbi__crea
$LN48@stbi__crea:
	jmp	$LN44@stbi__crea
$LN45@stbi__crea:
	jmp	$LN30@stbi__crea
$LN130@stbi__crea:

; 4545 : 				STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN52@stbi__crea
$LN50@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN52@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN51@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN55@stbi__crea
$LN53@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN55@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN54@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _prior$9[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	esi, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	add	eax, edx
	sar	eax, 1
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN53@stbi__crea
$LN54@stbi__crea:
	jmp	$LN50@stbi__crea
$LN51@stbi__crea:
	jmp	$LN30@stbi__crea
$LN131@stbi__crea:

; 4546 : 				STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN58@stbi__crea
$LN56@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN58@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN57@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN61@stbi__crea
$LN59@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN61@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN60@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _output_bytes$[ebp]
	mov	edx, DWORD PTR _prior$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _output_bytes$[ebp]
	mov	ecx, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], bl
	jmp	SHORT $LN59@stbi__crea
$LN60@stbi__crea:
	jmp	$LN56@stbi__crea
$LN57@stbi__crea:
	jmp	$LN30@stbi__crea
$LN132@stbi__crea:

; 4547 : 				STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN64@stbi__crea
$LN62@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN64@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN63@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN67@stbi__crea
$LN65@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN67@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN66@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, DWORD PTR _output_bytes$[ebp]
	mov	eax, DWORD PTR _cur$10[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sar	edx, 1
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN65@stbi__crea
$LN66@stbi__crea:
	jmp	$LN62@stbi__crea
$LN63@stbi__crea:
	jmp	$LN30@stbi__crea
$LN133@stbi__crea:

; 4548 : 				STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN70@stbi__crea
$LN68@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	edx, DWORD PTR _raw$[ebp]
	add	edx, DWORD PTR _filter_bytes$[ebp]
	mov	DWORD PTR _raw$[ebp], edx
	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], eax
	mov	ecx, DWORD PTR _prior$9[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _prior$9[ebp], ecx
$LN70@stbi__crea:
	cmp	DWORD PTR _i$[ebp], 1
	jb	SHORT $LN30@stbi__crea
	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN73@stbi__crea
$LN71@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN73@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _filter_bytes$[ebp]
	jge	SHORT $LN72@stbi__crea
	mov	eax, DWORD PTR _raw$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ebx, BYTE PTR [eax]
	push	0
	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _output_bytes$[ebp]
	mov	edx, DWORD PTR _cur$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	add	esp, 12					; 0000000cH
	add	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx], bl
	jmp	SHORT $LN71@stbi__crea
$LN72@stbi__crea:
	jmp	$LN68@stbi__crea
$LN30@stbi__crea:

; 4549 : 			}
; 4550 : #undef STBI__CASE
; 4551 : 
; 4552 : 			// the loop above sets the high byte of the pixels' alpha, but for
; 4553 : 			// 16 bit png files we also need the low byte set. we'll do that here.
; 4554 : 			if (depth == 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	SHORT $LN118@stbi__crea

; 4555 : 				cur = a->out + stride * j; // start at the beginning of the row again

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$10[ebp], eax

; 4556 : 				for (i = 0; i < x; ++i, cur += output_bytes) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN76@stbi__crea
$LN74@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$10[ebp]
	add	ecx, DWORD PTR _output_bytes$[ebp]
	mov	DWORD PTR _cur$10[ebp], ecx
$LN76@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _x$[ebp]
	jae	SHORT $LN118@stbi__crea

; 4557 : 					cur[filter_bytes + 1] = 255;

	mov	eax, DWORD PTR _cur$10[ebp]
	add	eax, DWORD PTR _filter_bytes$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 4558 : 				}

	jmp	SHORT $LN74@stbi__crea
$LN118@stbi__crea:

; 4559 : 			}
; 4560 : 		}
; 4561 : 	}

	jmp	$LN2@stbi__crea
$LN3@stbi__crea:

; 4562 : 
; 4563 : 	// we make a separate pass to expand bits to pixels; for performance,
; 4564 : 	// this could run two scanlines behind the above code, so it won't
; 4565 : 	// intefere with filtering but will still be in the cache.
; 4566 : 	if (depth < 8) {

	cmp	DWORD PTR _depth$[ebp], 8
	jge	$LN135@stbi__crea

; 4567 : 		for (j = 0; j < y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN79@stbi__crea
$LN77@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN79@stbi__crea:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jae	$LN78@stbi__crea

; 4568 : 			stbi_uc* cur = a->out + stride * j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$6[ebp], eax

; 4569 : 			stbi_uc* in = a->out + stride * j + x * out_n - img_width_bytes;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	add	edx, eax
	sub	edx, DWORD PTR _img_width_bytes$[ebp]
	mov	DWORD PTR _in$5[ebp], edx

; 4570 : 			// unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4571 : 			// png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4572 : 			stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

	cmp	DWORD PTR _color$[ebp], 0
	jne	SHORT $LN163@stbi__crea
	mov	eax, DWORD PTR _depth$[ebp]
	movzx	ecx, BYTE PTR ?stbi__depth_scale_table@@3QBEB[eax]
	mov	DWORD PTR tv559[ebp], ecx
	jmp	SHORT $LN164@stbi__crea
$LN163@stbi__crea:
	mov	DWORD PTR tv559[ebp], 1
$LN164@stbi__crea:
	mov	dl, BYTE PTR tv559[ebp]
	mov	BYTE PTR _scale$4[ebp], dl

; 4573 : 
; 4574 : 			// note that the final byte might overshoot and write more data than desired.
; 4575 : 			// we can allocate enough data that this never writes out of memory, but it
; 4576 : 			// could also overwrite the next scanline. can it overwrite non-empty data
; 4577 : 			// on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4578 : 			// so we need to explicitly clamp the final ones
; 4579 : 
; 4580 : 			if (depth == 4) {

	cmp	DWORD PTR _depth$[ebp], 4
	jne	$LN137@stbi__crea

; 4581 : 				for (k = x * img_n; k >= 2; k -= 2, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN82@stbi__crea
$LN80@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 2
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN82@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 2
	jl	SHORT $LN81@stbi__crea

; 4582 : 					*cur++ = scale * ((*in >> 4));

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4583 : 					*cur++ = scale * ((*in) & 0x0f);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 15					; 0000000fH
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4584 : 				}

	jmp	SHORT $LN80@stbi__crea
$LN81@stbi__crea:

; 4585 : 				if (k > 0)* cur++ = scale * ((*in >> 4));

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN139@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN139@stbi__crea:

; 4586 : 			}

	jmp	$LN138@stbi__crea
$LN137@stbi__crea:

; 4587 : 			else if (depth == 2) {

	cmp	DWORD PTR _depth$[ebp], 2
	jne	$LN140@stbi__crea

; 4588 : 				for (k = x * img_n; k >= 4; k -= 4, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN85@stbi__crea
$LN83@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 4
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN85@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 4
	jl	$LN84@stbi__crea

; 4589 : 					*cur++ = scale * ((*in >> 6));

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4590 : 					*cur++ = scale * ((*in >> 4) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4591 : 					*cur++ = scale * ((*in >> 2) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4592 : 					*cur++ = scale * ((*in) & 0x03);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4593 : 				}

	jmp	$LN83@stbi__crea
$LN84@stbi__crea:

; 4594 : 				if (k > 0)* cur++ = scale * ((*in >> 6));

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN142@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN142@stbi__crea:

; 4595 : 				if (k > 1)* cur++ = scale * ((*in >> 4) & 0x03);

	cmp	DWORD PTR _k$[ebp], 1
	jle	SHORT $LN143@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN143@stbi__crea:

; 4596 : 				if (k > 2)* cur++ = scale * ((*in >> 2) & 0x03);

	cmp	DWORD PTR _k$[ebp], 2
	jle	SHORT $LN144@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 3
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN144@stbi__crea:

; 4597 : 			}

	jmp	$LN138@stbi__crea
$LN140@stbi__crea:

; 4598 : 			else if (depth == 1) {

	cmp	DWORD PTR _depth$[ebp], 1
	jne	$LN138@stbi__crea

; 4599 : 				for (k = x * img_n; k >= 8; k -= 8, ++in) {

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN88@stbi__crea
$LN86@stbi__crea:
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _in$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$5[ebp], ecx
$LN88@stbi__crea:
	cmp	DWORD PTR _k$[ebp], 8
	jl	$LN87@stbi__crea

; 4600 : 					*cur++ = scale * ((*in >> 7));

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 7
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4601 : 					*cur++ = scale * ((*in >> 6) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4602 : 					*cur++ = scale * ((*in >> 5) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 5
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4603 : 					*cur++ = scale * ((*in >> 4) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4604 : 					*cur++ = scale * ((*in >> 3) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 3
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4605 : 					*cur++ = scale * ((*in >> 2) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4606 : 					*cur++ = scale * ((*in >> 1) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 1
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4607 : 					*cur++ = scale * ((*in) & 0x01);

	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx

; 4608 : 				}

	jmp	$LN86@stbi__crea
$LN87@stbi__crea:

; 4609 : 				if (k > 0)* cur++ = scale * ((*in >> 7));

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN146@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 7
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN146@stbi__crea:

; 4610 : 				if (k > 1)* cur++ = scale * ((*in >> 6) & 0x01);

	cmp	DWORD PTR _k$[ebp], 1
	jle	SHORT $LN147@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 6
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN147@stbi__crea:

; 4611 : 				if (k > 2)* cur++ = scale * ((*in >> 5) & 0x01);

	cmp	DWORD PTR _k$[ebp], 2
	jle	SHORT $LN148@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 5
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN148@stbi__crea:

; 4612 : 				if (k > 3)* cur++ = scale * ((*in >> 4) & 0x01);

	cmp	DWORD PTR _k$[ebp], 3
	jle	SHORT $LN149@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN149@stbi__crea:

; 4613 : 				if (k > 4)* cur++ = scale * ((*in >> 3) & 0x01);

	cmp	DWORD PTR _k$[ebp], 4
	jle	SHORT $LN150@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 3
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN150@stbi__crea:

; 4614 : 				if (k > 5)* cur++ = scale * ((*in >> 2) & 0x01);

	cmp	DWORD PTR _k$[ebp], 5
	jle	SHORT $LN151@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 2
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN151@stbi__crea:

; 4615 : 				if (k > 6)* cur++ = scale * ((*in >> 1) & 0x01);

	cmp	DWORD PTR _k$[ebp], 6
	jle	SHORT $LN138@stbi__crea
	movzx	eax, BYTE PTR _scale$4[ebp]
	mov	ecx, DWORD PTR _in$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 1
	and	edx, 1
	imul	eax, edx
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _cur$6[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$6[ebp], edx
$LN138@stbi__crea:

; 4616 : 			}
; 4617 : 			if (img_n != out_n) {

	mov	eax, DWORD PTR _img_n$[ebp]
	cmp	eax, DWORD PTR _out_n$[ebp]
	je	$LN153@stbi__crea

; 4618 : 				int q;
; 4619 : 				// insert alpha = 255
; 4620 : 				cur = a->out + stride * j;

	mov	eax, DWORD PTR _stride$[ebp]
	imul	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$6[ebp], eax

; 4621 : 				if (img_n == 1) {

	cmp	DWORD PTR _img_n$[ebp], 1
	jne	SHORT $LN154@stbi__crea

; 4622 : 					for (q = x - 1; q >= 0; --q) {

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
	jmp	SHORT $LN91@stbi__crea
$LN89@stbi__crea:
	mov	eax, DWORD PTR _q$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
$LN91@stbi__crea:
	cmp	DWORD PTR _q$3[ebp], 0
	jl	SHORT $LN90@stbi__crea

; 4623 : 						cur[q * 2 + 1] = 255;

	mov	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx+eax*2+1], 255		; 000000ffH

; 4624 : 						cur[q * 2 + 0] = cur[q];

	mov	eax, DWORD PTR _cur$6[ebp]
	add	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx*2], al

; 4625 : 					}

	jmp	SHORT $LN89@stbi__crea
$LN90@stbi__crea:

; 4626 : 				}

	jmp	$LN153@stbi__crea
$LN154@stbi__crea:

; 4627 : 				else {
; 4628 : 					STBI_ASSERT(img_n == 3);

	cmp	DWORD PTR _img_n$[ebp], 3
	je	SHORT $LN165@stbi__crea
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z@4JA
	add	eax, 191				; 000000bfH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN165@stbi__crea:

; 4629 : 					for (q = x - 1; q >= 0; --q) {

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
	jmp	SHORT $LN94@stbi__crea
$LN92@stbi__crea:
	mov	eax, DWORD PTR _q$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _q$3[ebp], eax
$LN94@stbi__crea:
	cmp	DWORD PTR _q$3[ebp], 0
	jl	SHORT $LN153@stbi__crea

; 4630 : 						cur[q * 4 + 3] = 255;

	mov	eax, DWORD PTR _q$3[ebp]
	mov	ecx, DWORD PTR _cur$6[ebp]
	mov	BYTE PTR [ecx+eax*4+3], 255		; 000000ffH

; 4631 : 						cur[q * 4 + 2] = cur[q * 3 + 2];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx*4+2], al

; 4632 : 						cur[q * 4 + 1] = cur[q * 3 + 1];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 4633 : 						cur[q * 4 + 0] = cur[q * 3 + 0];

	imul	eax, DWORD PTR _q$3[ebp], 3
	mov	ecx, DWORD PTR _q$3[ebp]
	mov	edx, DWORD PTR _cur$6[ebp]
	mov	esi, DWORD PTR _cur$6[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx*4], al

; 4634 : 					}

	jmp	$LN92@stbi__crea
$LN153@stbi__crea:

; 4635 : 				}
; 4636 : 			}
; 4637 : 		}

	jmp	$LN77@stbi__crea
$LN78@stbi__crea:

; 4638 : 	}

	jmp	$LN136@stbi__crea
$LN135@stbi__crea:

; 4639 : 	else if (depth == 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	jne	$LN136@stbi__crea

; 4640 : 		// force the image data from big-endian to platform-native.
; 4641 : 		// this is done in a separate pass due to the decoding relying
; 4642 : 		// on the data being untouched, but could probably be done
; 4643 : 		// per-line during decode if care is taken.
; 4644 : 		stbi_uc* cur = a->out;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$2[ebp], ecx

; 4645 : 		stbi__uint16* cur16 = (stbi__uint16*)cur;

	mov	eax, DWORD PTR _cur$2[ebp]
	mov	DWORD PTR _cur16$1[ebp], eax

; 4646 : 
; 4647 : 		for (i = 0; i < x * y * out_n; ++i, cur16++, cur += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN97@stbi__crea
$LN95@stbi__crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur16$1[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur16$1[ebp], ecx
	mov	edx, DWORD PTR _cur$2[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$2[ebp], edx
$LN97@stbi__crea:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _out_n$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN136@stbi__crea

; 4648 : 			*cur16 = (cur[0] << 8) | cur[1];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	or	eax, ecx
	mov	edx, DWORD PTR _cur16$1[ebp]
	mov	WORD PTR [edx], ax

; 4649 : 		}

	jmp	SHORT $LN95@stbi__crea
$LN136@stbi__crea:

; 4650 : 	}
; 4651 : 
; 4652 : 	return 1;

	mov	eax, 1
$LN1@stbi__crea:

; 4653 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN166@stbi__crea:
	DD	$LN104@stbi__crea
	DD	$LN105@stbi__crea
	DD	$LN106@stbi__crea
	DD	$LN107@stbi__crea
	DD	$LN108@stbi__crea
	DD	$LN109@stbi__crea
	DD	$LN110@stbi__crea
$LN167@stbi__crea:
	DD	$LN120@stbi__crea
	DD	$LN121@stbi__crea
	DD	$LN122@stbi__crea
	DD	$LN123@stbi__crea
	DD	$LN124@stbi__crea
	DD	$LN125@stbi__crea
	DD	$LN126@stbi__crea
$LN168@stbi__crea:
	DD	$LN127@stbi__crea
	DD	$LN128@stbi__crea
	DD	$LN129@stbi__crea
	DD	$LN130@stbi__crea
	DD	$LN131@stbi__crea
	DD	$LN132@stbi__crea
	DD	$LN133@stbi__crea
?stbi__create_png_image_raw@@YAHPAUstbi__png@@PAEIHIIHH@Z ENDP ; stbi__create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__paeth@@YAHHHH@Z
_TEXT	SEGMENT
_pc$ = -44						; size = 4
_pb$ = -32						; size = 4
_pa$ = -20						; size = 4
_p$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?stbi__paeth@@YAHHHH@Z PROC				; stbi__paeth, COMDAT

; 4423 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4424 : 	int p = a + b - c;

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	sub	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 4425 : 	int pa = abs(p - a);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pa$[ebp], eax

; 4426 : 	int pb = abs(p - b);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pb$[ebp], eax

; 4427 : 	int pc = abs(p - c);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _pc$[ebp], eax

; 4428 : 	if (pa <= pb && pa <= pc) return a;

	mov	eax, DWORD PTR _pa$[ebp]
	cmp	eax, DWORD PTR _pb$[ebp]
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR _pa$[ebp]
	cmp	eax, DWORD PTR _pc$[ebp]
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR _a$[ebp]
	jmp	SHORT $LN1@stbi__paet
$LN2@stbi__paet:

; 4429 : 	if (pb <= pc) return b;

	mov	eax, DWORD PTR _pb$[ebp]
	cmp	eax, DWORD PTR _pc$[ebp]
	jg	SHORT $LN3@stbi__paet
	mov	eax, DWORD PTR _b$[ebp]
	jmp	SHORT $LN1@stbi__paet
$LN3@stbi__paet:

; 4430 : 	return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN1@stbi__paet:

; 4431 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__paeth@@YAHHHH@Z ENDP				; stbi__paeth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__check_png_header@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__check_png_header@@YAHPAUstbi__context@@@Z PROC	; stbi__check_png_header, COMDAT

; 4386 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4387 : 	static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4388 : 	int i;
; 4389 : 	for (i = 0; i < 8; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__chec
$LN2@stbi__chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__chec:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@stbi__chec

; 4390 : 		if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR ?png_sig@?1??stbi__check_png_header@@YAHPAUstbi__context@@@Z@4QBEB[edx]
	cmp	ecx, eax
	je	SHORT $LN5@stbi__chec
	push	OFFSET ??_C@_0M@DMDNBACF@bad?5png?5sig@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__chec
$LN5@stbi__chec:
	jmp	SHORT $LN2@stbi__chec
$LN3@stbi__chec:

; 4391 : 	return 1;

	mov	eax, 1
$LN1@stbi__chec:

; 4392 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__check_png_header@@YAHPAUstbi__context@@@Z ENDP	; stbi__check_png_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PAUstbi__context@@@Z
_TEXT	SEGMENT
_c$ = -12						; size = 8
_s$ = 8							; size = 4
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PAUstbi__context@@@Z PROC ; stbi__get_chunk_header, COMDAT

; 4378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4379 : 	stbi__pngchunk c;
; 4380 : 	c.length = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 4381 : 	c.type = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	DWORD PTR _c$[ebp+4], eax

; 4382 : 	return c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp+4]

; 4383 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__get_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@stbi__get_:
	DD	1
	DD	$LN4@stbi__get_
$LN4@stbi__get_:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN3@stbi__get_
$LN3@stbi__get_:
	DB	99					; 00000063H
	DB	0
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PAUstbi__context@@@Z ENDP ; stbi__get_chunk_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_obuf$ = 12						; size = 4
_olen$ = 16						; size = 4
_exp$ = 20						; size = 4
_parse_header$ = 24					; size = 4
?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z PROC		; stbi__do_zlib, COMDAT

; 4272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4273 : 	a->zout_start = obuf;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _obuf$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4274 : 	a->zout = obuf;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _obuf$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4275 : 	a->zout_end = obuf + olen;

	mov	eax, DWORD PTR _obuf$[ebp]
	add	eax, DWORD PTR _olen$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 4276 : 	a->z_expandable = exp;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _exp$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 4277 : 
; 4278 : 	return stbi__parse_zlib(a, parse_header);

	mov	eax, DWORD PTR _parse_header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__parse_zlib@@YAHPAUstbi__zbuf@@H@Z ; stbi__parse_zlib
	add	esp, 8

; 4279 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ENDP		; stbi__do_zlib
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_zlib@@YAHPAUstbi__zbuf@@H@Z
_TEXT	SEGMENT
_type$ = -20						; size = 4
_final$ = -8						; size = 4
_a$ = 8							; size = 4
_parse_header$ = 12					; size = 4
?stbi__parse_zlib@@YAHPAUstbi__zbuf@@H@Z PROC		; stbi__parse_zlib, COMDAT

; 4241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4242 : 	int final, type;
; 4243 : 	if (parse_header)

	cmp	DWORD PTR _parse_header$[ebp], 0
	je	SHORT $LN5@stbi__pars

; 4244 : 		if (!stbi__parse_zlib_header(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__parse_zlib_header@@YAHPAUstbi__zbuf@@@Z ; stbi__parse_zlib_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN5@stbi__pars:

; 4245 : 	a->num_bits = 0;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4246 : 	a->code_buffer = 0;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN4@stbi__pars:

; 4247 : 	do {
; 4248 : 		final = stbi__zreceive(a, 1);

	push	1
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _final$[ebp], eax

; 4249 : 		type = stbi__zreceive(a, 2);

	push	2
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _type$[ebp], eax

; 4250 : 		if (type == 0) {

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN7@stbi__pars

; 4251 : 			if (!stbi__parse_uncompressed_block(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z ; stbi__parse_uncompressed_block
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN9@stbi__pars:

; 4252 : 		}

	jmp	$LN2@stbi__pars
$LN7@stbi__pars:

; 4253 : 		else if (type == 3) {

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN10@stbi__pars

; 4254 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars

; 4255 : 		}

	jmp	SHORT $LN2@stbi__pars
$LN10@stbi__pars:

; 4256 : 		else {
; 4257 : 			if (type == 1) {

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN12@stbi__pars

; 4258 : 				// use fixed code lengths
; 4259 : 				if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, 288)) return 0;

	push	288					; 00000120H
	push	OFFSET ?stbi__zdefault_length@@3QBEB
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ; stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN14@stbi__pars:

; 4260 : 				if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;

	push	32					; 00000020H
	push	OFFSET ?stbi__zdefault_distance@@3QBEB
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	call	?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ; stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 4261 : 			}

	jmp	SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 4262 : 			else {
; 4263 : 				if (!stbi__compute_huffman_codes(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z ; stbi__compute_huffman_codes
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN13@stbi__pars:

; 4264 : 			}
; 4265 : 			if (!stbi__parse_huffman_block(a)) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__parse_huffman_block@@YAHPAUstbi__zbuf@@@Z ; stbi__parse_huffman_block
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 4266 : 		}
; 4267 : 	} while (!final);

	cmp	DWORD PTR _final$[ebp], 0
	je	$LN4@stbi__pars

; 4268 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 4269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__parse_zlib@@YAHPAUstbi__zbuf@@H@Z ENDP		; stbi__parse_zlib
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_zlib_header@@YAHPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
_flg$ = -32						; size = 4
_cm$ = -20						; size = 4
_cmf$ = -8						; size = 4
_a$ = 8							; size = 4
?stbi__parse_zlib_header@@YAHPAUstbi__zbuf@@@Z PROC	; stbi__parse_zlib_header, COMDAT

; 4199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4200 : 	int cmf = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zget8@@YAEPAUstbi__zbuf@@@Z	; stbi__zget8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _cmf$[ebp], ecx

; 4201 : 	int cm = cmf & 15;

	mov	eax, DWORD PTR _cmf$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _cm$[ebp], eax

; 4202 : 	/* int cinfo = cmf >> 4; */
; 4203 : 	int flg = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zget8@@YAEPAUstbi__zbuf@@@Z	; stbi__zget8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _flg$[ebp], ecx

; 4204 : 	if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec

	mov	eax, DWORD PTR _cmf$[ebp]
	shl	eax, 8
	add	eax, DWORD PTR _flg$[ebp]
	cdq
	mov	ecx, 31					; 0000001fH
	idiv	ecx
	test	edx, edx
	je	SHORT $LN2@stbi__pars
	push	OFFSET ??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 4205 : 	if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png

	mov	eax, DWORD PTR _flg$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN3@stbi__pars
	push	OFFSET ??_C@_0P@DOGMHEBI@no?5preset?5dict@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 4206 : 	if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png

	cmp	DWORD PTR _cm$[ebp], 8
	je	SHORT $LN4@stbi__pars
	push	OFFSET ??_C@_0BA@MCNBDLPD@bad?5compression@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 4207 : 	// window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4208 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 4209 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__parse_zlib_header@@YAHPAUstbi__zbuf@@@Z ENDP	; stbi__parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
_k$ = -44						; size = 4
_nlen$ = -32						; size = 4
_len$ = -20						; size = 4
_header$ = -8						; size = 4
_a$ = 8							; size = 4
?stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z PROC ; stbi__parse_uncompressed_block, COMDAT

; 4170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4171 : 	stbi_uc header[4];
; 4172 : 	int len, nlen, k;
; 4173 : 	if (a->num_bits & 7)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	je	SHORT $LN6@stbi__pars

; 4174 : 		stbi__zreceive(a, a->num_bits & 7); // discard

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
$LN6@stbi__pars:

; 4175 : 	 // drain the bit-packed data into header
; 4176 : 	k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN2@stbi__pars:

; 4177 : 	while (a->num_bits > 0) {

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN3@stbi__pars

; 4178 : 		header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _header$[ebp+edx], cl
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 4179 : 		a->code_buffer >>= 8;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4180 : 		a->num_bits -= 8;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4181 : 	}

	jmp	SHORT $LN2@stbi__pars
$LN3@stbi__pars:

; 4182 : 	STBI_ASSERT(a->num_bits == 0);

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@stbi__pars
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z@4JA
	add	ecx, 12					; 0000000cH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CC@BHGGCLFF@?$AAa?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AA_?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@stbi__pars:

; 4183 : 	// now fill header the normal way
; 4184 : 	while (k < 4)

	cmp	DWORD PTR _k$[ebp], 4
	jge	SHORT $LN5@stbi__pars

; 4185 : 		header[k++] = stbi__zget8(a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zget8@@YAEPAUstbi__zbuf@@@Z	; stbi__zget8
	add	esp, 4
	mov	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _header$[ebp+ecx], al
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	jmp	SHORT $LN4@stbi__pars
$LN5@stbi__pars:

; 4186 : 	len = header[1] * 256 + header[0];

	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _header$[ebp+eax]
	shl	ecx, 8
	mov	edx, 1
	imul	eax, edx, 0
	movzx	edx, BYTE PTR _header$[ebp+eax]
	add	ecx, edx
	mov	DWORD PTR _len$[ebp], ecx

; 4187 : 	nlen = header[3] * 256 + header[2];

	mov	eax, 1
	imul	ecx, eax, 3
	movzx	edx, BYTE PTR _header$[ebp+ecx]
	shl	edx, 8
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _header$[ebp+eax]
	add	edx, ecx
	mov	DWORD PTR _nlen$[ebp], edx

; 4188 : 	if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");

	mov	eax, DWORD PTR _len$[ebp]
	xor	eax, 65535				; 0000ffffH
	cmp	DWORD PTR _nlen$[ebp], eax
	je	SHORT $LN7@stbi__pars
	push	OFFSET ??_C@_0N@IECDHMDI@zlib?5corrupt@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN7@stbi__pars:

; 4189 : 	if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	cmp	ecx, DWORD PTR [edx+4]
	jbe	SHORT $LN8@stbi__pars
	push	OFFSET ??_C@_0BB@PIPBCKIA@read?5past?5buffer@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pars
$LN8@stbi__pars:

; 4190 : 	if (a->zout + len > a->zout_end)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	cmp	ecx, DWORD PTR [edx+24]
	jbe	SHORT $LN9@stbi__pars

; 4191 : 		if (!stbi__zexpand(a, a->zout, len)) return 0;

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z ; stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN9@stbi__pars:

; 4192 : 	memcpy(a->zout, a->zbuffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4193 : 	a->zbuffer += len;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx], ecx

; 4194 : 	a->zout += len;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 4195 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 4196 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@stbi__pars:
	DD	1
	DD	$LN14@stbi__pars
$LN14@stbi__pars:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN13@stbi__pars
$LN13@stbi__pars:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?stbi__parse_uncompressed_block@@YAHPAUstbi__zbuf@@@Z ENDP ; stbi__parse_uncompressed_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
_fill$1 = -2625						; size = 1
_c$2 = -2616						; size = 4
_s$3 = -2604						; size = 4
_ntot$ = -2592						; size = 4
_hclen$ = -2580						; size = 4
_hdist$ = -2568						; size = 4
_hlit$ = -2556						; size = 4
_n$ = -2544						; size = 4
_i$ = -2532						; size = 4
_codelength_sizes$ = -2520				; size = 19
_lencodes$ = -2492					; size = 455
_z_codelength$ = -2028					; size = 2020
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
?stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z PROC	; stbi__compute_huffman_codes, COMDAT

; 4120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3784				; 00000ec8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-3784]
	mov	ecx, 946				; 000003b2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4121 : 	static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4122 : 	stbi__zhuffman z_codelength;
; 4123 : 	stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
; 4124 : 	stbi_uc codelength_sizes[19];
; 4125 : 	int i, n;
; 4126 : 
; 4127 : 	int hlit = stbi__zreceive(a, 5) + 257;

	push	5
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 257				; 00000101H
	mov	DWORD PTR _hlit$[ebp], eax

; 4128 : 	int hdist = stbi__zreceive(a, 5) + 1;

	push	5
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 1
	mov	DWORD PTR _hdist$[ebp], eax

; 4129 : 	int hclen = stbi__zreceive(a, 4) + 4;

	push	4
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 4
	mov	DWORD PTR _hclen$[ebp], eax

; 4130 : 	int ntot = hlit + hdist;

	mov	eax, DWORD PTR _hlit$[ebp]
	add	eax, DWORD PTR _hdist$[ebp]
	mov	DWORD PTR _ntot$[ebp], eax

; 4131 : 
; 4132 : 	memset(codelength_sizes, 0, sizeof(codelength_sizes));

	push	19					; 00000013H
	push	0
	lea	eax, DWORD PTR _codelength_sizes$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4133 : 	for (i = 0; i < hclen; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__comp
$LN2@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _hclen$[ebp]
	jge	SHORT $LN3@stbi__comp

; 4134 : 		int s = stbi__zreceive(a, 3);

	push	3
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	mov	DWORD PTR _s$3[ebp], eax

; 4135 : 		codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR ?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4QBEB[eax]
	mov	dl, BYTE PTR _s$3[ebp]
	mov	BYTE PTR _codelength_sizes$[ebp+ecx], dl

; 4136 : 	}

	jmp	SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4137 : 	if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	push	19					; 00000013H
	lea	eax, DWORD PTR _codelength_sizes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _z_codelength$[ebp]
	push	ecx
	call	?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ; stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@stbi__comp
	xor	eax, eax
	jmp	$LN1@stbi__comp
$LN7@stbi__comp:

; 4138 : 
; 4139 : 	n = 0;

	mov	DWORD PTR _n$[ebp], 0
$LN5@stbi__comp:

; 4140 : 	while (n < ntot) {

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _ntot$[ebp]
	jge	$LN6@stbi__comp

; 4141 : 		int c = stbi__zhuffman_decode(a, &z_codelength);

	lea	eax, DWORD PTR _z_codelength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _c$2[ebp], eax

; 4142 : 		if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	DWORD PTR _c$2[ebp], 0
	jl	SHORT $LN9@stbi__comp
	cmp	DWORD PTR _c$2[ebp], 19			; 00000013H
	jl	SHORT $LN8@stbi__comp
$LN9@stbi__comp:
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__comp
$LN8@stbi__comp:

; 4143 : 		if (c < 16)

	cmp	DWORD PTR _c$2[ebp], 16			; 00000010H
	jge	SHORT $LN10@stbi__comp

; 4144 : 			lencodes[n++] = (stbi_uc)c;

	mov	eax, DWORD PTR _n$[ebp]
	mov	cl, BYTE PTR _c$2[ebp]
	mov	BYTE PTR _lencodes$[ebp+eax], cl
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx
	jmp	$LN11@stbi__comp
$LN10@stbi__comp:

; 4145 : 		else {
; 4146 : 			stbi_uc fill = 0;

	mov	BYTE PTR _fill$1[ebp], 0

; 4147 : 			if (c == 16) {

	cmp	DWORD PTR _c$2[ebp], 16			; 00000010H
	jne	SHORT $LN12@stbi__comp

; 4148 : 				c = stbi__zreceive(a, 2) + 3;

	push	2
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 3
	mov	DWORD PTR _c$2[ebp], eax

; 4149 : 				if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN14@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__comp
$LN14@stbi__comp:

; 4150 : 				fill = lencodes[n - 1];

	mov	eax, DWORD PTR _n$[ebp]
	mov	cl, BYTE PTR _lencodes$[ebp+eax-1]
	mov	BYTE PTR _fill$1[ebp], cl

; 4151 : 			}

	jmp	SHORT $LN13@stbi__comp
$LN12@stbi__comp:

; 4152 : 			else if (c == 17)

	cmp	DWORD PTR _c$2[ebp], 17			; 00000011H
	jne	SHORT $LN15@stbi__comp

; 4153 : 				c = stbi__zreceive(a, 3) + 3;

	push	3
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 3
	mov	DWORD PTR _c$2[ebp], eax
	jmp	SHORT $LN13@stbi__comp
$LN15@stbi__comp:

; 4154 : 			else {
; 4155 : 				STBI_ASSERT(c == 18);

	cmp	DWORD PTR _c$2[ebp], 18			; 00000012H
	je	SHORT $LN22@stbi__comp
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z@4JA
	add	eax, 35					; 00000023H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1BA@NKONKNHF@?$AAc?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA8@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@stbi__comp:

; 4156 : 				c = stbi__zreceive(a, 7) + 11;

	push	7
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, 11					; 0000000bH
	mov	DWORD PTR _c$2[ebp], eax
$LN13@stbi__comp:

; 4157 : 			}
; 4158 : 			if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR _ntot$[ebp]
	sub	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _c$2[ebp]
	jge	SHORT $LN17@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__comp
$LN17@stbi__comp:

; 4159 : 			memset(lencodes + n, fill, c);

	mov	eax, DWORD PTR _c$2[ebp]
	push	eax
	movzx	ecx, BYTE PTR _fill$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR _lencodes$[ebp+edx]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4160 : 			n += c;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, DWORD PTR _c$2[ebp]
	mov	DWORD PTR _n$[ebp], eax
$LN11@stbi__comp:

; 4161 : 		}
; 4162 : 	}

	jmp	$LN5@stbi__comp
$LN6@stbi__comp:

; 4163 : 	if (n != ntot) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _ntot$[ebp]
	je	SHORT $LN18@stbi__comp
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__comp
$LN18@stbi__comp:

; 4164 : 	if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

	mov	eax, DWORD PTR _hlit$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lencodes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ; stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__comp
$LN19@stbi__comp:

; 4165 : 	if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;

	mov	eax, DWORD PTR _hdist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hlit$[ebp]
	lea	edx, DWORD PTR _lencodes$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	call	?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ; stbi__zbuild_huffman
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__comp
$LN20@stbi__comp:

; 4166 : 	return 1;

	mov	eax, 1
$LN1@stbi__comp:

; 4167 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@stbi__comp
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 3784				; 00000ec8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN27@stbi__comp:
	DD	3
	DD	$LN26@stbi__comp
$LN26@stbi__comp:
	DD	-2028					; fffff814H
	DD	2020					; 000007e4H
	DD	$LN23@stbi__comp
	DD	-2492					; fffff644H
	DD	455					; 000001c7H
	DD	$LN24@stbi__comp
	DD	-2520					; fffff628H
	DD	19					; 00000013H
	DD	$LN25@stbi__comp
$LN25@stbi__comp:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN24@stbi__comp:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN23@stbi__comp:
	DB	122					; 0000007aH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?stbi__compute_huffman_codes@@YAHPAUstbi__zbuf@@@Z ENDP	; stbi__compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_huffman_block@@YAHPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
_v$1 = -65						; size = 1
_dist$2 = -56						; size = 4
_len$3 = -44						; size = 4
_p$4 = -32						; size = 4
_z$5 = -20						; size = 4
_zout$ = -8						; size = 4
_a$ = 8							; size = 4
?stbi__parse_huffman_block@@YAHPAUstbi__zbuf@@@Z PROC	; stbi__parse_huffman_block, COMDAT

; 4076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4077 : 	char* zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN4@stbi__pars:

; 4078 : 	for (;;) {
; 4079 : 		int z = stbi__zhuffman_decode(a, &a->z_length);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _z$5[ebp], eax

; 4080 : 		if (z < 256) {

	cmp	DWORD PTR _z$5[ebp], 256		; 00000100H
	jge	SHORT $LN11@stbi__pars

; 4081 : 			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes

	cmp	DWORD PTR _z$5[ebp], 0
	jge	SHORT $LN13@stbi__pars
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN13@stbi__pars:

; 4082 : 			if (zout >= a->zout_end) {

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jb	SHORT $LN14@stbi__pars

; 4083 : 				if (!stbi__zexpand(a, zout, 1)) return 0;

	push	1
	mov	eax, DWORD PTR _zout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z ; stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN15@stbi__pars:

; 4084 : 				zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN14@stbi__pars:

; 4085 : 			}
; 4086 : 			*zout++ = (char)z;

	mov	eax, DWORD PTR _zout$[ebp]
	mov	cl, BYTE PTR _z$5[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _zout$[ebp]
	add	edx, 1
	mov	DWORD PTR _zout$[ebp], edx

; 4087 : 		}

	jmp	$LN12@stbi__pars
$LN11@stbi__pars:

; 4088 : 		else {
; 4089 : 			stbi_uc* p;
; 4090 : 			int len, dist;
; 4091 : 			if (z == 256) {

	cmp	DWORD PTR _z$5[ebp], 256		; 00000100H
	jne	SHORT $LN16@stbi__pars

; 4092 : 				a->zout = zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4093 : 				return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN16@stbi__pars:

; 4094 : 			}
; 4095 : 			z -= 257;

	mov	eax, DWORD PTR _z$5[ebp]
	sub	eax, 257				; 00000101H
	mov	DWORD PTR _z$5[ebp], eax

; 4096 : 			len = stbi__zlength_base[z];

	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR ?stbi__zlength_base@@3QBHB[eax*4]
	mov	DWORD PTR _len$3[ebp], ecx

; 4097 : 			if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

	mov	eax, DWORD PTR _z$5[ebp]
	cmp	DWORD PTR ?stbi__zlength_extra@@3QBHB[eax*4], 0
	je	SHORT $LN17@stbi__pars
	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR ?stbi__zlength_extra@@3QBHB[eax*4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, DWORD PTR _len$3[ebp]
	mov	DWORD PTR _len$3[ebp], eax
$LN17@stbi__pars:

; 4098 : 			z = stbi__zhuffman_decode(a, &a->z_distance);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	add	esp, 8
	mov	DWORD PTR _z$5[ebp], eax

; 4099 : 			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG");

	cmp	DWORD PTR _z$5[ebp], 0
	jge	SHORT $LN18@stbi__pars
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN18@stbi__pars:

; 4100 : 			dist = stbi__zdist_base[z];

	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR ?stbi__zdist_base@@3QBHB[eax*4]
	mov	DWORD PTR _dist$2[ebp], ecx

; 4101 : 			if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

	mov	eax, DWORD PTR _z$5[ebp]
	cmp	DWORD PTR ?stbi__zdist_extra@@3QBHB[eax*4], 0
	je	SHORT $LN19@stbi__pars
	mov	eax, DWORD PTR _z$5[ebp]
	mov	ecx, DWORD PTR ?stbi__zdist_extra@@3QBHB[eax*4]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	esp, 8
	add	eax, DWORD PTR _dist$2[ebp]
	mov	DWORD PTR _dist$2[ebp], eax
$LN19@stbi__pars:

; 4102 : 			if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _dist$2[ebp]
	jge	SHORT $LN20@stbi__pars
	push	OFFSET ??_C@_08DIAPIMGJ@bad?5dist@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__pars
$LN20@stbi__pars:

; 4103 : 			if (zout + len > a->zout_end) {

	mov	eax, DWORD PTR _zout$[ebp]
	add	eax, DWORD PTR _len$3[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR [ecx+24]
	jbe	SHORT $LN21@stbi__pars

; 4104 : 				if (!stbi__zexpand(a, zout, len)) return 0;

	mov	eax, DWORD PTR _len$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _zout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z ; stbi__zexpand
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN22@stbi__pars:

; 4105 : 				zout = a->zout;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _zout$[ebp], ecx
$LN21@stbi__pars:

; 4106 : 			}
; 4107 : 			p = (stbi_uc*)(zout - dist);

	mov	eax, DWORD PTR _zout$[ebp]
	sub	eax, DWORD PTR _dist$2[ebp]
	mov	DWORD PTR _p$4[ebp], eax

; 4108 : 			if (dist == 1) { // run of one byte; common in images.

	cmp	DWORD PTR _dist$2[ebp], 1
	jne	SHORT $LN23@stbi__pars

; 4109 : 				stbi_uc v = *p;

	mov	eax, DWORD PTR _p$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _v$1[ebp], cl

; 4110 : 				if (len) { do *zout++ = v; while (--len); }

	cmp	DWORD PTR _len$3[ebp], 0
	je	SHORT $LN25@stbi__pars
$LN7@stbi__pars:
	mov	eax, DWORD PTR _zout$[ebp]
	mov	cl, BYTE PTR _v$1[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _zout$[ebp]
	add	edx, 1
	mov	DWORD PTR _zout$[ebp], edx
	mov	eax, DWORD PTR _len$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$3[ebp], eax
	jne	SHORT $LN7@stbi__pars
$LN25@stbi__pars:

; 4111 : 			}

	jmp	SHORT $LN12@stbi__pars
$LN23@stbi__pars:

; 4112 : 			else {
; 4113 : 				if (len) { do *zout++ = *p++; while (--len); }

	cmp	DWORD PTR _len$3[ebp], 0
	je	SHORT $LN12@stbi__pars
$LN10@stbi__pars:
	mov	eax, DWORD PTR _zout$[ebp]
	mov	ecx, DWORD PTR _p$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _zout$[ebp]
	add	eax, 1
	mov	DWORD PTR _zout$[ebp], eax
	mov	ecx, DWORD PTR _p$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$4[ebp], ecx
	mov	eax, DWORD PTR _len$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$3[ebp], eax
	jne	SHORT $LN10@stbi__pars
$LN12@stbi__pars:

; 4114 : 			}
; 4115 : 		}
; 4116 : 	}

	jmp	$LN4@stbi__pars
$LN1@stbi__pars:

; 4117 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__parse_huffman_block@@YAHPAUstbi__zbuf@@@Z ENDP	; stbi__parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z
_TEXT	SEGMENT
_old_limit$ = -44					; size = 4
_limit$ = -32						; size = 4
_cur$ = -20						; size = 4
_q$ = -8						; size = 4
_z$ = 8							; size = 4
_zout$ = 12						; size = 4
_n$ = 16						; size = 4
?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z PROC		; stbi__zexpand, COMDAT

; 4043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4044 : 	char* q;
; 4045 : 	int cur, limit, old_limit;
; 4046 : 	z->zout = zout;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _zout$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4047 : 	if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN4@stbi__zexp
	push	OFFSET ??_C@_0BE@IBFIPFO@output?5buffer?5limit@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__zexp
$LN4@stbi__zexp:

; 4048 : 	cur = (int)(z->zout - z->zout_start);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cur$[ebp], edx

; 4049 : 	limit = old_limit = (int)(z->zout_end - z->zout_start);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _old_limit$[ebp], edx
	mov	eax, DWORD PTR _old_limit$[ebp]
	mov	DWORD PTR _limit$[ebp], eax
$LN2@stbi__zexp:

; 4050 : 	while (cur + n > limit)

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _limit$[ebp]
	jle	SHORT $LN3@stbi__zexp

; 4051 : 		limit *= 2;

	mov	eax, DWORD PTR _limit$[ebp]
	shl	eax, 1
	mov	DWORD PTR _limit$[ebp], eax
	jmp	SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 4052 : 	q = (char*)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

	mov	esi, esp
	mov	eax, DWORD PTR _limit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _q$[ebp], eax

; 4053 : 	STBI_NOTUSED(old_limit);
; 4054 : 	if (q == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	DWORD PTR _q$[ebp], 0
	jne	SHORT $LN5@stbi__zexp
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__zexp
$LN5@stbi__zexp:

; 4055 : 	z->zout_start = q;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4056 : 	z->zout = q + cur;

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 4057 : 	z->zout_end = q + limit;

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, DWORD PTR _limit$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 4058 : 	return 1;

	mov	eax, 1
$LN1@stbi__zexp:

; 4059 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__zexpand@@YAHPAUstbi__zbuf@@PADH@Z ENDP		; stbi__zexpand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z
_TEXT	SEGMENT
_s$ = -20						; size = 4
_b$ = -8						; size = 4
_a$ = 8							; size = 4
_z$ = 12						; size = 4
?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode, COMDAT

; 4029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4030 : 	int b, s;
; 4031 : 	if (a->num_bits < 16) stbi__fill_bits(a);

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+8], 16			; 00000010H
	jge	SHORT $LN2@stbi__zhuf
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z	; stbi__fill_bits
	add	esp, 4
$LN2@stbi__zhuf:

; 4032 : 	b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 511				; 000001ffH
	mov	edx, DWORD PTR _z$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	mov	DWORD PTR _b$[ebp], eax

; 4033 : 	if (b) {

	cmp	DWORD PTR _b$[ebp], 0
	je	SHORT $LN3@stbi__zhuf

; 4034 : 		s = b >> 9;

	mov	eax, DWORD PTR _b$[ebp]
	sar	eax, 9
	mov	DWORD PTR _s$[ebp], eax

; 4035 : 		a->code_buffer >>= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _s$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], edx

; 4036 : 		a->num_bits -= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4037 : 		return b & 511;

	mov	eax, DWORD PTR _b$[ebp]
	and	eax, 511				; 000001ffH
	jmp	SHORT $LN1@stbi__zhuf
$LN3@stbi__zhuf:

; 4038 : 	}
; 4039 : 	return stbi__zhuffman_decode_slowpath(a, z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
	add	esp, 8
$LN1@stbi__zhuf:

; 4040 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__zhuffman_decode@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z
_TEXT	SEGMENT
_k$ = -32						; size = 4
_s$ = -20						; size = 4
_b$ = -8						; size = 4
_a$ = 8							; size = 4
_z$ = 12						; size = 4
?stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode_slowpath, COMDAT

; 4011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4012 : 	int b, s, k;
; 4013 : 	// not resolved by fast table, so compute it the slow way
; 4014 : 	// use jpeg approach, which requires MSbits at top
; 4015 : 	k = stbi__bit_reverse(a->code_buffer, 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?stbi__bit_reverse@@YAHHH@Z		; stbi__bit_reverse
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 4016 : 	for (s = STBI__ZFAST_BITS + 1; ; ++s)

	mov	DWORD PTR _s$[ebp], 10			; 0000000aH
	jmp	SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN4@stbi__zhuf:

; 4017 : 		if (k < z->maxcode[s])

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+1056]
	jge	SHORT $LN5@stbi__zhuf

; 4018 : 			break;

	jmp	SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
	jmp	SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 4019 : 	if (s == 16) return -1; // invalid code!

	cmp	DWORD PTR _s$[ebp], 16			; 00000010H
	jne	SHORT $LN6@stbi__zhuf
	or	eax, -1
	jmp	$LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 4020 : 	// code size is s, so:
; 4021 : 	b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+1024]
	sub	eax, ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [ecx+edx*2+1124]
	add	eax, edx
	mov	DWORD PTR _b$[ebp], eax

; 4022 : 	STBI_ASSERT(z->size[b] == s);

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	movzx	ecx, BYTE PTR [eax+1156]
	cmp	ecx, DWORD PTR _s$[ebp]
	je	SHORT $LN8@stbi__zhuf
	mov	edx, DWORD PTR ?__LINE__Var@?0??stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z@4JA
	add	edx, 11					; 0000000bH
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CA@BMLMNMFI@?$AAz?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$FL?$AAb?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@stbi__zhuf:

; 4023 : 	a->code_buffer >>= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _s$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax+12], edx

; 4024 : 	a->num_bits -= s;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4025 : 	return z->value[b];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2+1444]
$LN1@stbi__zhuf:

; 4026 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__zhuffman_decode_slowpath@@YAHPAUstbi__zbuf@@PAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode_slowpath
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z
_TEXT	SEGMENT
_k$ = -8						; size = 4
_z$ = 8							; size = 4
_n$ = 12						; size = 4
?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z PROC		; stbi__zreceive, COMDAT

; 4001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4002 : 	unsigned int k;
; 4003 : 	if (z->num_bits < n) stbi__fill_bits(z);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@stbi__zrec
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z	; stbi__fill_bits
	add	esp, 4
$LN2@stbi__zrec:

; 4004 : 	k = z->code_buffer & ((1 << n) - 1);

	mov	eax, 1
	mov	ecx, DWORD PTR _n$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _z$[ebp]
	and	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _k$[ebp], eax

; 4005 : 	z->code_buffer >>= n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _n$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], edx

; 4006 : 	z->num_bits -= n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 4007 : 	return k;

	mov	eax, DWORD PTR _k$[ebp]

; 4008 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__zreceive@@YAIPAUstbi__zbuf@@H@Z ENDP		; stbi__zreceive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
_z$ = 8							; size = 4
?stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z PROC		; stbi__fill_bits, COMDAT

; 3992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
$LN4@stbi__fill:

; 3993 : 	do {
; 3994 : 		STBI_ASSERT(z->code_buffer < (1U << z->num_bits));

	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+8]
	shl	edx, cl
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jb	SHORT $LN6@stbi__fill
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z@4JA
	add	ecx, 2
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1EK@GAHNONBJ@?$AAz?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@stbi__fill:

; 3995 : 		z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__zget8@@YAEPAUstbi__zbuf@@@Z	; stbi__zget8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	edx, cl
	mov	ecx, DWORD PTR _z$[ebp]
	or	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+12], edx

; 3996 : 		z->num_bits += 8;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 8
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3997 : 	} while (z->num_bits <= 24);

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+8], 24			; 00000018H
	jle	SHORT $LN4@stbi__fill

; 3998 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__fill_bits@@YAXPAUstbi__zbuf@@@Z ENDP		; stbi__fill_bits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zget8@@YAEPAUstbi__zbuf@@@Z
_TEXT	SEGMENT
tv72 = -193						; size = 1
_z$ = 8							; size = 4
?stbi__zget8@@YAEPAUstbi__zbuf@@@Z PROC			; stbi__zget8, COMDAT

; 3986 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3987 : 	if (z->zbuffer >= z->zbuffer_end) return 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN2@stbi__zget
	xor	al, al
	jmp	SHORT $LN1@stbi__zget
$LN2@stbi__zget:

; 3988 : 	return *z->zbuffer++;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	al, BYTE PTR tv72[ebp]
$LN1@stbi__zget:

; 3989 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__zget8@@YAEPAUstbi__zbuf@@@Z ENDP			; stbi__zget8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z
_TEXT	SEGMENT
_j$1 = -232						; size = 4
_fastv$2 = -220						; size = 2
_c$3 = -208						; size = 4
_s$4 = -196						; size = 4
_sizes$ = -184						; size = 68
_next_code$ = -108					; size = 64
_code$ = -36						; size = 4
_k$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_sizelist$ = 12						; size = 4
_num$ = 16						; size = 4
?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z PROC ; stbi__zbuild_huffman, COMDAT

; 3919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-428]
	mov	ecx, 107				; 0000006bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3920 : 	int i, k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 3921 : 	int code, next_code[16], sizes[17];
; 3922 : 
; 3923 : 	// DEFLATE spec for generating codes
; 3924 : 	memset(sizes, 0, sizeof(sizes));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _sizes$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3925 : 	memset(z->fast, 0, sizeof(z->fast));

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3926 : 	for (i = 0; i < num; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	SHORT $LN3@stbi__zbui

; 3927 : 		++sizes[sizelist[i]];

	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _sizes$[ebp+ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _sizes$[ebp+ecx*4], edx
	jmp	SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 3928 : 	sizes[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _sizes$[ebp+ecx], 0

; 3929 : 	for (i = 1; i < 16; ++i)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__zbui:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN6@stbi__zbui

; 3930 : 		if (sizes[i] > (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _sizes$[ebp+ecx*4], eax
	jle	SHORT $LN16@stbi__zbui

; 3931 : 			return stbi__err("bad sizes", "Corrupt PNG");

	push	OFFSET ??_C@_09EOHLEIKL@bad?5sizes@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__zbui
$LN16@stbi__zbui:
	jmp	SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 3932 : 	code = 0;

	mov	DWORD PTR _code$[ebp], 0

; 3933 : 	for (i = 1; i < 16; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__zbui:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN9@stbi__zbui

; 3934 : 		next_code[i] = code;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	mov	DWORD PTR _next_code$[ebp+eax*4], ecx

; 3935 : 		z->firstcode[i] = (stbi__uint16)code;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _code$[ebp]
	mov	WORD PTR [ecx+eax*2+1024], dx

; 3936 : 		z->firstsymbol[i] = (stbi__uint16)k;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx+eax*2+1124], dx

; 3937 : 		code = (code + sizes[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, DWORD PTR _sizes$[ebp+eax*4]
	mov	DWORD PTR _code$[ebp], ecx

; 3938 : 		if (sizes[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _sizes$[ebp+eax*4], 0
	je	SHORT $LN17@stbi__zbui

; 3939 : 			if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR _code$[ebp]
	sub	eax, 1
	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN17@stbi__zbui
	push	OFFSET ??_C@_0BA@MDNKOBMC@bad?5codelengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__zbui
$LN17@stbi__zbui:

; 3940 : 		z->maxcode[i] = code << (16 - i); // preshift for inner loop

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx*4+1056], eax

; 3941 : 		code <<= 1;

	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, 1
	mov	DWORD PTR _code$[ebp], eax

; 3942 : 		k += sizes[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, DWORD PTR _sizes$[ebp+eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 3943 : 	}

	jmp	$LN8@stbi__zbui
$LN9@stbi__zbui:

; 3944 : 	z->maxcode[16] = 0x10000; // sentinel

	mov	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+1056], 65536		; 00010000H

; 3945 : 	for (i = 0; i < num; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@stbi__zbui:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	$LN12@stbi__zbui

; 3946 : 		int s = sizelist[i];

	mov	eax, DWORD PTR _sizelist$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _s$4[ebp], ecx

; 3947 : 		if (s) {

	cmp	DWORD PTR _s$4[ebp], 0
	je	$LN19@stbi__zbui

; 3948 : 			int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+1024]
	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _next_code$[ebp+eax*4]
	sub	ecx, edx
	mov	edx, DWORD PTR _s$4[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	movzx	edx, WORD PTR [eax+edx*2+1124]
	add	ecx, edx
	mov	DWORD PTR _c$3[ebp], ecx

; 3949 : 			stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);

	mov	eax, DWORD PTR _s$4[ebp]
	shl	eax, 9
	or	eax, DWORD PTR _i$[ebp]
	mov	WORD PTR _fastv$2[ebp], ax

; 3950 : 			z->size[c] = (stbi_uc)s;

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _c$3[ebp]
	mov	cl, BYTE PTR _s$4[ebp]
	mov	BYTE PTR [eax+1156], cl

; 3951 : 			z->value[c] = (stbi__uint16)i;

	mov	eax, DWORD PTR _c$3[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR [ecx+eax*2+1444], dx

; 3952 : 			if (s <= STBI__ZFAST_BITS) {

	cmp	DWORD PTR _s$4[ebp], 9
	jg	SHORT $LN20@stbi__zbui

; 3953 : 				int j = stbi__bit_reverse(next_code[s], s);

	mov	eax, DWORD PTR _s$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$4[ebp]
	mov	edx, DWORD PTR _next_code$[ebp+ecx*4]
	push	edx
	call	?stbi__bit_reverse@@YAHHH@Z		; stbi__bit_reverse
	add	esp, 8
	mov	DWORD PTR _j$1[ebp], eax
$LN14@stbi__zbui:

; 3954 : 				while (j < (1 << STBI__ZFAST_BITS)) {

	cmp	DWORD PTR _j$1[ebp], 512		; 00000200H
	jge	SHORT $LN20@stbi__zbui

; 3955 : 					z->fast[j] = fastv;

	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	dx, WORD PTR _fastv$2[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 3956 : 					j += (1 << s);

	mov	eax, 1
	mov	ecx, DWORD PTR _s$4[ebp]
	shl	eax, cl
	add	eax, DWORD PTR _j$1[ebp]
	mov	DWORD PTR _j$1[ebp], eax

; 3957 : 				}

	jmp	SHORT $LN14@stbi__zbui
$LN20@stbi__zbui:

; 3958 : 			}
; 3959 : 			++next_code[s];

	mov	eax, DWORD PTR _s$4[ebp]
	mov	ecx, DWORD PTR _next_code$[ebp+eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _s$4[ebp]
	mov	DWORD PTR _next_code$[ebp+edx*4], ecx
$LN19@stbi__zbui:

; 3960 : 		}
; 3961 : 	}

	jmp	$LN11@stbi__zbui
$LN12@stbi__zbui:

; 3962 : 	return 1;

	mov	eax, 1
$LN1@stbi__zbui:

; 3963 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@stbi__zbui
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 428				; 000001acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN25@stbi__zbui:
	DD	2
	DD	$LN24@stbi__zbui
$LN24@stbi__zbui:
	DD	-108					; ffffff94H
	DD	64					; 00000040H
	DD	$LN22@stbi__zbui
	DD	-184					; ffffff48H
	DD	68					; 00000044H
	DD	$LN23@stbi__zbui
$LN23@stbi__zbui:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN22@stbi__zbui:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?stbi__zbuild_huffman@@YAHPAUstbi__zhuffman@@PBEH@Z ENDP ; stbi__zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bit_reverse@@YAHHH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_bits$ = 12						; size = 4
?stbi__bit_reverse@@YAHHH@Z PROC			; stbi__bit_reverse, COMDAT

; 3911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3912 : 	STBI_ASSERT(bits <= 16);

	cmp	DWORD PTR _bits$[ebp], 16		; 00000010H
	jle	SHORT $LN3@stbi__bit_
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__bit_reverse@@YAHHH@Z@4JA
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@stbi__bit_:

; 3913 : 	// to bit reverse n bits, reverse 16 and shift
; 3914 : 	// e.g. 11 bits, bit reverse and shift away 5
; 3915 : 	return stbi__bitreverse16(v) >> (16 - bits);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	?stbi__bitreverse16@@YAHH@Z		; stbi__bitreverse16
	add	esp, 4
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _bits$[ebp]
	sar	eax, cl

; 3916 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bit_reverse@@YAHHH@Z ENDP			; stbi__bit_reverse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bitreverse16@@YAHH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?stbi__bitreverse16@@YAHH@Z PROC			; stbi__bitreverse16, COMDAT

; 3902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3903 : 	n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 43690				; 0000aaaaH
	sar	eax, 1
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 21845				; 00005555H
	shl	ecx, 1
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3904 : 	n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 52428				; 0000ccccH
	sar	eax, 2
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 13107				; 00003333H
	shl	ecx, 2
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3905 : 	n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 61680				; 0000f0f0H
	sar	eax, 4
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 3855				; 00000f0fH
	shl	ecx, 4
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3906 : 	n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);

	mov	eax, DWORD PTR _n$[ebp]
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 3907 : 	return n;

	mov	eax, DWORD PTR _n$[ebp]

; 3908 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bitreverse16@@YAHH@Z ENDP			; stbi__bitreverse16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_info_raw@@YAHPAUstbi__jpeg@@PAH11@Z
_TEXT	SEGMENT
tv80 = -196						; size = 4
_j$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__jpeg_info_raw@@YAHPAUstbi__jpeg@@PAH11@Z PROC	; stbi__jpeg_info_raw, COMDAT

; 3854 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3855 : 	if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

	push	2
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@stbi__jpeg

; 3856 : 		stbi__rewind(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 3857 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3858 : 	}
; 3859 : 	if (x)* x = j->s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN3@stbi__jpeg:

; 3860 : 	if (y)* y = j->s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@stbi__jpeg:

; 3861 : 	if (comp)* comp = j->s->img_n >= 3 ? 3 : 1;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN5@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jl	SHORT $LN7@stbi__jpeg
	mov	DWORD PTR tv80[ebp], 3
	jmp	SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
	mov	DWORD PTR tv80[ebp], 1
$LN8@stbi__jpeg:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR [edx], eax
$LN5@stbi__jpeg:

; 3862 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 3863 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_info_raw@@YAHPAUstbi__jpeg@@PAH11@Z ENDP	; stbi__jpeg_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?load_jpeg_image@@YAPAEPAUstbi__jpeg@@PAH11H@Z
_TEXT	SEGMENT
tv258 = -592						; size = 4
tv79 = -592						; size = 4
tv648 = -588						; size = 4
tv275 = -588						; size = 4
tv267 = -588						; size = 4
tv253 = -588						; size = 4
tv241 = -588						; size = 4
tv223 = -588						; size = 4
tv153 = -588						; size = 4
tv91 = -588						; size = 4
tv81 = -588						; size = 4
tv71 = -588						; size = 4
_y$1 = -388						; size = 4
_b$2 = -373						; size = 1
_g$3 = -361						; size = 1
_r$4 = -349						; size = 1
_m$5 = -337						; size = 1
_m$6 = -325						; size = 1
_m$7 = -313						; size = 1
_y$8 = -304						; size = 4
_y_bot$9 = -292						; size = 4
_r$10 = -280						; size = 4
_out$11 = -268						; size = 4
_r$12 = -256						; size = 4
_res_comp$13 = -244					; size = 128
_coutput$14 = -108					; size = 16
_output$15 = -84					; size = 4
_j$16 = -72						; size = 4
_i$17 = -60						; size = 4
_k$18 = -48						; size = 4
_is_rgb$ = -36						; size = 4
_decode_n$ = -24					; size = 4
_n$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_out_x$ = 12						; size = 4
_out_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?load_jpeg_image@@YAPAEPAUstbi__jpeg@@PAH11H@Z PROC	; load_jpeg_image, COMDAT

; 3662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-592]
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3663 : 	int n, decode_n, is_rgb;
; 3664 : 	z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], 0

; 3665 : 
; 3666 : 	// validate req_comp
; 3667 : 	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR _req_comp$[ebp], 0
	jl	SHORT $LN42@load_jpeg_
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN41@load_jpeg_
$LN42@load_jpeg_:
	push	OFFSET ??_C@_0N@KBPNPPBJ@bad?5req_comp@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN82@load_jpeg_
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN83@load_jpeg_
$LN82@load_jpeg_:
	mov	DWORD PTR tv71[ebp], 0
$LN83@load_jpeg_:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	$LN1@load_jpeg_
$LN41@load_jpeg_:

; 3668 : 
; 3669 : 	// load a jpeg image from whichever source, but leave in YCbCr format
; 3670 : 	if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__decode_jpeg_image@@YAHPAUstbi__jpeg@@@Z ; stbi__decode_jpeg_image
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN43@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN43@load_jpeg_:

; 3671 : 
; 3672 : 	// determine actual number of components to generate
; 3673 : 	n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN86@load_jpeg_
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN87@load_jpeg_
$LN86@load_jpeg_:
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+8], 3
	jl	SHORT $LN84@load_jpeg_
	mov	DWORD PTR tv79[ebp], 3
	jmp	SHORT $LN85@load_jpeg_
$LN84@load_jpeg_:
	mov	DWORD PTR tv79[ebp], 1
$LN85@load_jpeg_:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN87@load_jpeg_:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 3674 : 
; 3675 : 	is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	SHORT $LN88@load_jpeg_
	mov	edx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [edx+18412], 3
	je	SHORT $LN89@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	SHORT $LN88@load_jpeg_
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+18404], 0
	jne	SHORT $LN88@load_jpeg_
$LN89@load_jpeg_:
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN91@load_jpeg_
$LN88@load_jpeg_:
	mov	DWORD PTR tv91[ebp], 0
$LN91@load_jpeg_:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _is_rgb$[ebp], edx

; 3676 : 
; 3677 : 	if (z->s->img_n == 3 && n < 3 && !is_rgb)

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	SHORT $LN44@load_jpeg_
	cmp	DWORD PTR _n$[ebp], 3
	jge	SHORT $LN44@load_jpeg_
	cmp	DWORD PTR _is_rgb$[ebp], 0
	jne	SHORT $LN44@load_jpeg_

; 3678 : 		decode_n = 1;

	mov	DWORD PTR _decode_n$[ebp], 1
	jmp	SHORT $LN45@load_jpeg_
$LN44@load_jpeg_:

; 3679 : 	else
; 3680 : 		decode_n = z->s->img_n;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _decode_n$[ebp], edx
$LN45@load_jpeg_:

; 3681 : 
; 3682 : 	// resample and color-convert
; 3683 : 	{
; 3684 : 		int k;
; 3685 : 		unsigned int i, j;
; 3686 : 		stbi_uc* output;
; 3687 : 		stbi_uc* coutput[4] = { NULL, NULL, NULL, NULL };

	mov	DWORD PTR _coutput$14[ebp], 0
	mov	DWORD PTR _coutput$14[ebp+4], 0
	mov	DWORD PTR _coutput$14[ebp+8], 0
	mov	DWORD PTR _coutput$14[ebp+12], 0

; 3688 : 
; 3689 : 		stbi__resample res_comp[4];
; 3690 : 
; 3691 : 		for (k = 0; k < decode_n; ++k) {

	mov	DWORD PTR _k$18[ebp], 0
	jmp	SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	add	eax, 1
	mov	DWORD PTR _k$18[ebp], eax
$LN4@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	cmp	eax, DWORD PTR _decode_n$[ebp]
	jge	$LN3@load_jpeg_

; 3692 : 			stbi__resample* r = &res_comp[k];

	mov	eax, DWORD PTR _k$18[ebp]
	shl	eax, 5
	lea	ecx, DWORD PTR _res_comp$13[ebp+eax]
	mov	DWORD PTR _r$12[ebp], ecx

; 3693 : 
; 3694 : 			// allocate line buffer big enough for upsampling off the edges
; 3695 : 			// with upsample factor of 4
; 3696 : 			z->img_comp[k].linebuf = (stbi_uc*)stbi__malloc(z->s->img_x + 3);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	add	edx, 3
	push	edx
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18132], eax

; 3697 : 			if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18132], 0
	jne	SHORT $LN46@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	add	esp, 4
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN92@load_jpeg_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN93@load_jpeg_
$LN92@load_jpeg_:
	mov	DWORD PTR tv153[ebp], 0
$LN93@load_jpeg_:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN1@load_jpeg_
$LN46@load_jpeg_:

; 3698 : 
; 3699 : 			r->hs = z->img_h_max / z->img_comp[k].h;

	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18052]
	cdq
	idiv	DWORD PTR [esi+ecx+18080]
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [ecx+12], eax

; 3700 : 			r->vs = z->img_v_max / z->img_comp[k].v;

	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18056]
	cdq
	idiv	DWORD PTR [esi+ecx+18084]
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3701 : 			r->ystep = r->vs >> 1;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sar	ecx, 1
	mov	edx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [edx+24], ecx

; 3702 : 			r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _r$12[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [edx+20], eax

; 3703 : 			r->ypos = 0;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax+28], 0

; 3704 : 			r->line0 = r->line1 = z->img_comp[k].data;

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+eax+18120]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _r$12[ebp]
	mov	edx, DWORD PTR _r$12[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 3705 : 
; 3706 : 			if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN47@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN47@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET ?resample_row_1@@YAPAEPAE00HH@Z ; resample_row_1
	jmp	$LN48@load_jpeg_
$LN47@load_jpeg_:

; 3707 : 			else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN49@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN49@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET ?stbi__resample_row_v_2@@YAPAEPAE00HH@Z ; stbi__resample_row_v_2
	jmp	SHORT $LN48@load_jpeg_
$LN49@load_jpeg_:

; 3708 : 			else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN51@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN51@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET ?stbi__resample_row_h_2@@YAPAEPAE00HH@Z ; stbi__resample_row_h_2
	jmp	SHORT $LN48@load_jpeg_
$LN51@load_jpeg_:

; 3709 : 			else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN53@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN53@load_jpeg_
	mov	eax, DWORD PTR _r$12[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18452]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN48@load_jpeg_
$LN53@load_jpeg_:

; 3710 : 			else                               r->resample = stbi__resample_row_generic;

	mov	eax, DWORD PTR _r$12[ebp]
	mov	DWORD PTR [eax], OFFSET ?stbi__resample_row_generic@@YAPAEPAE00HH@Z ; stbi__resample_row_generic
$LN48@load_jpeg_:

; 3711 : 		}

	jmp	$LN2@load_jpeg_
$LN3@load_jpeg_:

; 3712 : 
; 3713 : 		// can't error after this so, this is safe
; 3714 : 		output = (stbi_uc*)stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

	push	1
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _output$15[ebp], eax

; 3715 : 		if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	cmp	DWORD PTR _output$15[ebp], 0
	jne	SHORT $LN55@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	add	esp, 4
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN94@load_jpeg_
	mov	DWORD PTR tv223[ebp], 0
	jmp	SHORT $LN95@load_jpeg_
$LN94@load_jpeg_:
	mov	DWORD PTR tv223[ebp], 0
$LN95@load_jpeg_:
	mov	eax, DWORD PTR tv223[ebp]
	jmp	$LN1@load_jpeg_
$LN55@load_jpeg_:

; 3716 : 
; 3717 : 		// now go ahead and resample
; 3718 : 		for (j = 0; j < z->s->img_y; ++j) {

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
	mov	eax, DWORD PTR _j$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$16[ebp], eax
$LN7@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$16[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	$LN6@load_jpeg_

; 3719 : 			stbi_uc* out = output + n * z->s->img_x * j;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	imul	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _j$16[ebp]
	add	edx, DWORD PTR _output$15[ebp]
	mov	DWORD PTR _out$11[ebp], edx

; 3720 : 			for (k = 0; k < decode_n; ++k) {

	mov	DWORD PTR _k$18[ebp], 0
	jmp	SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	add	eax, 1
	mov	DWORD PTR _k$18[ebp], eax
$LN10@load_jpeg_:
	mov	eax, DWORD PTR _k$18[ebp]
	cmp	eax, DWORD PTR _decode_n$[ebp]
	jge	$LN9@load_jpeg_

; 3721 : 				stbi__resample* r = &res_comp[k];

	mov	eax, DWORD PTR _k$18[ebp]
	shl	eax, 5
	lea	ecx, DWORD PTR _res_comp$13[ebp+eax]
	mov	DWORD PTR _r$10[ebp], ecx

; 3722 : 				int y_bot = r->ystep >= (r->vs >> 1);

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sar	ecx, 1
	mov	edx, DWORD PTR _r$10[ebp]
	cmp	DWORD PTR [edx+24], ecx
	jl	SHORT $LN96@load_jpeg_
	mov	DWORD PTR tv241[ebp], 1
	jmp	SHORT $LN97@load_jpeg_
$LN96@load_jpeg_:
	mov	DWORD PTR tv241[ebp], 0
$LN97@load_jpeg_:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR _y_bot$9[ebp], eax

; 3723 : 				coutput[k] = r->resample(z->img_comp[k].linebuf,

	cmp	DWORD PTR _y_bot$9[ebp], 0
	je	SHORT $LN98@load_jpeg_
	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv253[ebp], ecx
	jmp	SHORT $LN99@load_jpeg_
$LN98@load_jpeg_:
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv253[ebp], eax
$LN99@load_jpeg_:
	cmp	DWORD PTR _y_bot$9[ebp], 0
	je	SHORT $LN100@load_jpeg_
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv258[ebp], edx
	jmp	SHORT $LN101@load_jpeg_
$LN100@load_jpeg_:
	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv258[ebp], ecx
$LN101@load_jpeg_:
	mov	esi, esp
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR tv253[ebp]
	push	eax
	mov	ecx, DWORD PTR tv258[ebp]
	push	ecx
	imul	edx, DWORD PTR _k$18[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+edx+18132]
	push	ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _k$18[ebp]
	mov	DWORD PTR _coutput$14[ebp+ecx*4], eax

; 3724 : 					y_bot ? r->line1 : r->line0,
; 3725 : 					y_bot ? r->line0 : r->line1,
; 3726 : 					r->w_lores, r->hs);
; 3727 : 				if (++r->ystep >= r->vs) {

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv267[ebp], ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR tv267[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR tv267[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jl	SHORT $LN56@load_jpeg_

; 3728 : 					r->ystep = 0;

	mov	eax, DWORD PTR _r$10[ebp]
	mov	DWORD PTR [eax+24], 0

; 3729 : 					r->line0 = r->line1;

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 3730 : 					if (++r->ypos < z->img_comp[k].y)

	mov	eax, DWORD PTR _r$10[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	DWORD PTR tv275[ebp], ecx
	mov	edx, DWORD PTR _r$10[ebp]
	mov	eax, DWORD PTR tv275[ebp]
	mov	DWORD PTR [edx+28], eax
	imul	ecx, DWORD PTR _k$18[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR tv275[ebp]
	cmp	eax, DWORD PTR [edx+ecx+18108]
	jge	SHORT $LN56@load_jpeg_

; 3731 : 						r->line1 += z->img_comp[k].w2;

	imul	eax, DWORD PTR _k$18[ebp], 72
	mov	ecx, DWORD PTR _r$10[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _z$[ebp]
	add	edx, DWORD PTR [ecx+eax+18112]
	mov	eax, DWORD PTR _r$10[ebp]
	mov	DWORD PTR [eax+8], edx
$LN56@load_jpeg_:

; 3732 : 				}
; 3733 : 			}

	jmp	$LN8@load_jpeg_
$LN9@load_jpeg_:

; 3734 : 			if (n >= 3) {

	cmp	DWORD PTR _n$[ebp], 3
	jl	$LN58@load_jpeg_

; 3735 : 				stbi_uc* y = coutput[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	DWORD PTR _y$8[ebp], edx

; 3736 : 				if (z->s->img_n == 3) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jne	$LN60@load_jpeg_

; 3737 : 					if (is_rgb) {

	cmp	DWORD PTR _is_rgb$[ebp], 0
	je	$LN62@load_jpeg_

; 3738 : 						for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN13@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN12@load_jpeg_

; 3739 : 							out[0] = y[i];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _y$8[ebp]
	add	edx, DWORD PTR _i$17[ebp]
	mov	eax, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl

; 3740 : 							out[1] = coutput[1][i];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+edx], cl

; 3741 : 							out[2] = coutput[2][i];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+edx], cl

; 3742 : 							out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3743 : 							out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3744 : 						}

	jmp	$LN11@load_jpeg_
$LN12@load_jpeg_:

; 3745 : 					}

	jmp	SHORT $LN63@load_jpeg_
$LN62@load_jpeg_:

; 3746 : 					else {
; 3747 : 						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN63@load_jpeg_:

; 3748 : 					}
; 3749 : 				}

	jmp	$LN61@load_jpeg_
$LN60@load_jpeg_:

; 3750 : 				else if (z->s->img_n == 4) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN64@load_jpeg_

; 3751 : 					if (z->app14_color_transform == 0) { // CMYK

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	$LN66@load_jpeg_

; 3752 : 						for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN16@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN15@load_jpeg_

; 3753 : 							stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$7[ebp], cl

; 3754 : 							out[0] = stbi__blinn_8x8(coutput[0][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _coutput$14[ebp+edx]
	mov	ecx, DWORD PTR _i$17[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3755 : 							out[1] = stbi__blinn_8x8(coutput[1][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3756 : 							out[2] = stbi__blinn_8x8(coutput[2][i], m);

	movzx	eax, BYTE PTR _m$7[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3757 : 							out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3758 : 							out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3759 : 						}

	jmp	$LN14@load_jpeg_
$LN15@load_jpeg_:

; 3760 : 					}

	jmp	$LN67@load_jpeg_
$LN66@load_jpeg_:

; 3761 : 					else if (z->app14_color_transform == 2) { // YCCK

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 2
	jne	$LN68@load_jpeg_

; 3762 : 						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3763 : 						for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN19@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN18@load_jpeg_

; 3764 : 							stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$6[ebp], cl

; 3765 : 							out[0] = stbi__blinn_8x8(255 - out[0], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$11[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	push	edx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3766 : 							out[1] = stbi__blinn_8x8(255 - out[1], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$11[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3767 : 							out[2] = stbi__blinn_8x8(255 - out[2], m);

	movzx	eax, BYTE PTR _m$6[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$11[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3768 : 							out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3769 : 						}

	jmp	$LN17@load_jpeg_
$LN18@load_jpeg_:

; 3770 : 					}

	jmp	SHORT $LN67@load_jpeg_
$LN68@load_jpeg_:

; 3771 : 					else { // YCbCr + alpha?  Ignore the fourth channel for now
; 3772 : 						z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _out$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+18448]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN67@load_jpeg_:

; 3773 : 					}
; 3774 : 				}

	jmp	$LN61@load_jpeg_
$LN64@load_jpeg_:

; 3775 : 				else
; 3776 : 					for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN22@load_jpeg_
$LN20@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN22@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN61@load_jpeg_

; 3777 : 						out[0] = out[1] = out[2] = y[i];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _y$8[ebp]
	add	ecx, DWORD PTR _i$17[ebp]
	mov	edx, DWORD PTR _out$11[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	esi, DWORD PTR _out$11[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 3778 : 						out[3] = 255; // not used if n==3

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3779 : 						out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3780 : 					}

	jmp	$LN20@load_jpeg_
$LN61@load_jpeg_:

; 3781 : 			}

	jmp	$LN59@load_jpeg_
$LN58@load_jpeg_:

; 3782 : 			else {
; 3783 : 				if (is_rgb) {

	cmp	DWORD PTR _is_rgb$[ebp], 0
	je	$LN70@load_jpeg_

; 3784 : 					if (n == 1)

	cmp	DWORD PTR _n$[ebp], 1
	jne	SHORT $LN72@load_jpeg_

; 3785 : 						for (i = 0; i < z->s->img_x; ++i)

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN25@load_jpeg_
$LN23@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN25@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN24@load_jpeg_

; 3786 : 							* out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$11[ebp]
	add	edx, 1
	mov	DWORD PTR _out$11[ebp], edx
	jmp	SHORT $LN23@load_jpeg_
$LN24@load_jpeg_:
	jmp	$LN73@load_jpeg_
$LN72@load_jpeg_:

; 3787 : 					else {
; 3788 : 						for (i = 0; i < z->s->img_x; ++i, out += 2) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN28@load_jpeg_
$LN26@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
	mov	ecx, DWORD PTR _out$11[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$11[ebp], ecx
$LN28@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN73@load_jpeg_

; 3789 : 							out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3790 : 							out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3791 : 						}

	jmp	$LN26@load_jpeg_
$LN73@load_jpeg_:

; 3792 : 					}
; 3793 : 				}

	jmp	$LN59@load_jpeg_
$LN70@load_jpeg_:

; 3794 : 				else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN74@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 0
	jne	$LN74@load_jpeg_

; 3795 : 					for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN31@load_jpeg_
$LN29@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN31@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	$LN30@load_jpeg_

; 3796 : 						stbi_uc m = coutput[3][i];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _m$5[ebp], cl

; 3797 : 						stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _coutput$14[ebp+edx]
	mov	ecx, DWORD PTR _i$17[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _r$4[ebp], al

; 3798 : 						stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _g$3[ebp], al

; 3799 : 						stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

	movzx	eax, BYTE PTR _m$5[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	BYTE PTR _b$2[ebp], al

; 3800 : 						out[0] = stbi__compute_y(r, g, b);

	movzx	eax, BYTE PTR _b$2[ebp]
	push	eax
	movzx	ecx, BYTE PTR _g$3[ebp]
	push	ecx
	movzx	edx, BYTE PTR _r$4[ebp]
	push	edx
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3801 : 						out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3802 : 						out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3803 : 					}

	jmp	$LN29@load_jpeg_
$LN30@load_jpeg_:

; 3804 : 				}

	jmp	$LN59@load_jpeg_
$LN74@load_jpeg_:

; 3805 : 				else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 4
	jne	$LN76@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18408], 2
	jne	$LN76@load_jpeg_

; 3806 : 					for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN34@load_jpeg_
$LN32@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN34@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN33@load_jpeg_

; 3807 : 						out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	eax, DWORD PTR _i$17[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _coutput$14[ebp+eax]
	mov	edx, DWORD PTR _i$17[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	ecx
	call	?stbi__blinn_8x8@@YAEEE@Z		; stbi__blinn_8x8
	add	esp, 8
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3808 : 						out[1] = 255;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 3809 : 						out += n;

	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _out$11[ebp], eax

; 3810 : 					}

	jmp	SHORT $LN32@load_jpeg_
$LN33@load_jpeg_:

; 3811 : 				}

	jmp	$LN59@load_jpeg_
$LN76@load_jpeg_:

; 3812 : 				else {
; 3813 : 					stbi_uc* y = coutput[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _coutput$14[ebp+ecx]
	mov	DWORD PTR _y$1[ebp], edx

; 3814 : 					if (n == 1)

	cmp	DWORD PTR _n$[ebp], 1
	jne	SHORT $LN78@load_jpeg_

; 3815 : 						for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN37@load_jpeg_
$LN35@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN37@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN36@load_jpeg_
	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, DWORD PTR _i$17[ebp]
	mov	ecx, DWORD PTR _y$1[ebp]
	add	ecx, DWORD PTR _i$17[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN35@load_jpeg_
$LN36@load_jpeg_:
	jmp	SHORT $LN59@load_jpeg_
$LN78@load_jpeg_:

; 3816 : 					else
; 3817 : 						for (i = 0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN40@load_jpeg_
$LN38@load_jpeg_:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN40@load_jpeg_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$17[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN59@load_jpeg_
	mov	eax, DWORD PTR _y$1[ebp]
	add	eax, DWORD PTR _i$17[ebp]
	mov	ecx, DWORD PTR _out$11[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$11[ebp]
	add	eax, 1
	mov	DWORD PTR _out$11[ebp], eax
	mov	eax, DWORD PTR _out$11[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _out$11[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$11[ebp], ecx
	jmp	SHORT $LN38@load_jpeg_
$LN59@load_jpeg_:

; 3818 : 				}
; 3819 : 			}
; 3820 : 		}

	jmp	$LN5@load_jpeg_
$LN6@load_jpeg_:

; 3821 : 		stbi__cleanup_jpeg(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	add	esp, 4

; 3822 : 		*out_x = z->s->img_x;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_x$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 3823 : 		*out_y = z->s->img_y;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out_y$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 3824 : 		if (comp)* comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN80@load_jpeg_
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+8], 3
	jl	SHORT $LN102@load_jpeg_
	mov	DWORD PTR tv648[ebp], 3
	jmp	SHORT $LN103@load_jpeg_
$LN102@load_jpeg_:
	mov	DWORD PTR tv648[ebp], 1
$LN103@load_jpeg_:
	mov	edx, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR tv648[ebp]
	mov	DWORD PTR [edx], eax
$LN80@load_jpeg_:

; 3825 : 		return output;

	mov	eax, DWORD PTR _output$15[ebp]
$LN1@load_jpeg_:

; 3826 : 	}
; 3827 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN107@load_jpeg_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 592				; 00000250H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN107@load_jpeg_:
	DD	2
	DD	$LN106@load_jpeg_
$LN106@load_jpeg_:
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$LN104@load_jpeg_
	DD	-244					; ffffff0cH
	DD	128					; 00000080H
	DD	$LN105@load_jpeg_
$LN105@load_jpeg_:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN104@load_jpeg_:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
?load_jpeg_image@@YAPAEPAUstbi__jpeg@@PAH11H@Z ENDP	; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__blinn_8x8@@YAEEE@Z
_TEXT	SEGMENT
_t$ = -8						; size = 4
_x$ = 8							; size = 1
_y$ = 12						; size = 1
?stbi__blinn_8x8@@YAEEE@Z PROC				; stbi__blinn_8x8, COMDAT

; 3656 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3657 : 	unsigned int t = x * y + 128;

	movzx	eax, BYTE PTR _x$[ebp]
	movzx	ecx, BYTE PTR _y$[ebp]
	imul	eax, ecx
	add	eax, 128				; 00000080H
	mov	DWORD PTR _t$[ebp], eax

; 3658 : 	return (stbi_uc)((t + (t >> 8)) >> 8);

	mov	eax, DWORD PTR _t$[ebp]
	shr	eax, 8
	add	eax, DWORD PTR _t$[ebp]
	shr	eax, 8

; 3659 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__blinn_8x8@@YAEEE@Z ENDP				; stbi__blinn_8x8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_j$ = 8							; size = 4
?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z PROC		; stbi__cleanup_jpeg, COMDAT

; 3640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3641 : 	stbi__free_jpeg_components(j, j->s->img_n, 0);

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
	add	esp, 12					; 0000000cH

; 3642 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__cleanup_jpeg@@YAXPAUstbi__jpeg@@@Z ENDP		; stbi__cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__setup_jpeg@@YAXPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_j$ = 8							; size = 4
?stbi__setup_jpeg@@YAXPAUstbi__jpeg@@@Z PROC		; stbi__setup_jpeg, COMDAT

; 3618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3619 : 	j->idct_block_kernel = stbi__idct_block;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18444], OFFSET ?stbi__idct_block@@YAXPAEHQAF@Z ; stbi__idct_block

; 3620 : 	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18448], OFFSET ?stbi__YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z ; stbi__YCbCr_to_RGB_row

; 3621 : 	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18452], OFFSET ?stbi__resample_row_hv_2@@YAPAEPAE00HH@Z ; stbi__resample_row_hv_2

; 3622 : 
; 3623 : #ifdef STBI_SSE2
; 3624 : 	if (stbi__sse2_available()) {

	call	?stbi__sse2_available@@YAHXZ		; stbi__sse2_available
	test	eax, eax
	je	SHORT $LN1@stbi__setu

; 3625 : 		j->idct_block_kernel = stbi__idct_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18444], OFFSET ?stbi__idct_simd@@YAXPAEHQAF@Z ; stbi__idct_simd

; 3626 : 		j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18448], OFFSET ?stbi__YCbCr_to_RGB_simd@@YAXPAEPBE11HH@Z ; stbi__YCbCr_to_RGB_simd

; 3627 : 		j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18452], OFFSET ?stbi__resample_row_hv_2_simd@@YAPAEPAE00HH@Z ; stbi__resample_row_hv_2_simd
$LN1@stbi__setu:

; 3628 : 	}
; 3629 : #endif
; 3630 : 
; 3631 : #ifdef STBI_NEON
; 3632 : 	j->idct_block_kernel = stbi__idct_simd;
; 3633 : 	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3634 : 	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3635 : #endif
; 3636 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__setup_jpeg@@YAXPAUstbi__jpeg@@@Z ENDP		; stbi__setup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__YCbCr_to_RGB_simd@@YAXPAEPBE11HH@Z
_TEXT	SEGMENT
$T1 = -3200						; size = 16
$T2 = -3168						; size = 16
$T3 = -3136						; size = 16
$T4 = -3104						; size = 16
$T5 = -3072						; size = 16
$T6 = -3040						; size = 16
$T7 = -3008						; size = 16
$T8 = -2976						; size = 16
$T9 = -2944						; size = 16
$T10 = -2912						; size = 16
$T11 = -2880						; size = 16
$T12 = -2848						; size = 16
$T13 = -2816						; size = 16
$T14 = -2784						; size = 16
$T15 = -2752						; size = 16
$T16 = -2720						; size = 16
$T17 = -2688						; size = 16
$T18 = -2656						; size = 16
$T19 = -2624						; size = 16
$T20 = -2592						; size = 16
$T21 = -2560						; size = 16
$T22 = -2528						; size = 16
$T23 = -2496						; size = 16
$T24 = -2464						; size = 16
$T25 = -2432						; size = 16
$T26 = -2400						; size = 16
$T27 = -2368						; size = 16
$T28 = -2336						; size = 16
$T29 = -2304						; size = 16
$T30 = -2272						; size = 16
$T31 = -2240						; size = 16
$T32 = -2208						; size = 16
$T33 = -2176						; size = 16
$T34 = -2144						; size = 16
$T35 = -2112						; size = 16
_cb$36 = -1128						; size = 4
_cr$37 = -1116						; size = 4
_b$38 = -1104						; size = 4
_g$39 = -1092						; size = 4
_r$40 = -1080						; size = 4
_y_fixed$41 = -1068					; size = 4
_o1$42 = -1056						; size = 16
_o0$43 = -1024						; size = 16
_t1$44 = -992						; size = 16
_t0$45 = -960						; size = 16
_gxb$46 = -928						; size = 16
_brb$47 = -896						; size = 16
_gw$48 = -864						; size = 16
_bw$49 = -832						; size = 16
_rw$50 = -800						; size = 16
_gws$51 = -768						; size = 16
_bws$52 = -736						; size = 16
_gwt$53 = -704						; size = 16
_rws$54 = -672						; size = 16
_cr1$55 = -640						; size = 16
_cb1$56 = -608						; size = 16
_cb0$57 = -576						; size = 16
_cr0$58 = -544						; size = 16
_yws$59 = -512						; size = 16
_cbw$60 = -480						; size = 16
_crw$61 = -448						; size = 16
_yw$62 = -416						; size = 16
_cb_biased$63 = -384					; size = 16
_cr_biased$64 = -352					; size = 16
_cb_bytes$65 = -320					; size = 16
_cr_bytes$66 = -288					; size = 16
_y_bytes$67 = -256					; size = 16
_xw$68 = -224						; size = 16
_y_bias$69 = -192					; size = 16
_cb_const1$70 = -160					; size = 16
_cb_const0$71 = -128					; size = 16
_cr_const1$72 = -96					; size = 16
_cr_const0$73 = -64					; size = 16
_signflip$74 = -32					; size = 16
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
?stbi__YCbCr_to_RGB_simd@@YAXPAEPBE11HH@Z PROC		; stbi__YCbCr_to_RGB_simd, COMDAT

; 3483 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 3208				; 00000c88H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-3208]
	mov	ecx, 802				; 00000322H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3484 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 3485 : 
; 3486 : #ifdef STBI_SSE2
; 3487 : 	// step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3488 : 	// it's useful in practice (you wouldn't use it for textures, for example).
; 3489 : 	// so just accelerate step == 4 case.
; 3490 : 	if (step == 4) {

	cmp	DWORD PTR _step$[ebx], 4
	jne	$LN8@stbi__YCbC

; 3491 : 		// this is a fairly straightforward implementation and not super-optimized.
; 3492 : 		__m128i signflip = _mm_set1_epi8(-0x80);

	movaps	xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
	movaps	XMMWORD PTR $T35[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T35[ebp]
	movaps	XMMWORD PTR _signflip$74[ebp], xmm0

; 3493 : 		__m128i cr_const0 = _mm_set1_epi16((short)(1.40200f * 4096.0f + 0.5f));

	movaps	xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
	movaps	XMMWORD PTR $T34[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T34[ebp]
	movaps	XMMWORD PTR _cr_const0$73[ebp], xmm0

; 3494 : 		__m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f * 4096.0f + 0.5f));

	movaps	xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
	movaps	XMMWORD PTR $T33[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T33[ebp]
	movaps	XMMWORD PTR _cr_const1$72[ebp], xmm0

; 3495 : 		__m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f * 4096.0f + 0.5f));

	movaps	xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
	movaps	XMMWORD PTR $T32[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T32[ebp]
	movaps	XMMWORD PTR _cb_const0$71[ebp], xmm0

; 3496 : 		__m128i cb_const1 = _mm_set1_epi16((short)(1.77200f * 4096.0f + 0.5f));

	movaps	xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
	movaps	XMMWORD PTR $T31[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T31[ebp]
	movaps	XMMWORD PTR _cb_const1$70[ebp], xmm0

; 3497 : 		__m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);

	movaps	xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
	movaps	XMMWORD PTR $T30[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T30[ebp]
	movaps	XMMWORD PTR _y_bias$69[ebp], xmm0

; 3498 : 		__m128i xw = _mm_set1_epi16(255); // alpha channel

	movaps	xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	movaps	XMMWORD PTR $T29[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T29[ebp]
	movaps	XMMWORD PTR _xw$68[ebp], xmm0

; 3499 : 
; 3500 : 		for (; i + 7 < count; i += 8) {

	jmp	SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 8
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 7
	cmp	eax, DWORD PTR _count$[ebx]
	jge	$LN8@stbi__YCbC

; 3501 : 			// load
; 3502 : 			__m128i y_bytes = _mm_loadl_epi64((__m128i*) (y + i));

	mov	eax, DWORD PTR _y$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movaps	XMMWORD PTR $T28[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T28[ebp]
	movaps	XMMWORD PTR _y_bytes$67[ebp], xmm0

; 3503 : 			__m128i cr_bytes = _mm_loadl_epi64((__m128i*) (pcr + i));

	mov	eax, DWORD PTR _pcr$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movaps	XMMWORD PTR $T27[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T27[ebp]
	movaps	XMMWORD PTR _cr_bytes$66[ebp], xmm0

; 3504 : 			__m128i cb_bytes = _mm_loadl_epi64((__m128i*) (pcb + i));

	mov	eax, DWORD PTR _pcb$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movaps	XMMWORD PTR $T26[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T26[ebp]
	movaps	XMMWORD PTR _cb_bytes$65[ebp], xmm0

; 3505 : 			__m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

	movaps	xmm0, XMMWORD PTR _cr_bytes$66[ebp]
	pxor	xmm0, XMMWORD PTR _signflip$74[ebp]
	movaps	XMMWORD PTR $T25[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T25[ebp]
	movaps	XMMWORD PTR _cr_biased$64[ebp], xmm0

; 3506 : 			__m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

	movaps	xmm0, XMMWORD PTR _cb_bytes$65[ebp]
	pxor	xmm0, XMMWORD PTR _signflip$74[ebp]
	movaps	XMMWORD PTR $T24[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T24[ebp]
	movaps	XMMWORD PTR _cb_biased$63[ebp], xmm0

; 3507 : 
; 3508 : 			// unpack to short (and left-shift cr, cb by 8)
; 3509 : 			__m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);

	movaps	xmm0, XMMWORD PTR _y_bias$69[ebp]
	punpcklbw xmm0, XMMWORD PTR _y_bytes$67[ebp]
	movaps	XMMWORD PTR $T23[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T23[ebp]
	movaps	XMMWORD PTR _yw$62[ebp], xmm0

; 3510 : 			__m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T21[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T21[ebp]
	punpcklbw xmm0, XMMWORD PTR _cr_biased$64[ebp]
	movaps	XMMWORD PTR $T22[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T22[ebp]
	movaps	XMMWORD PTR _crw$61[ebp], xmm0

; 3511 : 			__m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T19[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T19[ebp]
	punpcklbw xmm0, XMMWORD PTR _cb_biased$63[ebp]
	movaps	XMMWORD PTR $T20[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T20[ebp]
	movaps	XMMWORD PTR _cbw$60[ebp], xmm0

; 3512 : 
; 3513 : 			// color transform
; 3514 : 			__m128i yws = _mm_srli_epi16(yw, 4);

	movaps	xmm0, XMMWORD PTR _yw$62[ebp]
	psrlw	xmm0, 4
	movaps	XMMWORD PTR $T18[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T18[ebp]
	movaps	XMMWORD PTR _yws$59[ebp], xmm0

; 3515 : 			__m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

	movaps	xmm0, XMMWORD PTR _cr_const0$73[ebp]
	pmulhw	xmm0, XMMWORD PTR _crw$61[ebp]
	movaps	XMMWORD PTR $T17[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T17[ebp]
	movaps	XMMWORD PTR _cr0$58[ebp], xmm0

; 3516 : 			__m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

	movaps	xmm0, XMMWORD PTR _cb_const0$71[ebp]
	pmulhw	xmm0, XMMWORD PTR _cbw$60[ebp]
	movaps	XMMWORD PTR $T16[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T16[ebp]
	movaps	XMMWORD PTR _cb0$57[ebp], xmm0

; 3517 : 			__m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

	movaps	xmm0, XMMWORD PTR _cbw$60[ebp]
	pmulhw	xmm0, XMMWORD PTR _cb_const1$70[ebp]
	movaps	XMMWORD PTR $T15[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T15[ebp]
	movaps	XMMWORD PTR _cb1$56[ebp], xmm0

; 3518 : 			__m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

	movaps	xmm0, XMMWORD PTR _crw$61[ebp]
	pmulhw	xmm0, XMMWORD PTR _cr_const1$72[ebp]
	movaps	XMMWORD PTR $T14[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T14[ebp]
	movaps	XMMWORD PTR _cr1$55[ebp], xmm0

; 3519 : 			__m128i rws = _mm_add_epi16(cr0, yws);

	movaps	xmm0, XMMWORD PTR _cr0$58[ebp]
	paddw	xmm0, XMMWORD PTR _yws$59[ebp]
	movaps	XMMWORD PTR $T13[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T13[ebp]
	movaps	XMMWORD PTR _rws$54[ebp], xmm0

; 3520 : 			__m128i gwt = _mm_add_epi16(cb0, yws);

	movaps	xmm0, XMMWORD PTR _cb0$57[ebp]
	paddw	xmm0, XMMWORD PTR _yws$59[ebp]
	movaps	XMMWORD PTR $T12[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T12[ebp]
	movaps	XMMWORD PTR _gwt$53[ebp], xmm0

; 3521 : 			__m128i bws = _mm_add_epi16(yws, cb1);

	movaps	xmm0, XMMWORD PTR _yws$59[ebp]
	paddw	xmm0, XMMWORD PTR _cb1$56[ebp]
	movaps	XMMWORD PTR $T11[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T11[ebp]
	movaps	XMMWORD PTR _bws$52[ebp], xmm0

; 3522 : 			__m128i gws = _mm_add_epi16(gwt, cr1);

	movaps	xmm0, XMMWORD PTR _gwt$53[ebp]
	paddw	xmm0, XMMWORD PTR _cr1$55[ebp]
	movaps	XMMWORD PTR $T10[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T10[ebp]
	movaps	XMMWORD PTR _gws$51[ebp], xmm0

; 3523 : 
; 3524 : 			// descale
; 3525 : 			__m128i rw = _mm_srai_epi16(rws, 4);

	movaps	xmm0, XMMWORD PTR _rws$54[ebp]
	psraw	xmm0, 4
	movaps	XMMWORD PTR $T9[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T9[ebp]
	movaps	XMMWORD PTR _rw$50[ebp], xmm0

; 3526 : 			__m128i bw = _mm_srai_epi16(bws, 4);

	movaps	xmm0, XMMWORD PTR _bws$52[ebp]
	psraw	xmm0, 4
	movaps	XMMWORD PTR $T8[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T8[ebp]
	movaps	XMMWORD PTR _bw$49[ebp], xmm0

; 3527 : 			__m128i gw = _mm_srai_epi16(gws, 4);

	movaps	xmm0, XMMWORD PTR _gws$51[ebp]
	psraw	xmm0, 4
	movaps	XMMWORD PTR $T7[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T7[ebp]
	movaps	XMMWORD PTR _gw$48[ebp], xmm0

; 3528 : 
; 3529 : 			// back to byte, set up for transpose
; 3530 : 			__m128i brb = _mm_packus_epi16(rw, bw);

	movaps	xmm0, XMMWORD PTR _rw$50[ebp]
	packuswb xmm0, XMMWORD PTR _bw$49[ebp]
	movaps	XMMWORD PTR $T6[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T6[ebp]
	movaps	XMMWORD PTR _brb$47[ebp], xmm0

; 3531 : 			__m128i gxb = _mm_packus_epi16(gw, xw);

	movaps	xmm0, XMMWORD PTR _gw$48[ebp]
	packuswb xmm0, XMMWORD PTR _xw$68[ebp]
	movaps	XMMWORD PTR $T5[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T5[ebp]
	movaps	XMMWORD PTR _gxb$46[ebp], xmm0

; 3532 : 
; 3533 : 			// transpose to interleave channels
; 3534 : 			__m128i t0 = _mm_unpacklo_epi8(brb, gxb);

	movaps	xmm0, XMMWORD PTR _brb$47[ebp]
	punpcklbw xmm0, XMMWORD PTR _gxb$46[ebp]
	movaps	XMMWORD PTR $T4[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T4[ebp]
	movaps	XMMWORD PTR _t0$45[ebp], xmm0

; 3535 : 			__m128i t1 = _mm_unpackhi_epi8(brb, gxb);

	movaps	xmm0, XMMWORD PTR _brb$47[ebp]
	punpckhbw xmm0, XMMWORD PTR _gxb$46[ebp]
	movaps	XMMWORD PTR $T3[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T3[ebp]
	movaps	XMMWORD PTR _t1$44[ebp], xmm0

; 3536 : 			__m128i o0 = _mm_unpacklo_epi16(t0, t1);

	movaps	xmm0, XMMWORD PTR _t0$45[ebp]
	punpcklwd xmm0, XMMWORD PTR _t1$44[ebp]
	movaps	XMMWORD PTR $T2[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T2[ebp]
	movaps	XMMWORD PTR _o0$43[ebp], xmm0

; 3537 : 			__m128i o1 = _mm_unpackhi_epi16(t0, t1);

	movaps	xmm0, XMMWORD PTR _t0$45[ebp]
	punpckhwd xmm0, XMMWORD PTR _t1$44[ebp]
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _o1$42[ebp], xmm0

; 3538 : 
; 3539 : 			// store
; 3540 : 			_mm_storeu_si128((__m128i*) (out + 0), o0);

	movups	xmm0, XMMWORD PTR _o0$43[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movups	XMMWORD PTR [eax], xmm0

; 3541 : 			_mm_storeu_si128((__m128i*) (out + 16), o1);

	movups	xmm0, XMMWORD PTR _o1$42[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0

; 3542 : 			out += 32;

	mov	eax, DWORD PTR _out$[ebx]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _out$[ebx], eax

; 3543 : 		}

	jmp	$LN2@stbi__YCbC
$LN8@stbi__YCbC:

; 3544 : 	}
; 3545 : #endif
; 3546 : 
; 3547 : #ifdef STBI_NEON
; 3548 : 	// in this version, step=3 support would be easy to add. but is there demand?
; 3549 : 	if (step == 4) {
; 3550 : 		// this is a fairly straightforward implementation and not super-optimized.
; 3551 : 		uint8x8_t signflip = vdup_n_u8(0x80);
; 3552 : 		int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f * 4096.0f + 0.5f));
; 3553 : 		int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f * 4096.0f + 0.5f));
; 3554 : 		int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f * 4096.0f + 0.5f));
; 3555 : 		int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f * 4096.0f + 0.5f));
; 3556 : 
; 3557 : 		for (; i + 7 < count; i += 8) {
; 3558 : 			// load
; 3559 : 			uint8x8_t y_bytes = vld1_u8(y + i);
; 3560 : 			uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3561 : 			uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3562 : 			int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3563 : 			int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3564 : 
; 3565 : 			// expand to s16
; 3566 : 			int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3567 : 			int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3568 : 			int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3569 : 
; 3570 : 			// color transform
; 3571 : 			int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3572 : 			int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3573 : 			int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3574 : 			int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3575 : 			int16x8_t rws = vaddq_s16(yws, cr0);
; 3576 : 			int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3577 : 			int16x8_t bws = vaddq_s16(yws, cb1);
; 3578 : 
; 3579 : 			// undo scaling, round, convert to byte
; 3580 : 			uint8x8x4_t o;
; 3581 : 			o.val[0] = vqrshrun_n_s16(rws, 4);
; 3582 : 			o.val[1] = vqrshrun_n_s16(gws, 4);
; 3583 : 			o.val[2] = vqrshrun_n_s16(bws, 4);
; 3584 : 			o.val[3] = vdup_n_u8(255);
; 3585 : 
; 3586 : 			// store, interleaving r/g/b/a
; 3587 : 			vst4_u8(out, o);
; 3588 : 			out += 8 * 4;
; 3589 : 		}
; 3590 : 	}
; 3591 : #endif
; 3592 : 
; 3593 : 	for (; i < count; ++i) {

	jmp	SHORT $LN7@stbi__YCbC
$LN5@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebx]
	jge	$LN1@stbi__YCbC

; 3594 : 		int y_fixed = (y[i] << 20) + (1 << 19); // rounding

	mov	eax, DWORD PTR _y$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 20					; 00000014H
	add	ecx, 524288				; 00080000H
	mov	DWORD PTR _y_fixed$41[ebp], ecx

; 3595 : 		int r, g, b;
; 3596 : 		int cr = pcr[i] - 128;

	mov	eax, DWORD PTR _pcr$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cr$37[ebp], ecx

; 3597 : 		int cb = pcb[i] - 128;

	mov	eax, DWORD PTR _pcb$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cb$36[ebp], ecx

; 3598 : 		r = y_fixed + cr * stbi__float2fixed(1.40200f);

	imul	eax, DWORD PTR _cr$37[ebp], 1470208
	add	eax, DWORD PTR _y_fixed$41[ebp]
	mov	DWORD PTR _r$40[ebp], eax

; 3599 : 		g = y_fixed + cr * -stbi__float2fixed(0.71414f) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, DWORD PTR _cr$37[ebp], -748800
	add	eax, DWORD PTR _y_fixed$41[ebp]
	imul	ecx, DWORD PTR _cb$36[ebp], -360960
	and	ecx, -65536				; ffff0000H
	add	eax, ecx
	mov	DWORD PTR _g$39[ebp], eax

; 3600 : 		b = y_fixed + cb * stbi__float2fixed(1.77200f);

	imul	eax, DWORD PTR _cb$36[ebp], 1858048
	add	eax, DWORD PTR _y_fixed$41[ebp]
	mov	DWORD PTR _b$38[ebp], eax

; 3601 : 		r >>= 20;

	mov	eax, DWORD PTR _r$40[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _r$40[ebp], eax

; 3602 : 		g >>= 20;

	mov	eax, DWORD PTR _g$39[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _g$39[ebp], eax

; 3603 : 		b >>= 20;

	mov	eax, DWORD PTR _b$38[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _b$38[ebp], eax

; 3604 : 		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR _r$40[ebp], 255		; 000000ffH
	jbe	SHORT $LN9@stbi__YCbC
	cmp	DWORD PTR _r$40[ebp], 0
	jge	SHORT $LN10@stbi__YCbC
	mov	DWORD PTR _r$40[ebp], 0
	jmp	SHORT $LN9@stbi__YCbC
$LN10@stbi__YCbC:
	mov	DWORD PTR _r$40[ebp], 255		; 000000ffH
$LN9@stbi__YCbC:

; 3605 : 		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	DWORD PTR _g$39[ebp], 255		; 000000ffH
	jbe	SHORT $LN12@stbi__YCbC
	cmp	DWORD PTR _g$39[ebp], 0
	jge	SHORT $LN13@stbi__YCbC
	mov	DWORD PTR _g$39[ebp], 0
	jmp	SHORT $LN12@stbi__YCbC
$LN13@stbi__YCbC:
	mov	DWORD PTR _g$39[ebp], 255		; 000000ffH
$LN12@stbi__YCbC:

; 3606 : 		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	DWORD PTR _b$38[ebp], 255		; 000000ffH
	jbe	SHORT $LN15@stbi__YCbC
	cmp	DWORD PTR _b$38[ebp], 0
	jge	SHORT $LN16@stbi__YCbC
	mov	DWORD PTR _b$38[ebp], 0
	jmp	SHORT $LN15@stbi__YCbC
$LN16@stbi__YCbC:
	mov	DWORD PTR _b$38[ebp], 255		; 000000ffH
$LN15@stbi__YCbC:

; 3607 : 		out[0] = (stbi_uc)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebx]
	mov	al, BYTE PTR _r$40[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3608 : 		out[1] = (stbi_uc)g;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR _g$39[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3609 : 		out[2] = (stbi_uc)b;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR _b$38[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3610 : 		out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3611 : 		out += step;

	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _step$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 3612 : 	}

	jmp	$LN5@stbi__YCbC
$LN1@stbi__YCbC:

; 3613 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?stbi__YCbCr_to_RGB_simd@@YAXPAEPBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z
_TEXT	SEGMENT
_cb$1 = -80						; size = 4
_cr$2 = -68						; size = 4
_b$3 = -56						; size = 4
_g$4 = -44						; size = 4
_r$5 = -32						; size = 4
_y_fixed$6 = -20					; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
?stbi__YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z PROC		; stbi__YCbCr_to_RGB_row, COMDAT

; 3457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3458 : 	int i;
; 3459 : 	for (i = 0; i < count; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__YCbC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN1@stbi__YCbC

; 3460 : 		int y_fixed = (y[i] << 20) + (1 << 19); // rounding

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 20					; 00000014H
	add	ecx, 524288				; 00080000H
	mov	DWORD PTR _y_fixed$6[ebp], ecx

; 3461 : 		int r, g, b;
; 3462 : 		int cr = pcr[i] - 128;

	mov	eax, DWORD PTR _pcr$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cr$2[ebp], ecx

; 3463 : 		int cb = pcb[i] - 128;

	mov	eax, DWORD PTR _pcb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR _cb$1[ebp], ecx

; 3464 : 		r = y_fixed + cr * stbi__float2fixed(1.40200f);

	imul	eax, DWORD PTR _cr$2[ebp], 1470208
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _r$5[ebp], eax

; 3465 : 		g = y_fixed + (cr * -stbi__float2fixed(0.71414f)) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, DWORD PTR _cr$2[ebp], -748800
	add	eax, DWORD PTR _y_fixed$6[ebp]
	imul	ecx, DWORD PTR _cb$1[ebp], -360960
	and	ecx, -65536				; ffff0000H
	add	eax, ecx
	mov	DWORD PTR _g$4[ebp], eax

; 3466 : 		b = y_fixed + cb * stbi__float2fixed(1.77200f);

	imul	eax, DWORD PTR _cb$1[ebp], 1858048
	add	eax, DWORD PTR _y_fixed$6[ebp]
	mov	DWORD PTR _b$3[ebp], eax

; 3467 : 		r >>= 20;

	mov	eax, DWORD PTR _r$5[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _r$5[ebp], eax

; 3468 : 		g >>= 20;

	mov	eax, DWORD PTR _g$4[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _g$4[ebp], eax

; 3469 : 		b >>= 20;

	mov	eax, DWORD PTR _b$3[ebp]
	sar	eax, 20					; 00000014H
	mov	DWORD PTR _b$3[ebp], eax

; 3470 : 		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR _r$5[ebp], 255		; 000000ffH
	jbe	SHORT $LN5@stbi__YCbC
	cmp	DWORD PTR _r$5[ebp], 0
	jge	SHORT $LN6@stbi__YCbC
	mov	DWORD PTR _r$5[ebp], 0
	jmp	SHORT $LN5@stbi__YCbC
$LN6@stbi__YCbC:
	mov	DWORD PTR _r$5[ebp], 255		; 000000ffH
$LN5@stbi__YCbC:

; 3471 : 		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	DWORD PTR _g$4[ebp], 255		; 000000ffH
	jbe	SHORT $LN8@stbi__YCbC
	cmp	DWORD PTR _g$4[ebp], 0
	jge	SHORT $LN9@stbi__YCbC
	mov	DWORD PTR _g$4[ebp], 0
	jmp	SHORT $LN8@stbi__YCbC
$LN9@stbi__YCbC:
	mov	DWORD PTR _g$4[ebp], 255		; 000000ffH
$LN8@stbi__YCbC:

; 3472 : 		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	DWORD PTR _b$3[ebp], 255		; 000000ffH
	jbe	SHORT $LN11@stbi__YCbC
	cmp	DWORD PTR _b$3[ebp], 0
	jge	SHORT $LN12@stbi__YCbC
	mov	DWORD PTR _b$3[ebp], 0
	jmp	SHORT $LN11@stbi__YCbC
$LN12@stbi__YCbC:
	mov	DWORD PTR _b$3[ebp], 255		; 000000ffH
$LN11@stbi__YCbC:

; 3473 : 		out[0] = (stbi_uc)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _r$5[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3474 : 		out[1] = (stbi_uc)g;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _g$4[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3475 : 		out[2] = (stbi_uc)b;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _b$3[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3476 : 		out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 3477 : 		out += step;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 3478 : 	}

	jmp	$LN2@stbi__YCbC
$LN1@stbi__YCbC:

; 3479 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__resample_row_generic@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?stbi__resample_row_generic@@YAPAEPAE00HH@Z PROC	; stbi__resample_row_generic, COMDAT

; 3443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3444 : 	// resample with nearest-neighbor
; 3445 : 	int i, j;
; 3446 : 	STBI_NOTUSED(in_far);
; 3447 : 	for (i = 0; i < w; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN3@stbi__resa

; 3448 : 		for (j = 0; j < hs; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@stbi__resa
$LN5@stbi__resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@stbi__resa:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hs$[ebp]
	jge	SHORT $LN6@stbi__resa

; 3449 : 			out[i * hs + j] = in_near[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _hs$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in_near$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax], cl
	jmp	SHORT $LN5@stbi__resa
$LN6@stbi__resa:
	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3450 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3451 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__resample_row_generic@@YAPAEPAE00HH@Z ENDP	; stbi__resample_row_generic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__resample_row_hv_2_simd@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
tv78 = -2344						; size = 4
$T1 = -2336						; size = 16
$T2 = -2304						; size = 16
$T3 = -2272						; size = 16
$T4 = -2240						; size = 16
$T5 = -2208						; size = 16
$T6 = -2176						; size = 16
$T7 = -2144						; size = 16
$T8 = -2112						; size = 16
$T9 = -2080						; size = 16
$T10 = -2048						; size = 16
$T11 = -2016						; size = 16
$T12 = -1984						; size = 16
$T13 = -1952						; size = 16
$T14 = -1920						; size = 16
$T15 = -1888						; size = 16
$T16 = -1856						; size = 16
$T17 = -1824						; size = 16
$T18 = -1792						; size = 16
$T19 = -1760						; size = 16
$T20 = -1728						; size = 16
$T21 = -1696						; size = 16
$T22 = -1664						; size = 16
$T23 = -1632						; size = 16
$T24 = -1600						; size = 16
_outv$25 = -800						; size = 16
_de1$26 = -768						; size = 16
_de0$27 = -736						; size = 16
_int1$28 = -704						; size = 16
_int0$29 = -672						; size = 16
_odd$30 = -640						; size = 16
_even$31 = -608						; size = 16
_curb$32 = -576						; size = 16
_nxtd$33 = -544						; size = 16
_prvd$34 = -512						; size = 16
_curs$35 = -480						; size = 16
_bias$36 = -448						; size = 16
_next$37 = -416						; size = 16
_prev$38 = -384						; size = 16
_nxt0$39 = -352						; size = 16
_prv0$40 = -320						; size = 16
_curr$41 = -288						; size = 16
_nears$42 = -256					; size = 16
_diff$43 = -224						; size = 16
_nearw$44 = -192					; size = 16
_farw$45 = -160						; size = 16
_nearb$46 = -128					; size = 16
_farb$47 = -96						; size = 16
_zero$48 = -64						; size = 16
_t1$ = -32						; size = 4
_t0$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?stbi__resample_row_hv_2_simd@@YAPAEPAE00HH@Z PROC	; stbi__resample_row_hv_2_simd, COMDAT

; 3327 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 2344				; 00000928H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2344]
	mov	ecx, 586				; 0000024aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3328 : 	// need to generate 2x2 samples for every one in input
; 3329 : 	int i = 0, t0, t1;

	mov	DWORD PTR _i$[ebp], 0

; 3330 : 
; 3331 : 	if (w == 1) {

	cmp	DWORD PTR _w$[ebx], 1
	jne	SHORT $LN8@stbi__resa

; 3332 : 		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebx]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebx]
	movzx	eax, BYTE PTR [edx+eax]
	lea	ecx, DWORD PTR [ecx+eax+2]
	sar	ecx, 2
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebx]
	mov	cl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebx]
	mov	dl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3333 : 		return out;

	mov	eax, DWORD PTR _out$[ebx]
	jmp	$LN1@stbi__resa
$LN8@stbi__resa:

; 3334 : 	}
; 3335 : 
; 3336 : 	t1 = 3 * in_near[0] + in_far[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebx]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebx]
	movzx	eax, BYTE PTR [edx+eax]
	add	ecx, eax
	mov	DWORD PTR _t1$[ebp], ecx

; 3337 : 	// process groups of 8 pixels for as long as we can.
; 3338 : 	// note we can't handle the last pixel in a row in this loop
; 3339 : 	// because we need to handle the filter boundary conditions.
; 3340 : 	for (; i < ((w - 1) & ~7); i += 8) {

	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 8
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR _w$[ebx]
	sub	eax, 1
	and	eax, -8					; fffffff8H
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@stbi__resa

; 3341 : #if defined(STBI_SSE2)
; 3342 : 		// load and perform the vertical filtering pass
; 3343 : 		// this uses 3*x + y = 4*x + (y - x)
; 3344 : 		__m128i zero = _mm_setzero_si128();

	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T24[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T24[ebp]
	movaps	XMMWORD PTR _zero$48[ebp], xmm0

; 3345 : 		__m128i farb = _mm_loadl_epi64((__m128i*) (in_far + i));

	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movaps	XMMWORD PTR $T23[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T23[ebp]
	movaps	XMMWORD PTR _farb$47[ebp], xmm0

; 3346 : 		__m128i nearb = _mm_loadl_epi64((__m128i*) (in_near + i));

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movaps	XMMWORD PTR $T22[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T22[ebp]
	movaps	XMMWORD PTR _nearb$46[ebp], xmm0

; 3347 : 		__m128i farw = _mm_unpacklo_epi8(farb, zero);

	movaps	xmm0, XMMWORD PTR _farb$47[ebp]
	punpcklbw xmm0, XMMWORD PTR _zero$48[ebp]
	movaps	XMMWORD PTR $T21[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T21[ebp]
	movaps	XMMWORD PTR _farw$45[ebp], xmm0

; 3348 : 		__m128i nearw = _mm_unpacklo_epi8(nearb, zero);

	movaps	xmm0, XMMWORD PTR _nearb$46[ebp]
	punpcklbw xmm0, XMMWORD PTR _zero$48[ebp]
	movaps	XMMWORD PTR $T20[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T20[ebp]
	movaps	XMMWORD PTR _nearw$44[ebp], xmm0

; 3349 : 		__m128i diff = _mm_sub_epi16(farw, nearw);

	movaps	xmm0, XMMWORD PTR _farw$45[ebp]
	psubw	xmm0, XMMWORD PTR _nearw$44[ebp]
	movaps	XMMWORD PTR $T19[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T19[ebp]
	movaps	XMMWORD PTR _diff$43[ebp], xmm0

; 3350 : 		__m128i nears = _mm_slli_epi16(nearw, 2);

	movaps	xmm0, XMMWORD PTR _nearw$44[ebp]
	psllw	xmm0, 2
	movaps	XMMWORD PTR $T18[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T18[ebp]
	movaps	XMMWORD PTR _nears$42[ebp], xmm0

; 3351 : 		__m128i curr = _mm_add_epi16(nears, diff); // current row

	movaps	xmm0, XMMWORD PTR _nears$42[ebp]
	paddw	xmm0, XMMWORD PTR _diff$43[ebp]
	movaps	XMMWORD PTR $T17[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T17[ebp]
	movaps	XMMWORD PTR _curr$41[ebp], xmm0

; 3352 : 
; 3353 : 		// horizontal filter works the same based on shifted vers of current
; 3354 : 		// row. "prev" is current row shifted right by 1 pixel; we need to
; 3355 : 		// insert the previous pixel value (from t1).
; 3356 : 		// "next" is current row shifted left by 1 pixel, with first pixel
; 3357 : 		// of next block of 8 pixels added in.
; 3358 : 		__m128i prv0 = _mm_slli_si128(curr, 2);

	movaps	xmm0, XMMWORD PTR _curr$41[ebp]
	pslldq	xmm0, 2
	movaps	XMMWORD PTR $T16[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T16[ebp]
	movaps	XMMWORD PTR _prv0$40[ebp], xmm0

; 3359 : 		__m128i nxt0 = _mm_srli_si128(curr, 2);

	movaps	xmm0, XMMWORD PTR _curr$41[ebp]
	psrldq	xmm0, 2
	movaps	XMMWORD PTR $T15[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T15[ebp]
	movaps	XMMWORD PTR _nxt0$39[ebp], xmm0

; 3360 : 		__m128i prev = _mm_insert_epi16(prv0, t1, 0);

	movaps	xmm0, XMMWORD PTR _prv0$40[ebp]
	pinsrw	xmm0, DWORD PTR _t1$[ebp], 0
	movaps	XMMWORD PTR $T14[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T14[ebp]
	movaps	XMMWORD PTR _prev$38[ebp], xmm0

; 3361 : 		__m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	add	edx, ecx
	movaps	xmm0, XMMWORD PTR _nxt0$39[ebp]
	pinsrw	xmm0, edx, 7
	movaps	XMMWORD PTR $T13[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T13[ebp]
	movaps	XMMWORD PTR _next$37[ebp], xmm0

; 3362 : 
; 3363 : 		// horizontal filter, polyphase implementation since it's convenient:
; 3364 : 		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3365 : 		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3366 : 		// note the shared term.
; 3367 : 		__m128i bias = _mm_set1_epi16(8);

	movaps	xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
	movaps	XMMWORD PTR $T12[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T12[ebp]
	movaps	XMMWORD PTR _bias$36[ebp], xmm0

; 3368 : 		__m128i curs = _mm_slli_epi16(curr, 2);

	movaps	xmm0, XMMWORD PTR _curr$41[ebp]
	psllw	xmm0, 2
	movaps	XMMWORD PTR $T11[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T11[ebp]
	movaps	XMMWORD PTR _curs$35[ebp], xmm0

; 3369 : 		__m128i prvd = _mm_sub_epi16(prev, curr);

	movaps	xmm0, XMMWORD PTR _prev$38[ebp]
	psubw	xmm0, XMMWORD PTR _curr$41[ebp]
	movaps	XMMWORD PTR $T10[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T10[ebp]
	movaps	XMMWORD PTR _prvd$34[ebp], xmm0

; 3370 : 		__m128i nxtd = _mm_sub_epi16(next, curr);

	movaps	xmm0, XMMWORD PTR _next$37[ebp]
	psubw	xmm0, XMMWORD PTR _curr$41[ebp]
	movaps	XMMWORD PTR $T9[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T9[ebp]
	movaps	XMMWORD PTR _nxtd$33[ebp], xmm0

; 3371 : 		__m128i curb = _mm_add_epi16(curs, bias);

	movaps	xmm0, XMMWORD PTR _curs$35[ebp]
	paddw	xmm0, XMMWORD PTR _bias$36[ebp]
	movaps	XMMWORD PTR $T8[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T8[ebp]
	movaps	XMMWORD PTR _curb$32[ebp], xmm0

; 3372 : 		__m128i even = _mm_add_epi16(prvd, curb);

	movaps	xmm0, XMMWORD PTR _prvd$34[ebp]
	paddw	xmm0, XMMWORD PTR _curb$32[ebp]
	movaps	XMMWORD PTR $T7[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T7[ebp]
	movaps	XMMWORD PTR _even$31[ebp], xmm0

; 3373 : 		__m128i odd = _mm_add_epi16(nxtd, curb);

	movaps	xmm0, XMMWORD PTR _nxtd$33[ebp]
	paddw	xmm0, XMMWORD PTR _curb$32[ebp]
	movaps	XMMWORD PTR $T6[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T6[ebp]
	movaps	XMMWORD PTR _odd$30[ebp], xmm0

; 3374 : 
; 3375 : 		// interleave even and odd pixels, then undo scaling.
; 3376 : 		__m128i int0 = _mm_unpacklo_epi16(even, odd);

	movaps	xmm0, XMMWORD PTR _even$31[ebp]
	punpcklwd xmm0, XMMWORD PTR _odd$30[ebp]
	movaps	XMMWORD PTR $T5[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T5[ebp]
	movaps	XMMWORD PTR _int0$29[ebp], xmm0

; 3377 : 		__m128i int1 = _mm_unpackhi_epi16(even, odd);

	movaps	xmm0, XMMWORD PTR _even$31[ebp]
	punpckhwd xmm0, XMMWORD PTR _odd$30[ebp]
	movaps	XMMWORD PTR $T4[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T4[ebp]
	movaps	XMMWORD PTR _int1$28[ebp], xmm0

; 3378 : 		__m128i de0 = _mm_srli_epi16(int0, 4);

	movaps	xmm0, XMMWORD PTR _int0$29[ebp]
	psrlw	xmm0, 4
	movaps	XMMWORD PTR $T3[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T3[ebp]
	movaps	XMMWORD PTR _de0$27[ebp], xmm0

; 3379 : 		__m128i de1 = _mm_srli_epi16(int1, 4);

	movaps	xmm0, XMMWORD PTR _int1$28[ebp]
	psrlw	xmm0, 4
	movaps	XMMWORD PTR $T2[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T2[ebp]
	movaps	XMMWORD PTR _de1$26[ebp], xmm0

; 3380 : 
; 3381 : 		// pack and write output
; 3382 : 		__m128i outv = _mm_packus_epi16(de0, de1);

	movaps	xmm0, XMMWORD PTR _de0$27[ebp]
	packuswb xmm0, XMMWORD PTR _de1$26[ebp]
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _outv$25[ebp], xmm0

; 3383 : 		_mm_storeu_si128((__m128i*) (out + i * 2), outv);

	movups	xmm0, XMMWORD PTR _outv$25[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	movups	XMMWORD PTR [ecx+eax*2], xmm0

; 3384 : #elif defined(STBI_NEON)
; 3385 : 		// load and perform the vertical filtering pass
; 3386 : 		// this uses 3*x + y = 4*x + (y - x)
; 3387 : 		uint8x8_t farb = vld1_u8(in_far + i);
; 3388 : 		uint8x8_t nearb = vld1_u8(in_near + i);
; 3389 : 		int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3390 : 		int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3391 : 		int16x8_t curr = vaddq_s16(nears, diff); // current row
; 3392 : 
; 3393 : 		// horizontal filter works the same based on shifted vers of current
; 3394 : 		// row. "prev" is current row shifted right by 1 pixel; we need to
; 3395 : 		// insert the previous pixel value (from t1).
; 3396 : 		// "next" is current row shifted left by 1 pixel, with first pixel
; 3397 : 		// of next block of 8 pixels added in.
; 3398 : 		int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3399 : 		int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3400 : 		int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3401 : 		int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);
; 3402 : 
; 3403 : 		// horizontal filter, polyphase implementation since it's convenient:
; 3404 : 		// even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3405 : 		// odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3406 : 		// note the shared term.
; 3407 : 		int16x8_t curs = vshlq_n_s16(curr, 2);
; 3408 : 		int16x8_t prvd = vsubq_s16(prev, curr);
; 3409 : 		int16x8_t nxtd = vsubq_s16(next, curr);
; 3410 : 		int16x8_t even = vaddq_s16(curs, prvd);
; 3411 : 		int16x8_t odd = vaddq_s16(curs, nxtd);
; 3412 : 
; 3413 : 		// undo scaling and round, then store with even/odd phases interleaved
; 3414 : 		uint8x8x2_t o;
; 3415 : 		o.val[0] = vqrshrun_n_s16(even, 4);
; 3416 : 		o.val[1] = vqrshrun_n_s16(odd, 4);
; 3417 : 		vst2_u8(out + i * 2, o);
; 3418 : #endif
; 3419 : 
; 3420 : 		// "previous" value for next iter
; 3421 : 		t1 = 3 * in_near[i + 7] + in_far[i + 7];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+7]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+7]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3422 : 	}

	jmp	$LN2@stbi__resa
$LN3@stbi__resa:

; 3423 : 
; 3424 : 	t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3425 : 	t1 = 3 * in_near[i] + in_far[i];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3426 : 	out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2], dl

; 3427 : 
; 3428 : 	for (++i; i < w; ++i) {

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@stbi__resa
$LN5@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebx]
	jge	SHORT $LN6@stbi__resa

; 3429 : 		t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3430 : 		t1 = 3 * in_near[i] + in_far[i];

	mov	eax, DWORD PTR _in_near$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebx]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3431 : 		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);

	imul	eax, DWORD PTR _t0$[ebp], 3
	mov	ecx, DWORD PTR _t1$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2-1], dl

; 3432 : 		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [ecx+eax*2], dl

; 3433 : 	}

	jmp	SHORT $LN5@stbi__resa
$LN6@stbi__resa:

; 3434 : 	out[w * 2 - 1] = stbi__div4(t1 + 2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, DWORD PTR _w$[ebx]
	mov	edx, DWORD PTR _out$[ebx]
	mov	BYTE PTR [edx+ecx*2-1], al

; 3435 : 
; 3436 : 	STBI_NOTUSED(hs);
; 3437 : 
; 3438 : 	return out;

	mov	eax, DWORD PTR _out$[ebx]
$LN1@stbi__resa:

; 3439 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?stbi__resample_row_hv_2_simd@@YAPAEPAE00HH@Z ENDP	; stbi__resample_row_hv_2_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__resample_row_hv_2@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
tv78 = -232						; size = 4
_t1$ = -32						; size = 4
_t0$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?stbi__resample_row_hv_2@@YAPAEPAE00HH@Z PROC		; stbi__resample_row_hv_2, COMDAT

; 3302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3303 : 	// need to generate 2x2 samples for every one in input
; 3304 : 	int i, t0, t1;
; 3305 : 	if (w == 1) {

	cmp	DWORD PTR _w$[ebp], 1
	jne	SHORT $LN5@stbi__resa

; 3306 : 		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	lea	ecx, DWORD PTR [ecx+eax+2]
	sar	ecx, 2
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR tv78[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3307 : 		return out;

	mov	eax, DWORD PTR _out$[ebp]
	jmp	$LN1@stbi__resa
$LN5@stbi__resa:

; 3308 : 	}
; 3309 : 
; 3310 : 	t1 = 3 * in_near[0] + in_far[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_near$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in_far$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	add	ecx, eax
	mov	DWORD PTR _t1$[ebp], ecx

; 3311 : 	out[0] = stbi__div4(t1 + 2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 3312 : 	for (i = 1; i < w; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN3@stbi__resa

; 3313 : 		t0 = t1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	DWORD PTR _t0$[ebp], eax

; 3314 : 		t1 = 3 * in_near[i] + in_far[i];

	mov	eax, DWORD PTR _in_near$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	edx, ecx
	mov	DWORD PTR _t1$[ebp], edx

; 3315 : 		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);

	imul	eax, DWORD PTR _t0$[ebp], 3
	mov	ecx, DWORD PTR _t1$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2-1], dl

; 3316 : 		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	imul	eax, DWORD PTR _t1$[ebp], 3
	mov	ecx, DWORD PTR _t0$[ebp]
	lea	edx, DWORD PTR [eax+ecx+8]
	sar	edx, 4
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2], dl

; 3317 : 	}

	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3318 : 	out[w * 2 - 1] = stbi__div4(t1 + 2);

	mov	eax, DWORD PTR _t1$[ebp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx*2-1], al

; 3319 : 
; 3320 : 	STBI_NOTUSED(hs);
; 3321 : 
; 3322 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@stbi__resa:

; 3323 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__resample_row_hv_2@@YAPAEPAE00HH@Z ENDP		; stbi__resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__resample_row_h_2@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
_n$1 = -32						; size = 4
_input$ = -20						; size = 4
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?stbi__resample_row_h_2@@YAPAEPAE00HH@Z PROC		; stbi__resample_row_h_2, COMDAT

; 3272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3273 : 	// need to generate two samples horizontally for every one in input
; 3274 : 	int i;
; 3275 : 	stbi_uc* input = in_near;

	mov	eax, DWORD PTR _in_near$[ebp]
	mov	DWORD PTR _input$[ebp], eax

; 3276 : 
; 3277 : 	if (w == 1) {

	cmp	DWORD PTR _w$[ebp], 1
	jne	SHORT $LN5@stbi__resa

; 3278 : 		// if only one sample, can't do any interpolation
; 3279 : 		out[0] = out[1] = input[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _input$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl

; 3280 : 		return out;

	mov	eax, DWORD PTR _out$[ebp]
	jmp	$LN1@stbi__resa
$LN5@stbi__resa:

; 3281 : 	}
; 3282 : 
; 3283 : 	out[0] = input[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _input$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl

; 3284 : 	out[1] = stbi__div4(input[0] * 3 + input[1] + 2);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, eax, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _input$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	lea	eax, DWORD PTR [ecx+edx+2]
	sar	eax, 2
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3285 : 	for (i = 1; i < w - 1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR _w$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@stbi__resa

; 3286 : 		int n = 3 * input[i] + 2;

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	add	edx, 2
	mov	DWORD PTR _n$1[ebp], edx

; 3287 : 		out[i * 2 + 0] = stbi__div4(n + input[i - 1]);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	add	ecx, DWORD PTR _n$1[ebp]
	sar	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx*2], cl

; 3288 : 		out[i * 2 + 1] = stbi__div4(n + input[i + 1]);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _n$1[ebp]
	sar	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx*2+1], cl

; 3289 : 	}

	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3290 : 	out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	movzx	ecx, BYTE PTR [eax-2]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	lea	edx, DWORD PTR [edx+ecx+2]
	sar	edx, 2
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax*2], dl

; 3291 : 	out[i * 2 + 1] = input[w - 1];

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [eax-1]
	mov	BYTE PTR [edx+ecx*2+1], al

; 3292 : 
; 3293 : 	STBI_NOTUSED(in_far);
; 3294 : 	STBI_NOTUSED(hs);
; 3295 : 
; 3296 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@stbi__resa:

; 3297 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__resample_row_h_2@@YAPAEPAE00HH@Z ENDP		; stbi__resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__resample_row_v_2@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?stbi__resample_row_v_2@@YAPAEPAE00HH@Z PROC		; stbi__resample_row_v_2, COMDAT

; 3262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3263 : 	// need to generate two samples vertically for every one in input
; 3264 : 	int i;
; 3265 : 	STBI_NOTUSED(hs);
; 3266 : 	for (i = 0; i < w; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN3@stbi__resa

; 3267 : 		out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);

	mov	eax, DWORD PTR _in_near$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in_far$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	lea	edx, DWORD PTR [edx+ecx+2]
	sar	edx, 2
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3268 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3269 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__resample_row_v_2@@YAPAEPAE00HH@Z ENDP		; stbi__resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?resample_row_1@@YAPAEPAE00HH@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_1@@YAPAEPAE00HH@Z PROC			; resample_row_1, COMDAT

; 3253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3254 : 	STBI_NOTUSED(out);
; 3255 : 	STBI_NOTUSED(in_far);
; 3256 : 	STBI_NOTUSED(w);
; 3257 : 	STBI_NOTUSED(hs);
; 3258 : 	return in_near;

	mov	eax, DWORD PTR _in_near$[ebp]

; 3259 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?resample_row_1@@YAPAEPAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__decode_jpeg_image@@YAHPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_NL$1 = -44						; size = 4
_Ld$2 = -32						; size = 4
_x$3 = -20						; size = 4
_m$ = -8						; size = 4
_j$ = 8							; size = 4
?stbi__decode_jpeg_image@@YAHPAUstbi__jpeg@@@Z PROC	; stbi__decode_jpeg_image, COMDAT

; 3204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3205 : 	int m;
; 3206 : 	for (m = 0; m < 4; m++) {

	mov	DWORD PTR _m$[ebp], 0
	jmp	SHORT $LN4@stbi__deco
$LN2@stbi__deco:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN4@stbi__deco:
	cmp	DWORD PTR _m$[ebp], 4
	jge	SHORT $LN3@stbi__deco

; 3207 : 		j->img_comp[m].raw_data = NULL;

	imul	eax, DWORD PTR _m$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18124], 0

; 3208 : 		j->img_comp[m].raw_coeff = NULL;

	imul	eax, DWORD PTR _m$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 3209 : 	}

	jmp	SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 3210 : 	j->restart_interval = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18436], 0

; 3211 : 	if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN9@stbi__deco:

; 3212 : 	m = stbi__get_marker(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN5@stbi__deco:

; 3213 : 	while (!stbi__EOI(m)) {

	cmp	DWORD PTR _m$[ebp], 217			; 000000d9H
	je	$LN6@stbi__deco

; 3214 : 		if (stbi__SOS(m)) {

	cmp	DWORD PTR _m$[ebp], 218			; 000000daH
	jne	$LN10@stbi__deco

; 3215 : 			if (!stbi__process_scan_header(j)) return 0;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__process_scan_header@@YAHPAUstbi__jpeg@@@Z ; stbi__process_scan_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN12@stbi__deco:

; 3216 : 			if (!stbi__parse_entropy_coded_data(j)) return 0;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__parse_entropy_coded_data@@YAHPAUstbi__jpeg@@@Z ; stbi__parse_entropy_coded_data
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN13@stbi__deco:

; 3217 : 			if (j->marker == STBI__MARKER_none) {

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN14@stbi__deco
$LN7@stbi__deco:

; 3218 : 				// handle 0s at the end of image data from IP Kamera 9060
; 3219 : 				while (!stbi__at_eof(j->s)) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@stbi__deco

; 3220 : 					int x = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _x$3[ebp], edx

; 3221 : 					if (x == 255) {

	cmp	DWORD PTR _x$3[ebp], 255		; 000000ffH
	jne	SHORT $LN15@stbi__deco

; 3222 : 						j->marker = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR [edx+18372], al

; 3223 : 						break;

	jmp	SHORT $LN14@stbi__deco
$LN15@stbi__deco:

; 3224 : 					}
; 3225 : 				}

	jmp	SHORT $LN7@stbi__deco
$LN14@stbi__deco:

; 3226 : 				// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3227 : 			}
; 3228 : 		}

	jmp	SHORT $LN11@stbi__deco
$LN10@stbi__deco:

; 3229 : 		else if (stbi__DNL(m)) {

	cmp	DWORD PTR _m$[ebp], 220			; 000000dcH
	jne	SHORT $LN16@stbi__deco

; 3230 : 			int Ld = stbi__get16be(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Ld$2[ebp], eax

; 3231 : 			stbi__uint32 NL = stbi__get16be(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _NL$1[ebp], eax

; 3232 : 			if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

	cmp	DWORD PTR _Ld$2[ebp], 4
	je	SHORT $LN18@stbi__deco
	push	OFFSET ??_C@_0M@EPMOIECP@bad?5DNL?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__deco
$LN18@stbi__deco:

; 3233 : 			if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _NL$1[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN19@stbi__deco
	push	OFFSET ??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__deco
$LN19@stbi__deco:

; 3234 : 		}

	jmp	SHORT $LN11@stbi__deco
$LN16@stbi__deco:

; 3235 : 		else {
; 3236 : 			if (!stbi__process_marker(j, m)) return 0;

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z ; stbi__process_marker
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN11@stbi__deco:

; 3237 : 		}
; 3238 : 		m = stbi__get_marker(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3239 : 	}

	jmp	$LN5@stbi__deco
$LN6@stbi__deco:

; 3240 : 	if (j->progressive)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	SHORT $LN21@stbi__deco

; 3241 : 		stbi__jpeg_finish(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_finish@@YAXPAUstbi__jpeg@@@Z ; stbi__jpeg_finish
	add	esp, 4
$LN21@stbi__deco:

; 3242 : 	return 1;

	mov	eax, 1
$LN1@stbi__deco:

; 3243 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__decode_jpeg_image@@YAHPAUstbi__jpeg@@@Z ENDP	; stbi__decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
tv131 = -208						; size = 4
_m$ = -8						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z PROC	; stbi__decode_jpeg_header, COMDAT

; 3179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3180 : 	int m;
; 3181 : 	z->jfif = 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18404], 0

; 3182 : 	z->app14_color_transform = -1; // valid values are 0,1,2

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18408], -1

; 3183 : 	z->marker = STBI__MARKER_none; // initialize cached marker to empty

	mov	eax, DWORD PTR _z$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH

; 3184 : 	m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3185 : 	if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");

	cmp	DWORD PTR _m$[ebp], 216			; 000000d8H
	je	SHORT $LN6@stbi__deco
	push	OFFSET ??_C@_06CLMBLEP@no?5SOI@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__deco
$LN6@stbi__deco:

; 3186 : 	if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR _scan$[ebp], 1
	jne	SHORT $LN7@stbi__deco
	mov	eax, 1
	jmp	$LN1@stbi__deco
$LN7@stbi__deco:

; 3187 : 	m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN2@stbi__deco:

; 3188 : 	while (!stbi__SOF(m)) {

	cmp	DWORD PTR _m$[ebp], 192			; 000000c0H
	je	$LN3@stbi__deco
	cmp	DWORD PTR _m$[ebp], 193			; 000000c1H
	je	SHORT $LN3@stbi__deco
	cmp	DWORD PTR _m$[ebp], 194			; 000000c2H
	je	SHORT $LN3@stbi__deco

; 3189 : 		if (!stbi__process_marker(z, m)) return 0;

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	?stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z ; stbi__process_marker
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN8@stbi__deco:

; 3190 : 		m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx
$LN4@stbi__deco:

; 3191 : 		while (m == STBI__MARKER_none) {

	cmp	DWORD PTR _m$[ebp], 255			; 000000ffH
	jne	SHORT $LN5@stbi__deco

; 3192 : 			// some files have extra padding after their blocks, so ok, we'll scan
; 3193 : 			if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@stbi__deco
	push	OFFSET ??_C@_06IFCEAHIA@no?5SOF@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 3194 : 			m = stbi__get_marker(z);

	mov	eax, DWORD PTR _z$[ebp]
	push	eax
	call	?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z	; stbi__get_marker
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _m$[ebp], ecx

; 3195 : 		}

	jmp	SHORT $LN4@stbi__deco
$LN5@stbi__deco:

; 3196 : 	}

	jmp	$LN2@stbi__deco
$LN3@stbi__deco:

; 3197 : 	z->progressive = stbi__SOF_progressive(m);

	cmp	DWORD PTR _m$[ebp], 194			; 000000c2H
	jne	SHORT $LN12@stbi__deco
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN13@stbi__deco
$LN12@stbi__deco:
	mov	DWORD PTR tv131[ebp], 0
$LN13@stbi__deco:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR [eax+18380], ecx

; 3198 : 	if (!stbi__process_frame_header(z, scan)) return 0;

	mov	eax, DWORD PTR _scan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	?stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z ; stbi__process_frame_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 3199 : 	return 1;

	mov	eax, 1
$LN1@stbi__deco:

; 3200 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z ENDP	; stbi__decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
_c$ = -92						; size = 4
_v_max$ = -80						; size = 4
_h_max$ = -68						; size = 4
_q$ = -56						; size = 4
_i$ = -44						; size = 4
_p$ = -32						; size = 4
_Lf$ = -20						; size = 4
_s$ = -8						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
?stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z PROC	; stbi__process_frame_header, COMDAT

; 3087 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3088 : 	stbi__context* s = z->s;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 3089 : 	int Lf, p, i, q, h_max = 1, v_max = 1, c;

	mov	DWORD PTR _h_max$[ebp], 1
	mov	DWORD PTR _v_max$[ebp], 1

; 3090 : 	Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Lf$[ebp], eax
	cmp	DWORD PTR _Lf$[ebp], 11			; 0000000bH
	jge	SHORT $LN14@stbi__proc
	push	OFFSET ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN14@stbi__proc:

; 3091 : 	p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _p$[ebp], ecx
	cmp	DWORD PTR _p$[ebp], 8
	je	SHORT $LN15@stbi__proc
	push	OFFSET ??_C@_0L@BCINMEBJ@only?58?9bit@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN15@stbi__proc:

; 3092 : 	s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN16@stbi__proc
	push	OFFSET ??_C@_0BB@LNEGOMA@no?5header?5height@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN16@stbi__proc:

; 3093 : 	s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@stbi__proc
	push	OFFSET ??_C@_07BIDACDEF@0?5width@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN17@stbi__proc:

; 3094 : 	c = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _c$[ebp], ecx

; 3095 : 	if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count", "Corrupt JPEG");

	cmp	DWORD PTR _c$[ebp], 3
	je	SHORT $LN18@stbi__proc
	cmp	DWORD PTR _c$[ebp], 1
	je	SHORT $LN18@stbi__proc
	cmp	DWORD PTR _c$[ebp], 4
	je	SHORT $LN18@stbi__proc
	push	OFFSET ??_C@_0BE@DAPHADHL@bad?5component?5count@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN18@stbi__proc:

; 3096 : 	s->img_n = c;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3097 : 	for (i = 0; i < c; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN3@stbi__proc

; 3098 : 		z->img_comp[i].data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], 0

; 3099 : 		z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0

; 3100 : 	}

	jmp	SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 3101 : 
; 3102 : 	if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

	mov	eax, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [eax+8], 3
	add	ecx, 8
	cmp	DWORD PTR _Lf$[ebp], ecx
	je	SHORT $LN19@stbi__proc
	push	OFFSET ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN19@stbi__proc:

; 3103 : 
; 3104 : 	z->rgb = 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18412], 0

; 3105 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__proc
$LN5@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN6@stbi__proc

; 3106 : 		static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3107 : 		z->img_comp[i].id = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18076], ecx

; 3108 : 		if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN20@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR ?rgb@?BC@??stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z@4QBEB[ecx]
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18076], edx
	jne	SHORT $LN20@stbi__proc

; 3109 : 			++z->rgb;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+18412]
	add	ecx, 1
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18412], ecx
$LN20@stbi__proc:

; 3110 : 		q = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _q$[ebp], ecx

; 3111 : 		z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");

	mov	eax, DWORD PTR _q$[ebp]
	sar	eax, 4
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18080], eax
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18080], 0
	je	SHORT $LN22@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18080], 4
	jle	SHORT $LN21@stbi__proc
$LN22@stbi__proc:
	push	OFFSET ??_C@_05BLPKENEJ@bad?5H@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN21@stbi__proc:

; 3112 : 		z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");

	mov	eax, DWORD PTR _q$[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18084], eax
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18084], 0
	je	SHORT $LN24@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18084], 4
	jle	SHORT $LN23@stbi__proc
$LN24@stbi__proc:
	push	OFFSET ??_C@_05MPLLHCJG@bad?5V@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN23@stbi__proc:

; 3113 : 		z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18088], ecx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18088], 3
	jle	SHORT $LN25@stbi__proc
	push	OFFSET ??_C@_06LJIHDFHI@bad?5TQ@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN25@stbi__proc:

; 3114 : 	}

	jmp	$LN5@stbi__proc
$LN6@stbi__proc:

; 3115 : 
; 3116 : 	if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR _scan$[ebp], 0
	je	SHORT $LN26@stbi__proc
	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN26@stbi__proc:

; 3117 : 
; 3118 : 	if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN27@stbi__proc
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN27@stbi__proc:

; 3119 : 
; 3120 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@stbi__proc
$LN8@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN9@stbi__proc

; 3121 : 		if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18080]
	cmp	edx, DWORD PTR _h_max$[ebp]
	jle	SHORT $LN28@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18080]
	mov	DWORD PTR _h_max$[ebp], edx
$LN28@stbi__proc:

; 3122 : 		if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18084]
	cmp	edx, DWORD PTR _v_max$[ebp]
	jle	SHORT $LN29@stbi__proc
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18084]
	mov	DWORD PTR _v_max$[ebp], edx
$LN29@stbi__proc:

; 3123 : 	}

	jmp	SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 3124 : 
; 3125 : 	// compute interleaved mcu info
; 3126 : 	z->img_h_max = h_max;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _h_max$[ebp]
	mov	DWORD PTR [eax+18052], ecx

; 3127 : 	z->img_v_max = v_max;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _v_max$[ebp]
	mov	DWORD PTR [eax+18056], ecx

; 3128 : 	z->img_mcu_w = h_max * 8;

	mov	eax, DWORD PTR _h_max$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18068], eax

; 3129 : 	z->img_mcu_h = v_max * 8;

	mov	eax, DWORD PTR _v_max$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18072], eax

; 3130 : 	// these sizes can't be more than 17 bits
; 3131 : 	z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18068]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _z$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+18068]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18060], eax

; 3132 : 	z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18072]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _z$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+18072]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18064], eax

; 3133 : 
; 3134 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@stbi__proc
$LN11@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@stbi__proc:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN12@stbi__proc

; 3135 : 		// number of effective pixels (e.g. for non-interleaved MCU)
; 3136 : 		z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, DWORD PTR [edx+eax+18080]
	mov	edx, DWORD PTR _h_max$[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	xor	edx, edx
	div	DWORD PTR _h_max$[ebp]
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18104], eax

; 3137 : 		z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	imul	ecx, DWORD PTR [edx+eax+18084]
	mov	edx, DWORD PTR _v_max$[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	xor	edx, edx
	div	DWORD PTR _v_max$[ebp]
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18108], eax

; 3138 : 		// to simplify generation, we'll allocate enough memory to decode
; 3139 : 		// the bogus oversized data from using interleaved MCUs and their
; 3140 : 		// big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3141 : 		// discard the extra data until colorspace conversion
; 3142 : 		//
; 3143 : 		// img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3144 : 		// so these muls can't overflow with 32-bit ints (which we require)
; 3145 : 		z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+18060]
	imul	ecx, DWORD PTR [edx+eax+18080]
	shl	ecx, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18112], ecx

; 3146 : 		z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+18064]
	imul	ecx, DWORD PTR [edx+eax+18084]
	shl	ecx, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+edx+18116], ecx

; 3147 : 		z->img_comp[i].coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], 0

; 3148 : 		z->img_comp[i].raw_coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 3149 : 		z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0

; 3150 : 		z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

	push	15					; 0000000fH
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18116]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18112]
	push	edx
	call	?stbi__malloc_mad2@@YAPAXHHH@Z		; stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18124], eax

; 3151 : 		if (z->img_comp[i].raw_data == NULL)

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18124], 0
	jne	SHORT $LN30@stbi__proc

; 3152 : 			return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
	add	esp, 12					; 0000000cH
	jmp	$LN1@stbi__proc
$LN30@stbi__proc:

; 3153 : 		// align blocks for idct using mmx/sse
; 3154 : 		z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18124]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], edx

; 3155 : 		if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	$LN31@stbi__proc

; 3156 : 			// w2, h2 are multiples of 8 (see above)
; 3157 : 			z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [ecx+eax+18112]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+edx+18140], eax

; 3158 : 			z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [ecx+eax+18116]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	edx, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+edx+18144], eax

; 3159 : 			z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

	push	15					; 0000000fH
	push	2
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18116]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18112]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR _i$[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18128], eax

; 3160 : 			if (z->img_comp[i].raw_coeff == NULL)

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18128], 0
	jne	SHORT $LN32@stbi__proc

; 3161 : 				return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@stbi__proc
$LN32@stbi__proc:

; 3162 : 			z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18128]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], edx
$LN31@stbi__proc:

; 3163 : 		}
; 3164 : 	}

	jmp	$LN11@stbi__proc
$LN12@stbi__proc:

; 3165 : 
; 3166 : 	return 1;

	mov	eax, 1
$LN1@stbi__proc:

; 3167 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__process_frame_header@@YAHPAUstbi__jpeg@@H@Z ENDP	; stbi__process_frame_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_z$ = 8							; size = 4
_ncomp$ = 12						; size = 4
_why$ = 16						; size = 4
?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z PROC ; stbi__free_jpeg_components, COMDAT

; 3065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3066 : 	int i;
; 3067 : 	for (i = 0; i < ncomp; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__free
$LN2@stbi__free:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__free:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _ncomp$[ebp]
	jge	$LN3@stbi__free

; 3068 : 		if (z->img_comp[i].raw_data) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18124], 0
	je	SHORT $LN5@stbi__free

; 3069 : 			STBI_FREE(z->img_comp[i].raw_data);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	esi, esp
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18124]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3070 : 			z->img_comp[i].raw_data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18124], 0

; 3071 : 			z->img_comp[i].data = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18120], 0
$LN5@stbi__free:

; 3072 : 		}
; 3073 : 		if (z->img_comp[i].raw_coeff) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18128], 0
	je	SHORT $LN6@stbi__free

; 3074 : 			STBI_FREE(z->img_comp[i].raw_coeff);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	esi, esp
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18128]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3075 : 			z->img_comp[i].raw_coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18128], 0

; 3076 : 			z->img_comp[i].coeff = 0;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18136], 0
$LN6@stbi__free:

; 3077 : 		}
; 3078 : 		if (z->img_comp[i].linebuf) {

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18132], 0
	je	SHORT $LN7@stbi__free

; 3079 : 			STBI_FREE(z->img_comp[i].linebuf);

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	esi, esp
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18132]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3080 : 			z->img_comp[i].linebuf = NULL;

	imul	eax, DWORD PTR _i$[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax+18132], 0
$LN7@stbi__free:

; 3081 : 		}
; 3082 : 	}

	jmp	$LN2@stbi__free
$LN3@stbi__free:

; 3083 : 	return why;

	mov	eax, DWORD PTR _why$[ebp]

; 3084 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__free_jpeg_components@@YAHPAUstbi__jpeg@@HH@Z ENDP ; stbi__free_jpeg_components
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__process_scan_header@@YAHPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_aa$1 = -68						; size = 4
_q$2 = -56						; size = 4
_which$3 = -44						; size = 4
_id$4 = -32						; size = 4
_Ls$ = -20						; size = 4
_i$ = -8						; size = 4
_z$ = 8							; size = 4
?stbi__process_scan_header@@YAHPAUstbi__jpeg@@@Z PROC	; stbi__process_scan_header, COMDAT

; 3025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3026 : 	int i;
; 3027 : 	int Ls = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _Ls$[ebp], eax

; 3028 : 	z->scan_n = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18416], edx

; 3029 : 	if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18416], 1
	jl	SHORT $LN9@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18416], 4
	jg	SHORT $LN9@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18416]
	cmp	eax, DWORD PTR [ecx+8]
	jle	SHORT $LN8@stbi__proc
$LN9@stbi__proc:
	push	OFFSET ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN8@stbi__proc:

; 3030 : 	if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+18416]
	lea	edx, DWORD PTR [ecx+ecx+6]
	cmp	DWORD PTR _Ls$[ebp], edx
	je	SHORT $LN10@stbi__proc
	push	OFFSET ??_C@_0M@GNEHAHOH@bad?5SOS?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN10@stbi__proc:

; 3031 : 	for (i = 0; i < z->scan_n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__proc:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN3@stbi__proc

; 3032 : 		int id = stbi__get8(z->s), which;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _id$4[ebp], edx

; 3033 : 		int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$2[ebp], edx

; 3034 : 		for (which = 0; which < z->s->img_n; ++which)

	mov	DWORD PTR _which$3[ebp], 0
	jmp	SHORT $LN7@stbi__proc
$LN5@stbi__proc:
	mov	eax, DWORD PTR _which$3[ebp]
	add	eax, 1
	mov	DWORD PTR _which$3[ebp], eax
$LN7@stbi__proc:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _which$3[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN6@stbi__proc

; 3035 : 			if (z->img_comp[which].id == id)

	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18076]
	cmp	edx, DWORD PTR _id$4[ebp]
	jne	SHORT $LN11@stbi__proc

; 3036 : 				break;

	jmp	SHORT $LN6@stbi__proc
$LN11@stbi__proc:
	jmp	SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 3037 : 		if (which == z->s->img_n) return 0; // no match

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _which$3[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN12@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN12@stbi__proc:

; 3038 : 		z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");

	mov	eax, DWORD PTR _q$2[ebp]
	sar	eax, 4
	imul	ecx, DWORD PTR _which$3[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18092], eax
	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18092], 3
	jle	SHORT $LN13@stbi__proc
	push	OFFSET ??_C@_0M@NOCCBFAC@bad?5DC?5huff@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN13@stbi__proc:

; 3039 : 		z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");

	mov	eax, DWORD PTR _q$2[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _which$3[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+ecx+18096], eax
	imul	eax, DWORD PTR _which$3[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [ecx+eax+18096], 3
	jle	SHORT $LN14@stbi__proc
	push	OFFSET ??_C@_0M@JGMCBLGG@bad?5AC?5huff@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN14@stbi__proc:

; 3040 : 		z->order[i] = which;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _which$3[ebp]
	mov	DWORD PTR [ecx+eax*4+18420], edx

; 3041 : 	}

	jmp	$LN2@stbi__proc
$LN3@stbi__proc:

; 3042 : 
; 3043 : 	{
; 3044 : 		int aa;
; 3045 : 		z->spec_start = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18384], edx

; 3046 : 		z->spec_end = stbi__get8(z->s); // should be 63, but might be 0

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18388], edx

; 3047 : 		aa = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _aa$1[ebp], edx

; 3048 : 		z->succ_high = (aa >> 4);

	mov	eax, DWORD PTR _aa$1[ebp]
	sar	eax, 4
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18392], eax

; 3049 : 		z->succ_low = (aa & 15);

	mov	eax, DWORD PTR _aa$1[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+18396], eax

; 3050 : 		if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	SHORT $LN15@stbi__proc

; 3051 : 			if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18384], 63		; 0000003fH
	jg	SHORT $LN18@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18388], 63		; 0000003fH
	jg	SHORT $LN18@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+18384]
	cmp	edx, DWORD PTR [ecx+18388]
	jg	SHORT $LN18@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18392], 13		; 0000000dH
	jg	SHORT $LN18@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18396], 13		; 0000000dH
	jle	SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3052 : 				return stbi__err("bad SOS", "Corrupt JPEG");

	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 3053 : 		}

	jmp	SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 3054 : 		else {
; 3055 : 			if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18384], 0
	je	SHORT $LN19@stbi__proc
	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 3056 : 			if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	SHORT $LN21@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18396], 0
	je	SHORT $LN20@stbi__proc
$LN21@stbi__proc:
	push	OFFSET ??_C@_07EEJOMGGP@bad?5SOS@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 3057 : 			z->spec_end = 63;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18388], 63		; 0000003fH
$LN16@stbi__proc:

; 3058 : 		}
; 3059 : 	}
; 3060 : 
; 3061 : 	return 1;

	mov	eax, 1
$LN1@stbi__proc:

; 3062 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__process_scan_header@@YAHPAUstbi__jpeg@@@Z ENDP	; stbi__process_scan_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
tv222 = -464						; size = 4
tv153 = -464						; size = 4
tv150 = -464						; size = 4
tv147 = -464						; size = 4
tv88 = -464						; size = 4
tv64 = -464						; size = 4
_i$1 = -264						; size = 4
_ok$2 = -252						; size = 4
_i$3 = -240						; size = 4
_ok$4 = -228						; size = 4
_th$5 = -216						; size = 4
_tc$6 = -204						; size = 4
_q$7 = -192						; size = 4
_n$8 = -180						; size = 4
_i$9 = -168						; size = 4
_sizes$10 = -156					; size = 64
_v$11 = -84						; size = 4
_i$12 = -72						; size = 4
_t$13 = -60						; size = 4
_sixteen$14 = -48					; size = 4
_p$15 = -36						; size = 4
_q$16 = -24						; size = 4
_L$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_m$ = 12						; size = 4
?stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z PROC	; stbi__process_marker, COMDAT

; 2920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-464]
	mov	ecx, 116				; 00000074H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2921 : 	int L;
; 2922 : 	switch (m) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 196				; 000000c4H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 59			; 0000003bH
	ja	$LN2@stbi__proc
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN61@stbi__proc[edx]
	jmp	DWORD PTR $LN62@stbi__proc[eax*4]
$LN23@stbi__proc:

; 2923 : 	case STBI__MARKER_none: // no marker found
; 2924 : 		return stbi__err("expected marker", "Corrupt JPEG");

	push	OFFSET ??_C@_0BA@KLNDOKJD@expected?5marker@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:

; 2925 : 
; 2926 : 	case 0xDD: // DRI - specify restart interval
; 2927 : 		if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 4
	je	SHORT $LN25@stbi__proc
	push	OFFSET ??_C@_0M@LPHNODCG@bad?5DRI?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN25@stbi__proc:

; 2928 : 		z->restart_interval = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+18436], eax

; 2929 : 		return 1;

	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN26@stbi__proc:

; 2930 : 
; 2931 : 	case 0xDB: // DQT - define quantization table
; 2932 : 		L = stbi__get16be(z->s) - 2;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax
$LN4@stbi__proc:

; 2933 : 		while (L > 0) {

	cmp	DWORD PTR _L$[ebp], 0
	jle	$LN5@stbi__proc

; 2934 : 			int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$16[ebp], edx

; 2935 : 			int p = q >> 4, sixteen = (p != 0);

	mov	eax, DWORD PTR _q$16[ebp]
	sar	eax, 4
	mov	DWORD PTR _p$15[ebp], eax
	cmp	DWORD PTR _p$15[ebp], 0
	je	SHORT $LN51@stbi__proc
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN52@stbi__proc
$LN51@stbi__proc:
	mov	DWORD PTR tv88[ebp], 0
$LN52@stbi__proc:
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR _sixteen$14[ebp], eax

; 2936 : 			int t = q & 15, i;

	mov	eax, DWORD PTR _q$16[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _t$13[ebp], eax

; 2937 : 			if (p != 0 && p != 1) return stbi__err("bad DQT type", "Corrupt JPEG");

	cmp	DWORD PTR _p$15[ebp], 0
	je	SHORT $LN27@stbi__proc
	cmp	DWORD PTR _p$15[ebp], 1
	je	SHORT $LN27@stbi__proc
	push	OFFSET ??_C@_0N@BOFJCHAP@bad?5DQT?5type@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN27@stbi__proc:

; 2938 : 			if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");

	cmp	DWORD PTR _t$13[ebp], 3
	jle	SHORT $LN28@stbi__proc
	push	OFFSET ??_C@_0O@CNHKKDIM@bad?5DQT?5table@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN28@stbi__proc:

; 2939 : 
; 2940 : 			for (i = 0; i < 64; ++i)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN8@stbi__proc
$LN6@stbi__proc:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN8@stbi__proc:
	cmp	DWORD PTR _i$12[ebp], 64		; 00000040H
	jge	SHORT $LN7@stbi__proc

; 2941 : 				z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

	cmp	DWORD PTR _sixteen$14[ebp], 0
	je	SHORT $LN53@stbi__proc
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN54@stbi__proc
$LN53@stbi__proc:
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv147[ebp], ecx
$LN54@stbi__proc:
	mov	edx, DWORD PTR _t$13[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebp]
	lea	ecx, DWORD PTR [eax+edx+13444]
	mov	edx, DWORD PTR _i$12[ebp]
	movzx	eax, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[edx]
	mov	dx, WORD PTR tv147[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	jmp	SHORT $LN6@stbi__proc
$LN7@stbi__proc:

; 2942 : 			L -= (sixteen ? 129 : 65);

	cmp	DWORD PTR _sixteen$14[ebp], 0
	je	SHORT $LN55@stbi__proc
	mov	DWORD PTR tv150[ebp], 129		; 00000081H
	jmp	SHORT $LN56@stbi__proc
$LN55@stbi__proc:
	mov	DWORD PTR tv150[ebp], 65		; 00000041H
$LN56@stbi__proc:
	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR _L$[ebp], eax

; 2943 : 		}

	jmp	$LN4@stbi__proc
$LN5@stbi__proc:

; 2944 : 		return L == 0;

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN57@stbi__proc
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN58@stbi__proc
$LN57@stbi__proc:
	mov	DWORD PTR tv153[ebp], 0
$LN58@stbi__proc:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN1@stbi__proc
$LN29@stbi__proc:

; 2945 : 
; 2946 : 	case 0xC4: // DHT - define huffman table
; 2947 : 		L = stbi__get16be(z->s) - 2;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax
$LN9@stbi__proc:

; 2948 : 		while (L > 0) {

	cmp	DWORD PTR _L$[ebp], 0
	jle	$LN10@stbi__proc

; 2949 : 			stbi_uc* v;
; 2950 : 			int sizes[16], i, n = 0;

	mov	DWORD PTR _n$8[ebp], 0

; 2951 : 			int q = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _q$7[ebp], edx

; 2952 : 			int tc = q >> 4;

	mov	eax, DWORD PTR _q$7[ebp]
	sar	eax, 4
	mov	DWORD PTR _tc$6[ebp], eax

; 2953 : 			int th = q & 15;

	mov	eax, DWORD PTR _q$7[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _th$5[ebp], eax

; 2954 : 			if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");

	cmp	DWORD PTR _tc$6[ebp], 1
	jg	SHORT $LN31@stbi__proc
	cmp	DWORD PTR _th$5[ebp], 3
	jle	SHORT $LN30@stbi__proc
$LN31@stbi__proc:
	push	OFFSET ??_C@_0P@JLGKOCGN@bad?5DHT?5header@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN30@stbi__proc:

; 2955 : 			for (i = 0; i < 16; ++i) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN13@stbi__proc
$LN11@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN13@stbi__proc:
	cmp	DWORD PTR _i$9[ebp], 16			; 00000010H
	jge	SHORT $LN12@stbi__proc

; 2956 : 				sizes[i] = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$9[ebp]
	mov	DWORD PTR _sizes$10[ebp+eax*4], edx

; 2957 : 				n += sizes[i];

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _n$8[ebp]
	add	ecx, DWORD PTR _sizes$10[ebp+eax*4]
	mov	DWORD PTR _n$8[ebp], ecx

; 2958 : 			}

	jmp	SHORT $LN11@stbi__proc
$LN12@stbi__proc:

; 2959 : 			L -= 17;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 17					; 00000011H
	mov	DWORD PTR _L$[ebp], eax

; 2960 : 			if (tc == 0) {

	cmp	DWORD PTR _tc$6[ebp], 0
	jne	SHORT $LN32@stbi__proc

; 2961 : 				if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;

	lea	eax, DWORD PTR _sizes$10[ebp]
	push	eax
	imul	ecx, DWORD PTR _th$5[ebp], 1680
	mov	edx, DWORD PTR _z$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	?stbi__build_huffman@@YAHPAUstbi__huffman@@PAH@Z ; stbi__build_huffman
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN34@stbi__proc:

; 2962 : 				v = z->huff_dc[th].values;

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1028]
	mov	DWORD PTR _v$11[ebp], edx

; 2963 : 			}

	jmp	SHORT $LN33@stbi__proc
$LN32@stbi__proc:

; 2964 : 			else {
; 2965 : 				if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;

	lea	eax, DWORD PTR _sizes$10[ebp]
	push	eax
	imul	ecx, DWORD PTR _th$5[ebp], 1680
	mov	edx, DWORD PTR _z$[ebp]
	lea	eax, DWORD PTR [edx+ecx+6724]
	push	eax
	call	?stbi__build_huffman@@YAHPAUstbi__huffman@@PAH@Z ; stbi__build_huffman
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN35@stbi__proc:

; 2966 : 				v = z->huff_ac[th].values;

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+7748]
	mov	DWORD PTR _v$11[ebp], edx
$LN33@stbi__proc:

; 2967 : 			}
; 2968 : 			for (i = 0; i < n; ++i)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN16@stbi__proc
$LN14@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN16@stbi__proc:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _n$8[ebp]
	jge	SHORT $LN15@stbi__proc

; 2969 : 				v[i] = stbi__get8(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	edx, DWORD PTR _v$11[ebp]
	add	edx, DWORD PTR _i$9[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 2970 : 			if (tc != 0)

	cmp	DWORD PTR _tc$6[ebp], 0
	je	SHORT $LN36@stbi__proc

; 2971 : 				stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

	imul	eax, DWORD PTR _th$5[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	mov	eax, DWORD PTR _th$5[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebp]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	call	?stbi__build_fast_ac@@YAXPAFPAUstbi__huffman@@@Z ; stbi__build_fast_ac
	add	esp, 8
$LN36@stbi__proc:

; 2972 : 			L -= n;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, DWORD PTR _n$8[ebp]
	mov	DWORD PTR _L$[ebp], eax

; 2973 : 		}

	jmp	$LN9@stbi__proc
$LN10@stbi__proc:

; 2974 : 		return L == 0;

	cmp	DWORD PTR _L$[ebp], 0
	jne	SHORT $LN59@stbi__proc
	mov	DWORD PTR tv222[ebp], 1
	jmp	SHORT $LN60@stbi__proc
$LN59@stbi__proc:
	mov	DWORD PTR tv222[ebp], 0
$LN60@stbi__proc:
	mov	eax, DWORD PTR tv222[ebp]
	jmp	$LN1@stbi__proc
$LN2@stbi__proc:

; 2975 : 	}
; 2976 : 
; 2977 : 	// check for comment block or APP blocks
; 2978 : 	if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

	cmp	DWORD PTR _m$[ebp], 224			; 000000e0H
	jl	SHORT $LN39@stbi__proc
	cmp	DWORD PTR _m$[ebp], 239			; 000000efH
	jle	SHORT $LN38@stbi__proc
$LN39@stbi__proc:
	cmp	DWORD PTR _m$[ebp], 254			; 000000feH
	jne	$LN37@stbi__proc
$LN38@stbi__proc:

; 2979 : 		L = stbi__get16be(z->s);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _L$[ebp], eax

; 2980 : 		if (L < 2) {

	cmp	DWORD PTR _L$[ebp], 2
	jge	SHORT $LN40@stbi__proc

; 2981 : 			if (m == 0xFE)

	cmp	DWORD PTR _m$[ebp], 254			; 000000feH
	jne	SHORT $LN41@stbi__proc

; 2982 : 				return stbi__err("bad COM len", "Corrupt JPEG");

	push	OFFSET ??_C@_0M@CICAFFCH@bad?5COM?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
	jmp	SHORT $LN40@stbi__proc
$LN41@stbi__proc:

; 2983 : 			else
; 2984 : 				return stbi__err("bad APP len", "Corrupt JPEG");

	push	OFFSET ??_C@_0M@EENLKPDI@bad?5APP?5len@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__proc
$LN40@stbi__proc:

; 2985 : 		}
; 2986 : 		L -= 2;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 2
	mov	DWORD PTR _L$[ebp], eax

; 2987 : 
; 2988 : 		if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

	cmp	DWORD PTR _m$[ebp], 224			; 000000e0H
	jne	$LN43@stbi__proc
	cmp	DWORD PTR _L$[ebp], 5
	jl	$LN43@stbi__proc

; 2989 : 			static const unsigned char tag[5] = { 'J','F','I','F','\0' };
; 2990 : 			int ok = 1;

	mov	DWORD PTR _ok$4[ebp], 1

; 2991 : 			int i;
; 2992 : 			for (i = 0; i < 5; ++i)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN19@stbi__proc
$LN17@stbi__proc:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN19@stbi__proc:
	cmp	DWORD PTR _i$3[ebp], 5
	jge	SHORT $LN18@stbi__proc

; 2993 : 				if (stbi__get8(z->s) != tag[i])

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$3[ebp]
	movzx	ecx, BYTE PTR ?tag@?CL@??stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z@4QBEB[eax]
	cmp	edx, ecx
	je	SHORT $LN45@stbi__proc

; 2994 : 					ok = 0;

	mov	DWORD PTR _ok$4[ebp], 0
$LN45@stbi__proc:
	jmp	SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 2995 : 			L -= 5;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 5
	mov	DWORD PTR _L$[ebp], eax

; 2996 : 			if (ok)

	cmp	DWORD PTR _ok$4[ebp], 0
	je	SHORT $LN46@stbi__proc

; 2997 : 				z->jfif = 1;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18404], 1
$LN46@stbi__proc:

; 2998 : 		}

	jmp	$LN44@stbi__proc
$LN43@stbi__proc:

; 2999 : 		else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

	cmp	DWORD PTR _m$[ebp], 238			; 000000eeH
	jne	$LN44@stbi__proc
	cmp	DWORD PTR _L$[ebp], 12			; 0000000cH
	jl	$LN44@stbi__proc

; 3000 : 			static const unsigned char tag[6] = { 'A','d','o','b','e','\0' };
; 3001 : 			int ok = 1;

	mov	DWORD PTR _ok$2[ebp], 1

; 3002 : 			int i;
; 3003 : 			for (i = 0; i < 6; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN22@stbi__proc
$LN20@stbi__proc:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN22@stbi__proc:
	cmp	DWORD PTR _i$1[ebp], 6
	jge	SHORT $LN21@stbi__proc

; 3004 : 				if (stbi__get8(z->s) != tag[i])

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR ?tag@?DE@??stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z@4QBEB[eax]
	cmp	edx, ecx
	je	SHORT $LN48@stbi__proc

; 3005 : 					ok = 0;

	mov	DWORD PTR _ok$2[ebp], 0
$LN48@stbi__proc:
	jmp	SHORT $LN20@stbi__proc
$LN21@stbi__proc:

; 3006 : 			L -= 6;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 6
	mov	DWORD PTR _L$[ebp], eax

; 3007 : 			if (ok) {

	cmp	DWORD PTR _ok$2[ebp], 0
	je	SHORT $LN44@stbi__proc

; 3008 : 				stbi__get8(z->s); // version

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4

; 3009 : 				stbi__get16be(z->s); // flags0

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4

; 3010 : 				stbi__get16be(z->s); // flags1

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4

; 3011 : 				z->app14_color_transform = stbi__get8(z->s); // color transform

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+18408], edx

; 3012 : 				L -= 6;

	mov	eax, DWORD PTR _L$[ebp]
	sub	eax, 6
	mov	DWORD PTR _L$[ebp], eax
$LN44@stbi__proc:

; 3013 : 			}
; 3014 : 		}
; 3015 : 
; 3016 : 		stbi__skip(z->s, L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 3017 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__proc
$LN37@stbi__proc:

; 3018 : 	}
; 3019 : 
; 3020 : 	return stbi__err("unknown marker", "Corrupt JPEG");

	push	OFFSET ??_C@_0P@NNGPHMMK@unknown?5marker@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
$LN1@stbi__proc:

; 3021 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN65@stbi__proc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 464				; 000001d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@stbi__proc:
	DD	1
	DD	$LN64@stbi__proc
$LN64@stbi__proc:
	DD	-156					; ffffff64H
	DD	64					; 00000040H
	DD	$LN63@stbi__proc
$LN63@stbi__proc:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
	npad	2
$LN62@stbi__proc:
	DD	$LN29@stbi__proc
	DD	$LN26@stbi__proc
	DD	$LN24@stbi__proc
	DD	$LN23@stbi__proc
	DD	$LN2@stbi__proc
$LN61@stbi__proc:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?stbi__process_marker@@YAHPAUstbi__jpeg@@H@Z ENDP	; stbi__process_marker
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_finish@@YAXPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_data$1 = -68						; size = 4
_h$2 = -56						; size = 4
_w$3 = -44						; size = 4
_n$4 = -32						; size = 4
_j$5 = -20						; size = 4
_i$6 = -8						; size = 4
_z$ = 8							; size = 4
?stbi__jpeg_finish@@YAXPAUstbi__jpeg@@@Z PROC		; stbi__jpeg_finish, COMDAT

; 2901 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2902 : 	if (z->progressive) {

	mov	eax, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [eax+18380], 0
	je	$LN1@stbi__jpeg

; 2903 : 		// dequantize and idct the data
; 2904 : 		int i, j, n;
; 2905 : 		for (n = 0; n < z->s->img_n; ++n) {

	mov	DWORD PTR _n$4[ebp], 0
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR _n$4[ebp]
	add	eax, 1
	mov	DWORD PTR _n$4[ebp], eax
$LN4@stbi__jpeg:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$4[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN1@stbi__jpeg

; 2906 : 			int w = (z->img_comp[n].x + 7) >> 3;

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$3[ebp], edx

; 2907 : 			int h = (z->img_comp[n].y + 7) >> 3;

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$2[ebp], edx

; 2908 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN7@stbi__jpeg:
	mov	eax, DWORD PTR _j$5[ebp]
	cmp	eax, DWORD PTR _h$2[ebp]
	jge	$LN6@stbi__jpeg

; 2909 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN10@stbi__jpeg:
	mov	eax, DWORD PTR _i$6[ebp]
	cmp	eax, DWORD PTR _w$3[ebp]
	jge	$LN9@stbi__jpeg

; 2910 : 					short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$4[ebp], 72
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	esi, DWORD PTR _j$5[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _i$6[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$1[ebp], eax

; 2911 : 					stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebp]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _data$1[ebp]
	push	edx
	call	?stbi__jpeg_dequantize@@YAXPAFPAG@Z	; stbi__jpeg_dequantize
	add	esp, 8

; 2912 : 					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	imul	edx, DWORD PTR _n$4[ebp], 72
	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _j$5[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _i$6[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2913 : 				}

	jmp	$LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 2914 : 			}

	jmp	$LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2915 : 		}

	jmp	$LN2@stbi__jpeg
$LN1@stbi__jpeg:

; 2916 : 	}
; 2917 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_finish@@YAXPAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_finish
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_dequantize@@YAXPAFPAG@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_dequant$ = 12						; size = 4
?stbi__jpeg_dequantize@@YAXPAFPAG@Z PROC		; stbi__jpeg_dequantize, COMDAT

; 2894 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2895 : 	int i;
; 2896 : 	for (i = 0; i < 64; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__jpeg:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN1@stbi__jpeg

; 2897 : 		data[i] *= dequant[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dequant$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	eax, WORD PTR [ecx+eax*2]
	imul	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	jmp	SHORT $LN2@stbi__jpeg
$LN1@stbi__jpeg:

; 2898 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_dequantize@@YAXPAFPAG@Z ENDP		; stbi__jpeg_dequantize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__parse_entropy_coded_data@@YAHPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
tv467 = -1048						; size = 4
tv359 = -1048						; size = 4
tv280 = -1048						; size = 4
tv176 = -1048						; size = 4
_data$1 = -656						; size = 4
_y2$2 = -644						; size = 4
_x2$3 = -632						; size = 4
_n$4 = -620						; size = 4
_y$5 = -608						; size = 4
_x$6 = -596						; size = 4
_k$7 = -584						; size = 4
_j$8 = -572						; size = 4
_i$9 = -560						; size = 4
_ha$10 = -548						; size = 4
_data$11 = -536						; size = 4
_h$12 = -524						; size = 4
_w$13 = -512						; size = 4
_n$14 = -500						; size = 4
_j$15 = -488						; size = 4
_i$16 = -476						; size = 4
_ha$17 = -464						; size = 4
_y2$18 = -452						; size = 4
_x2$19 = -440						; size = 4
_n$20 = -428						; size = 4
_data$21 = -416						; size = 128
_y$22 = -268						; size = 4
_x$23 = -256						; size = 4
_k$24 = -244						; size = 4
_j$25 = -232						; size = 4
_i$26 = -220						; size = 4
_ha$27 = -208						; size = 4
_h$28 = -196						; size = 4
_w$29 = -184						; size = 4
_n$30 = -172						; size = 4
_data$31 = -160						; size = 128
_j$32 = -24						; size = 4
_i$33 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
?stbi__parse_entropy_coded_data@@YAHPAUstbi__jpeg@@@Z PROC ; stbi__parse_entropy_coded_data, COMDAT

; 2766 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 1048				; 00000418H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1048]
	mov	ecx, 262				; 00000106H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2767 : 	stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z	; stbi__jpeg_reset
	add	esp, 4

; 2768 : 	if (!z->progressive) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18380], 0
	jne	$LN44@stbi__pars

; 2769 : 		if (z->scan_n == 1) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18416], 1
	jne	$LN46@stbi__pars

; 2770 : 			int i, j;
; 2771 : 			STBI_SIMD_ALIGN(short, data[64]);
; 2772 : 			int n = z->order[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18420]
	mov	DWORD PTR _n$30[ebp], eax

; 2773 : 			// non-interleaved data, we just need to process one block at a time,
; 2774 : 			// in trivial scanline order
; 2775 : 			// number of blocks to do just depends on how many actual "pixels" this
; 2776 : 			// component has, independent of interleaved MCU blocking and such
; 2777 : 			int w = (z->img_comp[n].x + 7) >> 3;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$29[ebp], edx

; 2778 : 			int h = (z->img_comp[n].y + 7) >> 3;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$28[ebp], edx

; 2779 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR _j$32[ebp], 0
	jmp	SHORT $LN4@stbi__pars
$LN2@stbi__pars:
	mov	eax, DWORD PTR _j$32[ebp]
	add	eax, 1
	mov	DWORD PTR _j$32[ebp], eax
$LN4@stbi__pars:
	mov	eax, DWORD PTR _j$32[ebp]
	cmp	eax, DWORD PTR _h$28[ebp]
	jge	$LN3@stbi__pars

; 2780 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR _i$33[ebp], 0
	jmp	SHORT $LN7@stbi__pars
$LN5@stbi__pars:
	mov	eax, DWORD PTR _i$33[ebp]
	add	eax, 1
	mov	DWORD PTR _i$33[ebp], eax
$LN7@stbi__pars:
	mov	eax, DWORD PTR _i$33[ebp]
	cmp	eax, DWORD PTR _w$29[ebp]
	jge	$LN6@stbi__pars

; 2781 : 					int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$27[ebp], edx

; 2782 : 					if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _n$30[ebp]
	push	edx
	mov	eax, DWORD PTR _ha$27[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$27[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	imul	eax, DWORD PTR _n$30[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	imul	edx, DWORD PTR [ecx+eax+18092], 1680
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	lea	edx, DWORD PTR _data$31[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_decode_block@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@2PAFHPAG@Z ; stbi__jpeg_decode_block
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN48@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN48@stbi__pars:

; 2783 : 					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

	mov	esi, esp
	lea	eax, DWORD PTR _data$31[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$30[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$30[ebp], 72
	imul	edx, DWORD PTR _n$30[ebp], 72
	mov	eax, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _j$32[ebp]
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _i$33[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2784 : 					// every data block is an MCU, so countdown the restart interval
; 2785 : 					if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv176[ebp], 0
	jg	SHORT $LN49@stbi__pars

; 2786 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN50@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN50@stbi__pars:

; 2787 : 						// if it's NOT a restart, then just bail, so we get corrupt data
; 2788 : 						// rather than no data
; 2789 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN52@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN51@stbi__pars
$LN52@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN51@stbi__pars:

; 2790 : 						stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z	; stbi__jpeg_reset
	add	esp, 4
$LN49@stbi__pars:

; 2791 : 					}
; 2792 : 				}

	jmp	$LN5@stbi__pars
$LN6@stbi__pars:

; 2793 : 			}

	jmp	$LN2@stbi__pars
$LN3@stbi__pars:

; 2794 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars

; 2795 : 		}

	jmp	$LN47@stbi__pars
$LN46@stbi__pars:

; 2796 : 		else { // interleaved
; 2797 : 			int i, j, k, x, y;
; 2798 : 			STBI_SIMD_ALIGN(short, data[64]);
; 2799 : 			for (j = 0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR _j$25[ebp], 0
	jmp	SHORT $LN10@stbi__pars
$LN8@stbi__pars:
	mov	eax, DWORD PTR _j$25[ebp]
	add	eax, 1
	mov	DWORD PTR _j$25[ebp], eax
$LN10@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _j$25[ebp]
	cmp	ecx, DWORD PTR [eax+18064]
	jge	$LN9@stbi__pars

; 2800 : 				for (i = 0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR _i$26[ebp], 0
	jmp	SHORT $LN13@stbi__pars
$LN11@stbi__pars:
	mov	eax, DWORD PTR _i$26[ebp]
	add	eax, 1
	mov	DWORD PTR _i$26[ebp], eax
$LN13@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _i$26[ebp]
	cmp	ecx, DWORD PTR [eax+18060]
	jge	$LN12@stbi__pars

; 2801 : 					// scan an interleaved mcu... process scan_n components in order
; 2802 : 					for (k = 0; k < z->scan_n; ++k) {

	mov	DWORD PTR _k$24[ebp], 0
	jmp	SHORT $LN16@stbi__pars
$LN14@stbi__pars:
	mov	eax, DWORD PTR _k$24[ebp]
	add	eax, 1
	mov	DWORD PTR _k$24[ebp], eax
$LN16@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _k$24[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN15@stbi__pars

; 2803 : 						int n = z->order[k];

	mov	eax, DWORD PTR _k$24[ebp]
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax*4+18420]
	mov	DWORD PTR _n$20[ebp], edx

; 2804 : 						// scan out an mcu's worth of this component; that's just determined
; 2805 : 						// by the basic H and V specified for the component
; 2806 : 						for (y = 0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR _y$22[ebp], 0
	jmp	SHORT $LN19@stbi__pars
$LN17@stbi__pars:
	mov	eax, DWORD PTR _y$22[ebp]
	add	eax, 1
	mov	DWORD PTR _y$22[ebp], eax
$LN19@stbi__pars:
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _y$22[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18084]
	jge	$LN18@stbi__pars

; 2807 : 							for (x = 0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR _x$23[ebp], 0
	jmp	SHORT $LN22@stbi__pars
$LN20@stbi__pars:
	mov	eax, DWORD PTR _x$23[ebp]
	add	eax, 1
	mov	DWORD PTR _x$23[ebp], eax
$LN22@stbi__pars:
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _x$23[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18080]
	jge	$LN21@stbi__pars

; 2808 : 								int x2 = (i * z->img_comp[n].h + x) * 8;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _i$26[ebp]
	imul	edx, DWORD PTR [ecx+eax+18080]
	add	edx, DWORD PTR _x$23[ebp]
	shl	edx, 3
	mov	DWORD PTR _x2$19[ebp], edx

; 2809 : 								int y2 = (j * z->img_comp[n].v + y) * 8;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _j$25[ebp]
	imul	edx, DWORD PTR [ecx+eax+18084]
	add	edx, DWORD PTR _y$22[ebp]
	shl	edx, 3
	mov	DWORD PTR _y2$18[ebp], edx

; 2810 : 								int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$17[ebp], edx

; 2811 : 								if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18088]
	shl	edx, 7
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+13444]
	push	ecx
	mov	edx, DWORD PTR _n$20[ebp]
	push	edx
	mov	eax, DWORD PTR _ha$17[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$17[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	imul	eax, DWORD PTR _n$20[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	imul	edx, DWORD PTR [ecx+eax+18092], 1680
	mov	eax, DWORD PTR _z$[ebx]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	lea	edx, DWORD PTR _data$21[ebp]
	push	edx
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_decode_block@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@2PAFHPAG@Z ; stbi__jpeg_decode_block
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN53@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN53@stbi__pars:

; 2812 : 								z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * y2 + x2, z->img_comp[n].w2, data);

	mov	esi, esp
	lea	eax, DWORD PTR _data$21[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$20[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18112]
	push	eax
	imul	ecx, DWORD PTR _n$20[ebp], 72
	imul	edx, DWORD PTR _n$20[ebp], 72
	mov	eax, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [eax+edx+18112]
	imul	edx, DWORD PTR _y2$18[ebp]
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+ecx+18120]
	add	ecx, edx
	add	ecx, DWORD PTR _x2$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+18444]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2813 : 							}

	jmp	$LN20@stbi__pars
$LN21@stbi__pars:

; 2814 : 						}

	jmp	$LN17@stbi__pars
$LN18@stbi__pars:

; 2815 : 					}

	jmp	$LN14@stbi__pars
$LN15@stbi__pars:

; 2816 : 					// after all interleaved components, that's an interleaved MCU,
; 2817 : 					// so now count down the restart interval
; 2818 : 					if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv280[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv280[ebp], 0
	jg	SHORT $LN54@stbi__pars

; 2819 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN55@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN55@stbi__pars:

; 2820 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN57@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN56@stbi__pars
$LN57@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN56@stbi__pars:

; 2821 : 						stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z	; stbi__jpeg_reset
	add	esp, 4
$LN54@stbi__pars:

; 2822 : 					}
; 2823 : 				}

	jmp	$LN11@stbi__pars
$LN12@stbi__pars:

; 2824 : 			}

	jmp	$LN8@stbi__pars
$LN9@stbi__pars:

; 2825 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN47@stbi__pars:

; 2826 : 		}
; 2827 : 	}

	jmp	$LN1@stbi__pars
$LN44@stbi__pars:

; 2828 : 	else {
; 2829 : 		if (z->scan_n == 1) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18416], 1
	jne	$LN58@stbi__pars

; 2830 : 			int i, j;
; 2831 : 			int n = z->order[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR [edx+ecx+18420]
	mov	DWORD PTR _n$14[ebp], eax

; 2832 : 			// non-interleaved data, we just need to process one block at a time,
; 2833 : 			// in trivial scanline order
; 2834 : 			// number of blocks to do just depends on how many actual "pixels" this
; 2835 : 			// component has, independent of interleaved MCU blocking and such
; 2836 : 			int w = (z->img_comp[n].x + 7) >> 3;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18104]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _w$13[ebp], edx

; 2837 : 			int h = (z->img_comp[n].y + 7) >> 3;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18108]
	add	edx, 7
	sar	edx, 3
	mov	DWORD PTR _h$12[ebp], edx

; 2838 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR _j$15[ebp], 0
	jmp	SHORT $LN25@stbi__pars
$LN23@stbi__pars:
	mov	eax, DWORD PTR _j$15[ebp]
	add	eax, 1
	mov	DWORD PTR _j$15[ebp], eax
$LN25@stbi__pars:
	mov	eax, DWORD PTR _j$15[ebp]
	cmp	eax, DWORD PTR _h$12[ebp]
	jge	$LN24@stbi__pars

; 2839 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN28@stbi__pars
$LN26@stbi__pars:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN28@stbi__pars:
	mov	eax, DWORD PTR _i$16[ebp]
	cmp	eax, DWORD PTR _w$13[ebp]
	jge	$LN27@stbi__pars

; 2840 : 					short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$14[ebp], 72
	imul	ecx, DWORD PTR _n$14[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	esi, DWORD PTR _j$15[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _i$16[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$11[ebp], eax

; 2841 : 					if (z->spec_start == 0) {

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18384], 0
	jne	SHORT $LN60@stbi__pars

; 2842 : 						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	mov	eax, DWORD PTR _n$14[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$14[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	imul	eax, DWORD PTR [edx+ecx+18092], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	mov	eax, DWORD PTR _data$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN62@stbi__pars

; 2843 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN62@stbi__pars:

; 2844 : 					}

	jmp	SHORT $LN61@stbi__pars
$LN60@stbi__pars:

; 2845 : 					else {
; 2846 : 						int ha = z->img_comp[n].ha;

	imul	eax, DWORD PTR _n$14[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18096]
	mov	DWORD PTR _ha$10[ebp], edx

; 2847 : 						if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

	mov	eax, DWORD PTR _ha$10[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+13956]
	push	edx
	imul	eax, DWORD PTR _ha$10[ebp], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+6724]
	push	edx
	mov	eax, DWORD PTR _data$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	?stbi__jpeg_decode_block_prog_ac@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@PAF@Z ; stbi__jpeg_decode_block_prog_ac
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN61@stbi__pars

; 2848 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN61@stbi__pars:

; 2849 : 					}
; 2850 : 					// every data block is an MCU, so countdown the restart interval
; 2851 : 					if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv359[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv359[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv359[ebp], 0
	jg	SHORT $LN64@stbi__pars

; 2852 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN65@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN65@stbi__pars:

; 2853 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN67@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN66@stbi__pars
$LN67@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN66@stbi__pars:

; 2854 : 						stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z	; stbi__jpeg_reset
	add	esp, 4
$LN64@stbi__pars:

; 2855 : 					}
; 2856 : 				}

	jmp	$LN26@stbi__pars
$LN27@stbi__pars:

; 2857 : 			}

	jmp	$LN23@stbi__pars
$LN24@stbi__pars:

; 2858 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars

; 2859 : 		}

	jmp	$LN1@stbi__pars
$LN58@stbi__pars:

; 2860 : 		else { // interleaved
; 2861 : 			int i, j, k, x, y;
; 2862 : 			for (j = 0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR _j$8[ebp], 0
	jmp	SHORT $LN31@stbi__pars
$LN29@stbi__pars:
	mov	eax, DWORD PTR _j$8[ebp]
	add	eax, 1
	mov	DWORD PTR _j$8[ebp], eax
$LN31@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _j$8[ebp]
	cmp	ecx, DWORD PTR [eax+18064]
	jge	$LN30@stbi__pars

; 2863 : 				for (i = 0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN34@stbi__pars
$LN32@stbi__pars:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN34@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR [eax+18060]
	jge	$LN33@stbi__pars

; 2864 : 					// scan an interleaved mcu... process scan_n components in order
; 2865 : 					for (k = 0; k < z->scan_n; ++k) {

	mov	DWORD PTR _k$7[ebp], 0
	jmp	SHORT $LN37@stbi__pars
$LN35@stbi__pars:
	mov	eax, DWORD PTR _k$7[ebp]
	add	eax, 1
	mov	DWORD PTR _k$7[ebp], eax
$LN37@stbi__pars:
	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR _k$7[ebp]
	cmp	ecx, DWORD PTR [eax+18416]
	jge	$LN36@stbi__pars

; 2866 : 						int n = z->order[k];

	mov	eax, DWORD PTR _k$7[ebp]
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax*4+18420]
	mov	DWORD PTR _n$4[ebp], edx

; 2867 : 						// scan out an mcu's worth of this component; that's just determined
; 2868 : 						// by the basic H and V specified for the component
; 2869 : 						for (y = 0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR _y$5[ebp], 0
	jmp	SHORT $LN40@stbi__pars
$LN38@stbi__pars:
	mov	eax, DWORD PTR _y$5[ebp]
	add	eax, 1
	mov	DWORD PTR _y$5[ebp], eax
$LN40@stbi__pars:
	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _y$5[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18084]
	jge	$LN39@stbi__pars

; 2870 : 							for (x = 0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR _x$6[ebp], 0
	jmp	SHORT $LN43@stbi__pars
$LN41@stbi__pars:
	mov	eax, DWORD PTR _x$6[ebp]
	add	eax, 1
	mov	DWORD PTR _x$6[ebp], eax
$LN43@stbi__pars:
	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _x$6[ebp]
	cmp	edx, DWORD PTR [ecx+eax+18080]
	jge	$LN42@stbi__pars

; 2871 : 								int x2 = (i * z->img_comp[n].h + x);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _i$9[ebp]
	imul	edx, DWORD PTR [ecx+eax+18080]
	add	edx, DWORD PTR _x$6[ebp]
	mov	DWORD PTR _x2$3[ebp], edx

; 2872 : 								int y2 = (j * z->img_comp[n].v + y);

	imul	eax, DWORD PTR _n$4[ebp], 72
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, DWORD PTR [ecx+eax+18084]
	add	edx, DWORD PTR _y$5[ebp]
	mov	DWORD PTR _y2$2[ebp], edx

; 2873 : 								short* data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

	imul	eax, DWORD PTR _n$4[ebp], 72
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	mov	esi, DWORD PTR _y2$2[ebp]
	imul	esi, DWORD PTR [edx+ecx+18140]
	add	esi, DWORD PTR _x2$3[ebp]
	shl	esi, 6
	mov	ecx, DWORD PTR _z$[ebx]
	mov	edx, DWORD PTR [ecx+eax+18136]
	lea	eax, DWORD PTR [edx+esi*2]
	mov	DWORD PTR _data$1[ebp], eax

; 2874 : 								if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	mov	eax, DWORD PTR _n$4[ebp]
	push	eax
	imul	ecx, DWORD PTR _n$4[ebp], 72
	mov	edx, DWORD PTR _z$[ebx]
	imul	eax, DWORD PTR [edx+ecx+18092], 1680
	mov	ecx, DWORD PTR _z$[ebx]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _z$[ebx]
	push	ecx
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN68@stbi__pars

; 2875 : 									return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN68@stbi__pars:

; 2876 : 							}

	jmp	$LN41@stbi__pars
$LN42@stbi__pars:

; 2877 : 						}

	jmp	$LN38@stbi__pars
$LN39@stbi__pars:

; 2878 : 					}

	jmp	$LN35@stbi__pars
$LN36@stbi__pars:

; 2879 : 					// after all interleaved components, that's an interleaved MCU,
; 2880 : 					// so now count down the restart interval
; 2881 : 					if (--z->todo <= 0) {

	mov	eax, DWORD PTR _z$[ebx]
	mov	ecx, DWORD PTR [eax+18440]
	sub	ecx, 1
	mov	DWORD PTR tv467[ebp], ecx
	mov	edx, DWORD PTR _z$[ebx]
	mov	eax, DWORD PTR tv467[ebp]
	mov	DWORD PTR [edx+18440], eax
	cmp	DWORD PTR tv467[ebp], 0
	jg	SHORT $LN69@stbi__pars

; 2882 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	eax, DWORD PTR _z$[ebx]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jge	SHORT $LN70@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN70@stbi__pars:

; 2883 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 208				; 000000d0H
	jl	SHORT $LN72@stbi__pars
	mov	eax, DWORD PTR _z$[ebx]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 215				; 000000d7H
	jle	SHORT $LN71@stbi__pars
$LN72@stbi__pars:
	mov	eax, 1
	jmp	SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 2884 : 						stbi__jpeg_reset(z);

	mov	eax, DWORD PTR _z$[ebx]
	push	eax
	call	?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z	; stbi__jpeg_reset
	add	esp, 4
$LN69@stbi__pars:

; 2885 : 					}
; 2886 : 				}

	jmp	$LN32@stbi__pars
$LN33@stbi__pars:

; 2887 : 			}

	jmp	$LN29@stbi__pars
$LN30@stbi__pars:

; 2888 : 			return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 2889 : 		}
; 2890 : 	}
; 2891 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN77@stbi__pars
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	3
$LN77@stbi__pars:
	DD	2
	DD	$LN76@stbi__pars
$LN76@stbi__pars:
	DD	-160					; ffffff60H
	DD	128					; 00000080H
	DD	$LN74@stbi__pars
	DD	-416					; fffffe60H
	DD	128					; 00000080H
	DD	$LN75@stbi__pars
$LN75@stbi__pars:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN74@stbi__pars:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?stbi__parse_entropy_coded_data@@YAHPAUstbi__jpeg@@@Z ENDP ; stbi__parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
tv88 = -196						; size = 4
_j$ = 8							; size = 4
?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z PROC		; stbi__jpeg_reset, COMDAT

; 2753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2754 : 	j->code_bits = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18368], 0

; 2755 : 	j->code_buffer = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], 0

; 2756 : 	j->nomore = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18376], 0

; 2757 : 	j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

	mov	eax, 72					; 00000048H
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+ecx+18100], 0
	mov	eax, 72					; 00000048H
	shl	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+18100], 0
	mov	edx, 72					; 00000048H
	shl	edx, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+edx+18100], 0
	mov	ecx, 72					; 00000048H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+edx+18100], 0

; 2758 : 	j->marker = STBI__MARKER_none;

	mov	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH

; 2759 : 	j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18436], 0
	je	SHORT $LN3@stbi__jpeg
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18436]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
	mov	DWORD PTR tv88[ebp], 2147483647		; 7fffffffH
$LN4@stbi__jpeg:
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR [eax+18440], ecx

; 2760 : 	j->eob_run = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18400], 0

; 2761 : 	// no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2762 : 	// since we don't even allow 1<<30 pixels
; 2763 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_reset@@YAXPAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_x$ = -5						; size = 1
_j$ = 8							; size = 4
?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z PROC		; stbi__get_marker, COMDAT

; 2736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2737 : 	stbi_uc x;
; 2738 : 	if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+18372]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN4@stbi__get_
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [eax+18372]
	mov	BYTE PTR _x$[ebp], cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax+18372], 255		; 000000ffH
	mov	al, BYTE PTR _x$[ebp]
	jmp	SHORT $LN1@stbi__get_
$LN4@stbi__get_:

; 2739 : 	x = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _x$[ebp], al

; 2740 : 	if (x != 0xff) return STBI__MARKER_none;

	movzx	eax, BYTE PTR _x$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN2@stbi__get_
	or	al, 255					; 000000ffH
	jmp	SHORT $LN1@stbi__get_
$LN2@stbi__get_:

; 2741 : 	while (x == 0xff)

	movzx	eax, BYTE PTR _x$[ebp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN3@stbi__get_

; 2742 : 		x = stbi__get8(j->s); // consume repeated 0xff fill bytes

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _x$[ebp], al
	jmp	SHORT $LN2@stbi__get_
$LN3@stbi__get_:

; 2743 : 	return x;

	mov	al, BYTE PTR _x$[ebp]
$LN1@stbi__get_:

; 2744 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get_marker@@YAEPAUstbi__jpeg@@@Z ENDP		; stbi__get_marker
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__idct_simd@@YAXPAEHQAF@Z
_TEXT	SEGMENT
$T1 = -15520						; size = 16
$T2 = -15488						; size = 16
$T3 = -15456						; size = 16
$T4 = -15424						; size = 16
$T5 = -15392						; size = 16
$T6 = -15360						; size = 16
$T7 = -15328						; size = 16
$T8 = -15296						; size = 16
$T9 = -15264						; size = 16
$T10 = -15232						; size = 16
$T11 = -15200						; size = 16
$T12 = -15168						; size = 16
$T13 = -15136						; size = 16
$T14 = -15104						; size = 16
$T15 = -15072						; size = 16
$T16 = -15040						; size = 16
$T17 = -15008						; size = 16
$T18 = -14976						; size = 16
$T19 = -14944						; size = 16
$T20 = -14912						; size = 16
$T21 = -14880						; size = 16
$T22 = -14848						; size = 16
$T23 = -14816						; size = 16
$T24 = -14784						; size = 16
$T25 = -14752						; size = 16
$T26 = -14720						; size = 16
$T27 = -14688						; size = 16
$T28 = -14656						; size = 16
$T29 = -14624						; size = 16
$T30 = -14592						; size = 16
$T31 = -14560						; size = 16
$T32 = -14528						; size = 16
$T33 = -14496						; size = 16
$T34 = -14464						; size = 16
$T35 = -14432						; size = 16
$T36 = -14400						; size = 16
$T37 = -14368						; size = 16
$T38 = -14336						; size = 16
$T39 = -14304						; size = 16
$T40 = -14272						; size = 16
$T41 = -14240						; size = 16
$T42 = -14208						; size = 16
$T43 = -14176						; size = 16
$T44 = -14144						; size = 16
$T45 = -14112						; size = 16
$T46 = -14080						; size = 16
$T47 = -14048						; size = 16
$T48 = -14016						; size = 16
$T49 = -13984						; size = 16
$T50 = -13952						; size = 16
$T51 = -13920						; size = 16
$T52 = -13888						; size = 16
$T53 = -13856						; size = 16
$T54 = -13824						; size = 16
$T55 = -13792						; size = 16
$T56 = -13760						; size = 16
$T57 = -13728						; size = 16
$T58 = -13696						; size = 16
$T59 = -13664						; size = 16
$T60 = -13632						; size = 16
$T61 = -13600						; size = 16
$T62 = -13568						; size = 16
$T63 = -13536						; size = 16
$T64 = -13504						; size = 16
$T65 = -13472						; size = 16
$T66 = -13440						; size = 16
$T67 = -13408						; size = 16
$T68 = -13376						; size = 16
$T69 = -13344						; size = 16
$T70 = -13312						; size = 16
$T71 = -13280						; size = 16
$T72 = -13248						; size = 16
$T73 = -13216						; size = 16
$T74 = -13184						; size = 16
$T75 = -13152						; size = 16
$T76 = -13120						; size = 16
$T77 = -13088						; size = 16
$T78 = -13056						; size = 16
$T79 = -13024						; size = 16
$T80 = -12992						; size = 16
$T81 = -12960						; size = 16
$T82 = -12928						; size = 16
$T83 = -12896						; size = 16
$T84 = -12864						; size = 16
$T85 = -12832						; size = 16
$T86 = -12800						; size = 16
$T87 = -12768						; size = 16
$T88 = -12736						; size = 16
$T89 = -12704						; size = 16
$T90 = -12672						; size = 16
$T91 = -12640						; size = 16
$T92 = -12608						; size = 16
$T93 = -12576						; size = 16
$T94 = -12544						; size = 16
$T95 = -12512						; size = 16
$T96 = -12480						; size = 16
$T97 = -12448						; size = 16
$T98 = -12416						; size = 16
$T99 = -12384						; size = 16
$T100 = -12352						; size = 16
$T101 = -12320						; size = 16
$T102 = -12288						; size = 16
$T103 = -12256						; size = 16
$T104 = -12224						; size = 16
$T105 = -12192						; size = 16
$T106 = -12160						; size = 16
$T107 = -12128						; size = 16
$T108 = -12096						; size = 16
$T109 = -12064						; size = 16
$T110 = -12032						; size = 16
$T111 = -12000						; size = 16
$T112 = -11968						; size = 16
$T113 = -11936						; size = 16
$T114 = -11904						; size = 16
$T115 = -11872						; size = 16
$T116 = -11840						; size = 16
$T117 = -11808						; size = 16
$T118 = -11776						; size = 16
$T119 = -11744						; size = 16
$T120 = -11712						; size = 16
$T121 = -11680						; size = 16
$T122 = -11648						; size = 16
$T123 = -11616						; size = 16
$T124 = -11584						; size = 16
$T125 = -11552						; size = 16
$T126 = -11520						; size = 16
$T127 = -11488						; size = 16
$T128 = -11456						; size = 16
$T129 = -11424						; size = 16
$T130 = -11392						; size = 16
$T131 = -11360						; size = 16
$T132 = -11328						; size = 16
$T133 = -11296						; size = 16
$T134 = -11264						; size = 16
$T135 = -11232						; size = 16
$T136 = -11200						; size = 16
$T137 = -11168						; size = 16
$T138 = -11136						; size = 16
$T139 = -11104						; size = 16
$T140 = -11072						; size = 16
$T141 = -11040						; size = 16
$T142 = -11008						; size = 16
$T143 = -10976						; size = 16
$T144 = -10944						; size = 16
$T145 = -10912						; size = 16
$T146 = -10880						; size = 16
$T147 = -10848						; size = 16
$T148 = -10816						; size = 16
$T149 = -10784						; size = 16
$T150 = -10752						; size = 16
$T151 = -10720						; size = 16
$T152 = -10688						; size = 16
$T153 = -10656						; size = 16
$T154 = -10624						; size = 16
$T155 = -10592						; size = 16
$T156 = -10560						; size = 16
$T157 = -10528						; size = 16
$T158 = -10496						; size = 16
$T159 = -10464						; size = 16
$T160 = -10432						; size = 16
$T161 = -10400						; size = 16
$T162 = -10368						; size = 16
$T163 = -10336						; size = 16
$T164 = -10304						; size = 16
$T165 = -10272						; size = 16
$T166 = -10240						; size = 16
$T167 = -10208						; size = 16
$T168 = -10176						; size = 16
$T169 = -10144						; size = 16
$T170 = -10112						; size = 16
$T171 = -10080						; size = 16
$T172 = -10048						; size = 16
$T173 = -10016						; size = 16
$T174 = -9984						; size = 16
$T175 = -9952						; size = 16
$T176 = -9920						; size = 16
$T177 = -9888						; size = 16
$T178 = -9856						; size = 16
$T179 = -9824						; size = 16
$T180 = -9792						; size = 16
$T181 = -9760						; size = 16
$T182 = -9728						; size = 16
$T183 = -9696						; size = 16
$T184 = -9664						; size = 16
$T185 = -9632						; size = 16
$T186 = -9600						; size = 16
$T187 = -9568						; size = 16
$T188 = -9536						; size = 16
$T189 = -9504						; size = 16
$T190 = -9472						; size = 16
$T191 = -9440						; size = 16
$T192 = -9408						; size = 16
$T193 = -9376						; size = 16
$T194 = -9344						; size = 16
$T195 = -9312						; size = 16
$T196 = -9280						; size = 16
$T197 = -9248						; size = 16
$T198 = -9216						; size = 16
$T199 = -9184						; size = 16
$T200 = -9152						; size = 16
$T201 = -9120						; size = 16
$T202 = -9088						; size = 16
$T203 = -9056						; size = 16
$T204 = -9024						; size = 16
$T205 = -8992						; size = 16
$T206 = -8960						; size = 16
$T207 = -8928						; size = 16
$T208 = -8896						; size = 16
$T209 = -8864						; size = 16
$T210 = -8832						; size = 16
$T211 = -8800						; size = 16
$T212 = -8768						; size = 16
$T213 = -8736						; size = 16
$T214 = -8704						; size = 16
$T215 = -8672						; size = 16
$T216 = -8640						; size = 16
$T217 = -8608						; size = 16
$T218 = -8576						; size = 16
$T219 = -8544						; size = 16
$T220 = -8512						; size = 16
$T221 = -8480						; size = 16
$T222 = -8448						; size = 16
$T223 = -8416						; size = 16
$T224 = -8384						; size = 16
$T225 = -8352						; size = 16
$T226 = -8320						; size = 16
$T227 = -8288						; size = 16
$T228 = -8256						; size = 16
$T229 = -8224						; size = 16
$T230 = -8192						; size = 16
$T231 = -8160						; size = 16
$T232 = -8128						; size = 16
$T233 = -8096						; size = 16
$T234 = -8064						; size = 16
$T235 = -8032						; size = 16
$T236 = -8000						; size = 16
$T237 = -7968						; size = 16
$T238 = -7936						; size = 16
$T239 = -7904						; size = 16
$T240 = -7872						; size = 16
$T241 = -7840						; size = 16
$T242 = -7808						; size = 16
$T243 = -7776						; size = 16
$T244 = -7744						; size = 16
$T245 = -7712						; size = 16
$T246 = -7680						; size = 16
$T247 = -7648						; size = 16
$T248 = -7616						; size = 16
$T249 = -7584						; size = 16
$T250 = -7552						; size = 16
$T251 = -7520						; size = 16
$T252 = -7488						; size = 16
$T253 = -7456						; size = 16
$T254 = -7424						; size = 16
$T255 = -7392						; size = 16
$T256 = -7360						; size = 16
$T257 = -7328						; size = 16
$T258 = -7296						; size = 16
$T259 = -7264						; size = 16
$T260 = -7232						; size = 16
$T261 = -7200						; size = 16
$T262 = -7168						; size = 16
$T263 = -7136						; size = 16
$T264 = -7104						; size = 16
$T265 = -7072						; size = 16
$T266 = -7040						; size = 16
$T267 = -7008						; size = 16
$T268 = -6976						; size = 16
$T269 = -6944						; size = 16
$T270 = -6912						; size = 16
_p3$271 = -5344						; size = 16
_p2$272 = -5312						; size = 16
_p1$273 = -5280						; size = 16
_p0$274 = -5248						; size = 16
_dif_h$275 = -5216					; size = 16
_dif_l$276 = -5184					; size = 16
_sum_h$277 = -5152					; size = 16
_sum_l$278 = -5120					; size = 16
_abiased_h$279 = -5088					; size = 16
_abiased_l$280 = -5056					; size = 16
_dif_h$281 = -5024					; size = 16
_dif_l$282 = -4992					; size = 16
_sum_h$283 = -4960					; size = 16
_sum_l$284 = -4928					; size = 16
_abiased_h$285 = -4896					; size = 16
_abiased_l$286 = -4864					; size = 16
_dif_h$287 = -4832					; size = 16
_dif_l$288 = -4800					; size = 16
_sum_h$289 = -4768					; size = 16
_sum_l$290 = -4736					; size = 16
_abiased_h$291 = -4704					; size = 16
_abiased_l$292 = -4672					; size = 16
_dif_h$293 = -4640					; size = 16
_dif_l$294 = -4608					; size = 16
_sum_h$295 = -4576					; size = 16
_sum_l$296 = -4544					; size = 16
_abiased_h$297 = -4512					; size = 16
_abiased_l$298 = -4480					; size = 16
_x7_h$299 = -4448					; size = 16
_x7_l$300 = -4416					; size = 16
_x6_h$301 = -4384					; size = 16
_x6_l$302 = -4352					; size = 16
_x5_h$303 = -4320					; size = 16
_x5_l$304 = -4288					; size = 16
_x4_h$305 = -4256					; size = 16
_x4_l$306 = -4224					; size = 16
_y5o_h$307 = -4192					; size = 16
_y5o_l$308 = -4160					; size = 16
_y4o_h$309 = -4128					; size = 16
_y4o_l$310 = -4096					; size = 16
_rot1_0hi$311 = -4064					; size = 16
_rot1_0lo$312 = -4032					; size = 16
_sum35$313 = -4000					; size = 16
_sum17$314 = -3968					; size = 16
_y3o_h$315 = -3936					; size = 16
_y3o_l$316 = -3904					; size = 16
_y1o_h$317 = -3872					; size = 16
_y1o_l$318 = -3840					; size = 16
_rot3_0hi$319 = -3808					; size = 16
_rot3_0lo$320 = -3776					; size = 16
_y2o_h$321 = -3744					; size = 16
_y2o_l$322 = -3712					; size = 16
_y0o_h$323 = -3680					; size = 16
_y0o_l$324 = -3648					; size = 16
_rot2_0hi$325 = -3616					; size = 16
_rot2_0lo$326 = -3584					; size = 16
_x2_h$327 = -3552					; size = 16
_x2_l$328 = -3520					; size = 16
_x1_h$329 = -3488					; size = 16
_x1_l$330 = -3456					; size = 16
_x3_h$331 = -3424					; size = 16
_x3_l$332 = -3392					; size = 16
_x0_h$333 = -3360					; size = 16
_x0_l$334 = -3328					; size = 16
_t1e_h$335 = -3296					; size = 16
_t1e_l$336 = -3264					; size = 16
_t0e_h$337 = -3232					; size = 16
_t0e_l$338 = -3200					; size = 16
_dif04$339 = -3168					; size = 16
_sum04$340 = -3136					; size = 16
_t3e_h$341 = -3104					; size = 16
_t3e_l$342 = -3072					; size = 16
_t2e_h$343 = -3040					; size = 16
_t2e_l$344 = -3008					; size = 16
_rot0_0hi$345 = -2976					; size = 16
_rot0_0lo$346 = -2944					; size = 16
_dif_h$347 = -2912					; size = 16
_dif_l$348 = -2880					; size = 16
_sum_h$349 = -2848					; size = 16
_sum_l$350 = -2816					; size = 16
_abiased_h$351 = -2784					; size = 16
_abiased_l$352 = -2752					; size = 16
_dif_h$353 = -2720					; size = 16
_dif_l$354 = -2688					; size = 16
_sum_h$355 = -2656					; size = 16
_sum_l$356 = -2624					; size = 16
_abiased_h$357 = -2592					; size = 16
_abiased_l$358 = -2560					; size = 16
_dif_h$359 = -2528					; size = 16
_dif_l$360 = -2496					; size = 16
_sum_h$361 = -2464					; size = 16
_sum_l$362 = -2432					; size = 16
_abiased_h$363 = -2400					; size = 16
_abiased_l$364 = -2368					; size = 16
_dif_h$365 = -2336					; size = 16
_dif_l$366 = -2304					; size = 16
_sum_h$367 = -2272					; size = 16
_sum_l$368 = -2240					; size = 16
_abiased_h$369 = -2208					; size = 16
_abiased_l$370 = -2176					; size = 16
_x7_h$371 = -2144					; size = 16
_x7_l$372 = -2112					; size = 16
_x6_h$373 = -2080					; size = 16
_x6_l$374 = -2048					; size = 16
_x5_h$375 = -2016					; size = 16
_x5_l$376 = -1984					; size = 16
_x4_h$377 = -1952					; size = 16
_x4_l$378 = -1920					; size = 16
_y5o_h$379 = -1888					; size = 16
_y5o_l$380 = -1856					; size = 16
_y4o_h$381 = -1824					; size = 16
_y4o_l$382 = -1792					; size = 16
_rot1_0hi$383 = -1760					; size = 16
_rot1_0lo$384 = -1728					; size = 16
_sum35$385 = -1696					; size = 16
_sum17$386 = -1664					; size = 16
_y3o_h$387 = -1632					; size = 16
_y3o_l$388 = -1600					; size = 16
_y1o_h$389 = -1568					; size = 16
_y1o_l$390 = -1536					; size = 16
_rot3_0hi$391 = -1504					; size = 16
_rot3_0lo$392 = -1472					; size = 16
_y2o_h$393 = -1440					; size = 16
_y2o_l$394 = -1408					; size = 16
_y0o_h$395 = -1376					; size = 16
_y0o_l$396 = -1344					; size = 16
_rot2_0hi$397 = -1312					; size = 16
_rot2_0lo$398 = -1280					; size = 16
_x2_h$399 = -1248					; size = 16
_x2_l$400 = -1216					; size = 16
_x1_h$401 = -1184					; size = 16
_x1_l$402 = -1152					; size = 16
_x3_h$403 = -1120					; size = 16
_x3_l$404 = -1088					; size = 16
_x0_h$405 = -1056					; size = 16
_x0_l$406 = -1024					; size = 16
_t1e_h$407 = -992					; size = 16
_t1e_l$408 = -960					; size = 16
_t0e_h$409 = -928					; size = 16
_t0e_l$410 = -896					; size = 16
_dif04$411 = -864					; size = 16
_sum04$412 = -832					; size = 16
_t3e_h$413 = -800					; size = 16
_t3e_l$414 = -768					; size = 16
_t2e_h$415 = -736					; size = 16
_t2e_l$416 = -704					; size = 16
_rot0_0hi$417 = -672					; size = 16
_rot0_0lo$418 = -640					; size = 16
_bias_1$ = -608						; size = 16
_bias_0$ = -576						; size = 16
_rot3_1$ = -544						; size = 16
_rot3_0$ = -512						; size = 16
_rot2_1$ = -480						; size = 16
_rot2_0$ = -448						; size = 16
_rot1_1$ = -416						; size = 16
_rot1_0$ = -384						; size = 16
_rot0_1$ = -352						; size = 16
_rot0_0$ = -320						; size = 16
_tmp$ = -288						; size = 16
_row7$ = -256						; size = 16
_row6$ = -224						; size = 16
_row5$ = -192						; size = 16
_row4$ = -160						; size = 16
_row3$ = -128						; size = 16
_row2$ = -96						; size = 16
_row1$ = -64						; size = 16
_row0$ = -32						; size = 16
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
?stbi__idct_simd@@YAXPAEHQAF@Z PROC			; stbi__idct_simd, COMDAT

; 2347 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	mov	eax, 15528				; 00003ca8H
	call	__chkstk
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-15528]
	mov	ecx, 3882				; 00000f2aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2348 : 	// This is constructed to match our regular (generic) integer IDCT exactly.
; 2349 : 	__m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2350 : 	__m128i tmp;
; 2351 : 
; 2352 : 	// dot product constant: even elems=x, odd elems=y
; 2353 : #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2354 : 
; 2355 : // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2356 : // out(1) = c1[even]*x + c1[odd]*y
; 2357 : #define dct_rot(out0,out1, x,y,c0,c1) \
; 2358 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2359 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2360 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2361 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2362 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2363 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2364 : 
; 2365 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2366 : #define dct_widen(out, in) \
; 2367 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2368 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2369 : 
; 2370 :    // wide add
; 2371 : #define dct_wadd(out, a, b) \
; 2372 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2373 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2374 : 
; 2375 :    // wide sub
; 2376 : #define dct_wsub(out, a, b) \
; 2377 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2378 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2379 : 
; 2380 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2381 : #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2382 :       { \
; 2383 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2384 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2385 :          dct_wadd(sum, abiased, b); \
; 2386 :          dct_wsub(dif, abiased, b); \
; 2387 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2388 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2389 :       }
; 2390 : 
; 2391 :    // 8-bit interleave step (for transposes)
; 2392 : #define dct_interleave8(a, b) \
; 2393 :       tmp = a; \
; 2394 :       a = _mm_unpacklo_epi8(a, b); \
; 2395 :       b = _mm_unpackhi_epi8(tmp, b)
; 2396 : 
; 2397 :    // 16-bit interleave step (for transposes)
; 2398 : #define dct_interleave16(a, b) \
; 2399 :       tmp = a; \
; 2400 :       a = _mm_unpacklo_epi16(a, b); \
; 2401 :       b = _mm_unpackhi_epi16(tmp, b)
; 2402 : 
; 2403 : #define dct_pass(bias,shift) \
; 2404 :       { \
; 2405 :          /* even part */ \
; 2406 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2407 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2408 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2409 :          dct_widen(t0e, sum04); \
; 2410 :          dct_widen(t1e, dif04); \
; 2411 :          dct_wadd(x0, t0e, t3e); \
; 2412 :          dct_wsub(x3, t0e, t3e); \
; 2413 :          dct_wadd(x1, t1e, t2e); \
; 2414 :          dct_wsub(x2, t1e, t2e); \
; 2415 :          /* odd part */ \
; 2416 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2417 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2418 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2419 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2420 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2421 :          dct_wadd(x4, y0o, y4o); \
; 2422 :          dct_wadd(x5, y1o, y5o); \
; 2423 :          dct_wadd(x6, y2o, y5o); \
; 2424 :          dct_wadd(x7, y3o, y4o); \
; 2425 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2426 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2427 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2428 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2429 :       }
; 2430 : 
; 2431 : 	__m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

	movaps	xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
	movaps	XMMWORD PTR $T270[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T270[ebp]
	movaps	XMMWORD PTR _rot0_0$[ebp], xmm0

; 2432 : 	__m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));

	movaps	xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
	movaps	XMMWORD PTR $T269[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T269[ebp]
	movaps	XMMWORD PTR _rot0_1$[ebp], xmm0

; 2433 : 	__m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

	movaps	xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
	movaps	XMMWORD PTR $T268[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T268[ebp]
	movaps	XMMWORD PTR _rot1_0$[ebp], xmm0

; 2434 : 	__m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

	movaps	xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
	movaps	XMMWORD PTR $T267[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T267[ebp]
	movaps	XMMWORD PTR _rot1_1$[ebp], xmm0

; 2435 : 	__m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));

	movaps	xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
	movaps	XMMWORD PTR $T266[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T266[ebp]
	movaps	XMMWORD PTR _rot2_0$[ebp], xmm0

; 2436 : 	__m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));

	movaps	xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
	movaps	XMMWORD PTR $T265[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T265[ebp]
	movaps	XMMWORD PTR _rot2_1$[ebp], xmm0

; 2437 : 	__m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));

	movaps	xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
	movaps	XMMWORD PTR $T264[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T264[ebp]
	movaps	XMMWORD PTR _rot3_0$[ebp], xmm0

; 2438 : 	__m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));

	movaps	xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
	movaps	XMMWORD PTR $T263[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T263[ebp]
	movaps	XMMWORD PTR _rot3_1$[ebp], xmm0

; 2439 : 
; 2440 : 	// rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2441 : 	__m128i bias_0 = _mm_set1_epi32(512);

	movaps	xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
	movaps	XMMWORD PTR $T262[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T262[ebp]
	movaps	XMMWORD PTR _bias_0$[ebp], xmm0

; 2442 : 	__m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));

	movaps	xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
	movaps	XMMWORD PTR $T261[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T261[ebp]
	movaps	XMMWORD PTR _bias_1$[ebp], xmm0

; 2443 : 
; 2444 : 	// load
; 2445 : 	row0 = _mm_load_si128((const __m128i*) (data + 0 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax]
	movaps	XMMWORD PTR $T260[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T260[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0

; 2446 : 	row1 = _mm_load_si128((const __m128i*) (data + 1 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+16]
	movaps	XMMWORD PTR $T259[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T259[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0

; 2447 : 	row2 = _mm_load_si128((const __m128i*) (data + 2 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+32]
	movaps	XMMWORD PTR $T258[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T258[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0

; 2448 : 	row3 = _mm_load_si128((const __m128i*) (data + 3 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+48]
	movaps	XMMWORD PTR $T257[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T257[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0

; 2449 : 	row4 = _mm_load_si128((const __m128i*) (data + 4 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+64]
	movaps	XMMWORD PTR $T256[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T256[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0

; 2450 : 	row5 = _mm_load_si128((const __m128i*) (data + 5 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+80]
	movaps	XMMWORD PTR $T255[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T255[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0

; 2451 : 	row6 = _mm_load_si128((const __m128i*) (data + 6 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+96]
	movaps	XMMWORD PTR $T254[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T254[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0

; 2452 : 	row7 = _mm_load_si128((const __m128i*) (data + 7 * 8));

	mov	eax, DWORD PTR _data$[ebx]
	movups	xmm0, XMMWORD PTR [eax+112]
	movaps	XMMWORD PTR $T253[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T253[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0

; 2453 : 
; 2454 : 	// column pass
; 2455 : 	dct_pass(bias_0, 10);

	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T252[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T252[ebp]
	movaps	XMMWORD PTR _rot0_0lo$418[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T251[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T251[ebp]
	movaps	XMMWORD PTR _rot0_0hi$417[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0lo$418[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movaps	XMMWORD PTR $T250[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T250[ebp]
	movaps	XMMWORD PTR _t2e_l$416[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0hi$417[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movaps	XMMWORD PTR $T249[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T249[ebp]
	movaps	XMMWORD PTR _t2e_h$415[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0lo$418[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movaps	XMMWORD PTR $T248[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T248[ebp]
	movaps	XMMWORD PTR _t3e_l$414[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0hi$417[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movaps	XMMWORD PTR $T247[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T247[ebp]
	movaps	XMMWORD PTR _t3e_h$413[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	paddw	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T246[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T246[ebp]
	movaps	XMMWORD PTR _sum04$412[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	psubw	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T245[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T245[ebp]
	movaps	XMMWORD PTR _dif04$411[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T242[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T242[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum04$412[ebp]
	movaps	XMMWORD PTR $T243[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T243[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T244[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T244[ebp]
	movaps	XMMWORD PTR _t0e_l$410[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T239[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T239[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum04$412[ebp]
	movaps	XMMWORD PTR $T240[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T240[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T241[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T241[ebp]
	movaps	XMMWORD PTR _t0e_h$409[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T236[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T236[ebp]
	punpcklwd xmm0, XMMWORD PTR _dif04$411[ebp]
	movaps	XMMWORD PTR $T237[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T237[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T238[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T238[ebp]
	movaps	XMMWORD PTR _t1e_l$408[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T233[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T233[ebp]
	punpckhwd xmm0, XMMWORD PTR _dif04$411[ebp]
	movaps	XMMWORD PTR $T234[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T234[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T235[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T235[ebp]
	movaps	XMMWORD PTR _t1e_h$407[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_l$410[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_l$414[ebp]
	movaps	XMMWORD PTR $T232[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T232[ebp]
	movaps	XMMWORD PTR _x0_l$406[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_h$409[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_h$413[ebp]
	movaps	XMMWORD PTR $T231[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T231[ebp]
	movaps	XMMWORD PTR _x0_h$405[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_l$410[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_l$414[ebp]
	movaps	XMMWORD PTR $T230[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T230[ebp]
	movaps	XMMWORD PTR _x3_l$404[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_h$409[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_h$413[ebp]
	movaps	XMMWORD PTR $T229[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T229[ebp]
	movaps	XMMWORD PTR _x3_h$403[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_l$408[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_l$416[ebp]
	movaps	XMMWORD PTR $T228[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T228[ebp]
	movaps	XMMWORD PTR _x1_l$402[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_h$407[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_h$415[ebp]
	movaps	XMMWORD PTR $T227[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T227[ebp]
	movaps	XMMWORD PTR _x1_h$401[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_l$408[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_l$416[ebp]
	movaps	XMMWORD PTR $T226[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T226[ebp]
	movaps	XMMWORD PTR _x2_l$400[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_h$407[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_h$415[ebp]
	movaps	XMMWORD PTR $T225[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T225[ebp]
	movaps	XMMWORD PTR _x2_h$399[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row7$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T224[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T224[ebp]
	movaps	XMMWORD PTR _rot2_0lo$398[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row7$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T223[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T223[ebp]
	movaps	XMMWORD PTR _rot2_0hi$397[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0lo$398[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movaps	XMMWORD PTR $T222[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T222[ebp]
	movaps	XMMWORD PTR _y0o_l$396[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0hi$397[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movaps	XMMWORD PTR $T221[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T221[ebp]
	movaps	XMMWORD PTR _y0o_h$395[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0lo$398[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movaps	XMMWORD PTR $T220[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T220[ebp]
	movaps	XMMWORD PTR _y2o_l$394[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0hi$397[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movaps	XMMWORD PTR $T219[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T219[ebp]
	movaps	XMMWORD PTR _y2o_h$393[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T218[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T218[ebp]
	movaps	XMMWORD PTR _rot3_0lo$392[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T217[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T217[ebp]
	movaps	XMMWORD PTR _rot3_0hi$391[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0lo$392[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movaps	XMMWORD PTR $T216[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T216[ebp]
	movaps	XMMWORD PTR _y1o_l$390[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0hi$391[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movaps	XMMWORD PTR $T215[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T215[ebp]
	movaps	XMMWORD PTR _y1o_h$389[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0lo$392[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movaps	XMMWORD PTR $T214[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T214[ebp]
	movaps	XMMWORD PTR _y3o_l$388[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0hi$391[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movaps	XMMWORD PTR $T213[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T213[ebp]
	movaps	XMMWORD PTR _y3o_h$387[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	paddw	xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T212[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T212[ebp]
	movaps	XMMWORD PTR _sum17$386[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row3$[ebp]
	paddw	xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T211[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T211[ebp]
	movaps	XMMWORD PTR _sum35$385[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum17$386[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum35$385[ebp]
	movaps	XMMWORD PTR $T210[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T210[ebp]
	movaps	XMMWORD PTR _rot1_0lo$384[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum17$386[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum35$385[ebp]
	movaps	XMMWORD PTR $T209[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T209[ebp]
	movaps	XMMWORD PTR _rot1_0hi$383[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0lo$384[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movaps	XMMWORD PTR $T208[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T208[ebp]
	movaps	XMMWORD PTR _y4o_l$382[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0hi$383[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movaps	XMMWORD PTR $T207[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T207[ebp]
	movaps	XMMWORD PTR _y4o_h$381[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0lo$384[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movaps	XMMWORD PTR $T206[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T206[ebp]
	movaps	XMMWORD PTR _y5o_l$380[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0hi$383[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movaps	XMMWORD PTR $T205[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T205[ebp]
	movaps	XMMWORD PTR _y5o_h$379[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y0o_l$396[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$382[ebp]
	movaps	XMMWORD PTR $T204[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T204[ebp]
	movaps	XMMWORD PTR _x4_l$378[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y0o_h$395[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$381[ebp]
	movaps	XMMWORD PTR $T203[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T203[ebp]
	movaps	XMMWORD PTR _x4_h$377[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y1o_l$390[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$380[ebp]
	movaps	XMMWORD PTR $T202[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T202[ebp]
	movaps	XMMWORD PTR _x5_l$376[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y1o_h$389[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$379[ebp]
	movaps	XMMWORD PTR $T201[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T201[ebp]
	movaps	XMMWORD PTR _x5_h$375[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y2o_l$394[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$380[ebp]
	movaps	XMMWORD PTR $T200[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T200[ebp]
	movaps	XMMWORD PTR _x6_l$374[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y2o_h$393[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$379[ebp]
	movaps	XMMWORD PTR $T199[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T199[ebp]
	movaps	XMMWORD PTR _x6_h$373[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y3o_l$388[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$382[ebp]
	movaps	XMMWORD PTR $T198[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T198[ebp]
	movaps	XMMWORD PTR _x7_l$372[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y3o_h$387[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$381[ebp]
	movaps	XMMWORD PTR $T197[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T197[ebp]
	movaps	XMMWORD PTR _x7_h$371[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x0_l$406[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T196[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T196[ebp]
	movaps	XMMWORD PTR _abiased_l$370[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x0_h$405[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T195[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T195[ebp]
	movaps	XMMWORD PTR _abiased_h$369[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$370[ebp]
	paddd	xmm0, XMMWORD PTR _x7_l$372[ebp]
	movaps	XMMWORD PTR $T194[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T194[ebp]
	movaps	XMMWORD PTR _sum_l$368[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$369[ebp]
	paddd	xmm0, XMMWORD PTR _x7_h$371[ebp]
	movaps	XMMWORD PTR $T193[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T193[ebp]
	movaps	XMMWORD PTR _sum_h$367[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$370[ebp]
	psubd	xmm0, XMMWORD PTR _x7_l$372[ebp]
	movaps	XMMWORD PTR $T192[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T192[ebp]
	movaps	XMMWORD PTR _dif_l$366[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$369[ebp]
	psubd	xmm0, XMMWORD PTR _x7_h$371[ebp]
	movaps	XMMWORD PTR $T191[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T191[ebp]
	movaps	XMMWORD PTR _dif_h$365[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$367[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T189[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$368[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T188[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T188[ebp]
	packssdw xmm0, XMMWORD PTR $T189[ebp]
	movaps	XMMWORD PTR $T190[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T190[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$365[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T186[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$366[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T185[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T185[ebp]
	packssdw xmm0, XMMWORD PTR $T186[ebp]
	movaps	XMMWORD PTR $T187[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T187[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x1_l$402[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T184[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T184[ebp]
	movaps	XMMWORD PTR _abiased_l$364[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x1_h$401[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T183[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T183[ebp]
	movaps	XMMWORD PTR _abiased_h$363[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$364[ebp]
	paddd	xmm0, XMMWORD PTR _x6_l$374[ebp]
	movaps	XMMWORD PTR $T182[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T182[ebp]
	movaps	XMMWORD PTR _sum_l$362[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$363[ebp]
	paddd	xmm0, XMMWORD PTR _x6_h$373[ebp]
	movaps	XMMWORD PTR $T181[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T181[ebp]
	movaps	XMMWORD PTR _sum_h$361[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$364[ebp]
	psubd	xmm0, XMMWORD PTR _x6_l$374[ebp]
	movaps	XMMWORD PTR $T180[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T180[ebp]
	movaps	XMMWORD PTR _dif_l$360[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$363[ebp]
	psubd	xmm0, XMMWORD PTR _x6_h$373[ebp]
	movaps	XMMWORD PTR $T179[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T179[ebp]
	movaps	XMMWORD PTR _dif_h$359[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$361[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T177[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$362[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T176[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T176[ebp]
	packssdw xmm0, XMMWORD PTR $T177[ebp]
	movaps	XMMWORD PTR $T178[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T178[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$359[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T174[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$360[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T173[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T173[ebp]
	packssdw xmm0, XMMWORD PTR $T174[ebp]
	movaps	XMMWORD PTR $T175[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T175[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x2_l$400[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T172[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T172[ebp]
	movaps	XMMWORD PTR _abiased_l$358[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x2_h$399[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T171[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T171[ebp]
	movaps	XMMWORD PTR _abiased_h$357[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$358[ebp]
	paddd	xmm0, XMMWORD PTR _x5_l$376[ebp]
	movaps	XMMWORD PTR $T170[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T170[ebp]
	movaps	XMMWORD PTR _sum_l$356[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$357[ebp]
	paddd	xmm0, XMMWORD PTR _x5_h$375[ebp]
	movaps	XMMWORD PTR $T169[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T169[ebp]
	movaps	XMMWORD PTR _sum_h$355[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$358[ebp]
	psubd	xmm0, XMMWORD PTR _x5_l$376[ebp]
	movaps	XMMWORD PTR $T168[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T168[ebp]
	movaps	XMMWORD PTR _dif_l$354[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$357[ebp]
	psubd	xmm0, XMMWORD PTR _x5_h$375[ebp]
	movaps	XMMWORD PTR $T167[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T167[ebp]
	movaps	XMMWORD PTR _dif_h$353[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$355[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T165[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$356[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T164[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T164[ebp]
	packssdw xmm0, XMMWORD PTR $T165[ebp]
	movaps	XMMWORD PTR $T166[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T166[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$353[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T162[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$354[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T161[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T161[ebp]
	packssdw xmm0, XMMWORD PTR $T162[ebp]
	movaps	XMMWORD PTR $T163[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T163[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x3_l$404[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T160[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T160[ebp]
	movaps	XMMWORD PTR _abiased_l$352[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x3_h$403[ebp]
	paddd	xmm0, XMMWORD PTR _bias_0$[ebp]
	movaps	XMMWORD PTR $T159[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T159[ebp]
	movaps	XMMWORD PTR _abiased_h$351[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$352[ebp]
	paddd	xmm0, XMMWORD PTR _x4_l$378[ebp]
	movaps	XMMWORD PTR $T158[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T158[ebp]
	movaps	XMMWORD PTR _sum_l$350[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$351[ebp]
	paddd	xmm0, XMMWORD PTR _x4_h$377[ebp]
	movaps	XMMWORD PTR $T157[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T157[ebp]
	movaps	XMMWORD PTR _sum_h$349[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$352[ebp]
	psubd	xmm0, XMMWORD PTR _x4_l$378[ebp]
	movaps	XMMWORD PTR $T156[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T156[ebp]
	movaps	XMMWORD PTR _dif_l$348[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$351[ebp]
	psubd	xmm0, XMMWORD PTR _x4_h$377[ebp]
	movaps	XMMWORD PTR $T155[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T155[ebp]
	movaps	XMMWORD PTR _dif_h$347[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$349[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T153[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$350[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T152[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T152[ebp]
	packssdw xmm0, XMMWORD PTR $T153[ebp]
	movaps	XMMWORD PTR $T154[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T154[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$347[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T150[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$348[ebp]
	psrad	xmm0, 10				; 0000000aH
	movaps	XMMWORD PTR $T149[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T149[ebp]
	packssdw xmm0, XMMWORD PTR $T150[ebp]
	movaps	XMMWORD PTR $T151[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T151[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0

; 2456 : 
; 2457 : 	{
; 2458 : 		// 16bit 8x8 transpose pass 1
; 2459 : 		dct_interleave16(row0, row4);

	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T148[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T148[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T147[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T147[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0

; 2460 : 		dct_interleave16(row1, row5);

	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T146[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T146[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T145[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T145[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0

; 2461 : 		dct_interleave16(row2, row6);

	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T144[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T144[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T143[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T143[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0

; 2462 : 		dct_interleave16(row3, row7);

	movaps	xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row3$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T142[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T142[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T141[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T141[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0

; 2463 : 
; 2464 : 		// transpose pass 2
; 2465 : 		dct_interleave16(row0, row2);

	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row2$[ebp]
	movaps	XMMWORD PTR $T140[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T140[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row2$[ebp]
	movaps	XMMWORD PTR $T139[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T139[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0

; 2466 : 		dct_interleave16(row1, row3);

	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T138[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T138[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T137[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T137[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0

; 2467 : 		dct_interleave16(row4, row6);

	movaps	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row4$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T136[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T136[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T135[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T135[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0

; 2468 : 		dct_interleave16(row5, row7);

	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T134[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T134[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T133[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T133[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0

; 2469 : 
; 2470 : 		// transpose pass 3
; 2471 : 		dct_interleave16(row0, row1);

	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T132[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T132[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T131[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T131[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0

; 2472 : 		dct_interleave16(row2, row3);

	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T130[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T130[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T129[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T129[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0

; 2473 : 		dct_interleave16(row4, row5);

	movaps	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row4$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T128[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T128[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T127[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T127[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0

; 2474 : 		dct_interleave16(row6, row7);

	movaps	xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row6$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T126[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T126[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T125[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T125[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0

; 2475 : 	}
; 2476 : 
; 2477 : 	// row pass
; 2478 : 	dct_pass(bias_1, 17);

	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T124[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T124[ebp]
	movaps	XMMWORD PTR _rot0_0lo$346[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row6$[ebp]
	movaps	XMMWORD PTR $T123[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T123[ebp]
	movaps	XMMWORD PTR _rot0_0hi$345[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0lo$346[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movaps	XMMWORD PTR $T122[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T122[ebp]
	movaps	XMMWORD PTR _t2e_l$344[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0hi$345[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_0$[ebp]
	movaps	XMMWORD PTR $T121[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T121[ebp]
	movaps	XMMWORD PTR _t2e_h$343[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0lo$346[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movaps	XMMWORD PTR $T120[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T120[ebp]
	movaps	XMMWORD PTR _t3e_l$342[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot0_0hi$345[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot0_1$[ebp]
	movaps	XMMWORD PTR $T119[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T119[ebp]
	movaps	XMMWORD PTR _t3e_h$341[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	paddw	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T118[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T118[ebp]
	movaps	XMMWORD PTR _sum04$340[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	psubw	xmm0, XMMWORD PTR _row4$[ebp]
	movaps	XMMWORD PTR $T117[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T117[ebp]
	movaps	XMMWORD PTR _dif04$339[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T114[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T114[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum04$340[ebp]
	movaps	XMMWORD PTR $T115[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T115[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T116[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T116[ebp]
	movaps	XMMWORD PTR _t0e_l$338[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T111[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T111[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum04$340[ebp]
	movaps	XMMWORD PTR $T112[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T112[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T113[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T113[ebp]
	movaps	XMMWORD PTR _t0e_h$337[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T108[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T108[ebp]
	punpcklwd xmm0, XMMWORD PTR _dif04$339[ebp]
	movaps	XMMWORD PTR $T109[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T109[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T110[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T110[ebp]
	movaps	XMMWORD PTR _t1e_l$336[ebp], xmm0
	xorps	xmm0, xmm0
	movaps	XMMWORD PTR $T105[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T105[ebp]
	punpckhwd xmm0, XMMWORD PTR _dif04$339[ebp]
	movaps	XMMWORD PTR $T106[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T106[ebp]
	psrad	xmm0, 4
	movaps	XMMWORD PTR $T107[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T107[ebp]
	movaps	XMMWORD PTR _t1e_h$335[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_l$338[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_l$342[ebp]
	movaps	XMMWORD PTR $T104[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T104[ebp]
	movaps	XMMWORD PTR _x0_l$334[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_h$337[ebp]
	paddd	xmm0, XMMWORD PTR _t3e_h$341[ebp]
	movaps	XMMWORD PTR $T103[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T103[ebp]
	movaps	XMMWORD PTR _x0_h$333[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_l$338[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_l$342[ebp]
	movaps	XMMWORD PTR $T102[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T102[ebp]
	movaps	XMMWORD PTR _x3_l$332[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t0e_h$337[ebp]
	psubd	xmm0, XMMWORD PTR _t3e_h$341[ebp]
	movaps	XMMWORD PTR $T101[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T101[ebp]
	movaps	XMMWORD PTR _x3_h$331[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_l$336[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_l$344[ebp]
	movaps	XMMWORD PTR $T100[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T100[ebp]
	movaps	XMMWORD PTR _x1_l$330[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_h$335[ebp]
	paddd	xmm0, XMMWORD PTR _t2e_h$343[ebp]
	movaps	XMMWORD PTR $T99[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T99[ebp]
	movaps	XMMWORD PTR _x1_h$329[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_l$336[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_l$344[ebp]
	movaps	XMMWORD PTR $T98[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T98[ebp]
	movaps	XMMWORD PTR _x2_l$328[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _t1e_h$335[ebp]
	psubd	xmm0, XMMWORD PTR _t2e_h$343[ebp]
	movaps	XMMWORD PTR $T97[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T97[ebp]
	movaps	XMMWORD PTR _x2_h$327[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row7$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T96[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T96[ebp]
	movaps	XMMWORD PTR _rot2_0lo$326[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row7$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T95[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T95[ebp]
	movaps	XMMWORD PTR _rot2_0hi$325[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0lo$326[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movaps	XMMWORD PTR $T94[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T94[ebp]
	movaps	XMMWORD PTR _y0o_l$324[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0hi$325[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_0$[ebp]
	movaps	XMMWORD PTR $T93[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T93[ebp]
	movaps	XMMWORD PTR _y0o_h$323[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0lo$326[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movaps	XMMWORD PTR $T92[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T92[ebp]
	movaps	XMMWORD PTR _y2o_l$322[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot2_0hi$325[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot2_1$[ebp]
	movaps	XMMWORD PTR $T91[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T91[ebp]
	movaps	XMMWORD PTR _y2o_h$321[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	punpcklwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T90[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T90[ebp]
	movaps	XMMWORD PTR _rot3_0lo$320[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row5$[ebp]
	punpckhwd xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T89[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T89[ebp]
	movaps	XMMWORD PTR _rot3_0hi$319[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0lo$320[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movaps	XMMWORD PTR $T88[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T88[ebp]
	movaps	XMMWORD PTR _y1o_l$318[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0hi$319[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_0$[ebp]
	movaps	XMMWORD PTR $T87[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T87[ebp]
	movaps	XMMWORD PTR _y1o_h$317[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0lo$320[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movaps	XMMWORD PTR $T86[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T86[ebp]
	movaps	XMMWORD PTR _y3o_l$316[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot3_0hi$319[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot3_1$[ebp]
	movaps	XMMWORD PTR $T85[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T85[ebp]
	movaps	XMMWORD PTR _y3o_h$315[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row1$[ebp]
	paddw	xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T84[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T84[ebp]
	movaps	XMMWORD PTR _sum17$314[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _row3$[ebp]
	paddw	xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T83[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T83[ebp]
	movaps	XMMWORD PTR _sum35$313[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum17$314[ebp]
	punpcklwd xmm0, XMMWORD PTR _sum35$313[ebp]
	movaps	XMMWORD PTR $T82[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T82[ebp]
	movaps	XMMWORD PTR _rot1_0lo$312[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum17$314[ebp]
	punpckhwd xmm0, XMMWORD PTR _sum35$313[ebp]
	movaps	XMMWORD PTR $T81[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T81[ebp]
	movaps	XMMWORD PTR _rot1_0hi$311[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0lo$312[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movaps	XMMWORD PTR $T80[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T80[ebp]
	movaps	XMMWORD PTR _y4o_l$310[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0hi$311[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_0$[ebp]
	movaps	XMMWORD PTR $T79[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T79[ebp]
	movaps	XMMWORD PTR _y4o_h$309[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0lo$312[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movaps	XMMWORD PTR $T78[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T78[ebp]
	movaps	XMMWORD PTR _y5o_l$308[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _rot1_0hi$311[ebp]
	pmaddwd	xmm0, XMMWORD PTR _rot1_1$[ebp]
	movaps	XMMWORD PTR $T77[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T77[ebp]
	movaps	XMMWORD PTR _y5o_h$307[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y0o_l$324[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$310[ebp]
	movaps	XMMWORD PTR $T76[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T76[ebp]
	movaps	XMMWORD PTR _x4_l$306[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y0o_h$323[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$309[ebp]
	movaps	XMMWORD PTR $T75[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T75[ebp]
	movaps	XMMWORD PTR _x4_h$305[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y1o_l$318[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$308[ebp]
	movaps	XMMWORD PTR $T74[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T74[ebp]
	movaps	XMMWORD PTR _x5_l$304[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y1o_h$317[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$307[ebp]
	movaps	XMMWORD PTR $T73[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T73[ebp]
	movaps	XMMWORD PTR _x5_h$303[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y2o_l$322[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_l$308[ebp]
	movaps	XMMWORD PTR $T72[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T72[ebp]
	movaps	XMMWORD PTR _x6_l$302[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y2o_h$321[ebp]
	paddd	xmm0, XMMWORD PTR _y5o_h$307[ebp]
	movaps	XMMWORD PTR $T71[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T71[ebp]
	movaps	XMMWORD PTR _x6_h$301[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y3o_l$316[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_l$310[ebp]
	movaps	XMMWORD PTR $T70[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T70[ebp]
	movaps	XMMWORD PTR _x7_l$300[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _y3o_h$315[ebp]
	paddd	xmm0, XMMWORD PTR _y4o_h$309[ebp]
	movaps	XMMWORD PTR $T69[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T69[ebp]
	movaps	XMMWORD PTR _x7_h$299[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x0_l$334[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T68[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T68[ebp]
	movaps	XMMWORD PTR _abiased_l$298[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x0_h$333[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T67[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T67[ebp]
	movaps	XMMWORD PTR _abiased_h$297[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$298[ebp]
	paddd	xmm0, XMMWORD PTR _x7_l$300[ebp]
	movaps	XMMWORD PTR $T66[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T66[ebp]
	movaps	XMMWORD PTR _sum_l$296[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$297[ebp]
	paddd	xmm0, XMMWORD PTR _x7_h$299[ebp]
	movaps	XMMWORD PTR $T65[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T65[ebp]
	movaps	XMMWORD PTR _sum_h$295[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$298[ebp]
	psubd	xmm0, XMMWORD PTR _x7_l$300[ebp]
	movaps	XMMWORD PTR $T64[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T64[ebp]
	movaps	XMMWORD PTR _dif_l$294[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$297[ebp]
	psubd	xmm0, XMMWORD PTR _x7_h$299[ebp]
	movaps	XMMWORD PTR $T63[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T63[ebp]
	movaps	XMMWORD PTR _dif_h$293[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$295[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T61[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$296[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T60[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T60[ebp]
	packssdw xmm0, XMMWORD PTR $T61[ebp]
	movaps	XMMWORD PTR $T62[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T62[ebp]
	movaps	XMMWORD PTR _row0$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$293[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T58[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$294[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T57[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T57[ebp]
	packssdw xmm0, XMMWORD PTR $T58[ebp]
	movaps	XMMWORD PTR $T59[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T59[ebp]
	movaps	XMMWORD PTR _row7$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x1_l$330[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T56[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T56[ebp]
	movaps	XMMWORD PTR _abiased_l$292[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x1_h$329[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T55[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T55[ebp]
	movaps	XMMWORD PTR _abiased_h$291[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$292[ebp]
	paddd	xmm0, XMMWORD PTR _x6_l$302[ebp]
	movaps	XMMWORD PTR $T54[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T54[ebp]
	movaps	XMMWORD PTR _sum_l$290[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$291[ebp]
	paddd	xmm0, XMMWORD PTR _x6_h$301[ebp]
	movaps	XMMWORD PTR $T53[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T53[ebp]
	movaps	XMMWORD PTR _sum_h$289[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$292[ebp]
	psubd	xmm0, XMMWORD PTR _x6_l$302[ebp]
	movaps	XMMWORD PTR $T52[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T52[ebp]
	movaps	XMMWORD PTR _dif_l$288[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$291[ebp]
	psubd	xmm0, XMMWORD PTR _x6_h$301[ebp]
	movaps	XMMWORD PTR $T51[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T51[ebp]
	movaps	XMMWORD PTR _dif_h$287[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$289[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T49[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$290[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T48[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T48[ebp]
	packssdw xmm0, XMMWORD PTR $T49[ebp]
	movaps	XMMWORD PTR $T50[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T50[ebp]
	movaps	XMMWORD PTR _row1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$287[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T46[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$288[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T45[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T45[ebp]
	packssdw xmm0, XMMWORD PTR $T46[ebp]
	movaps	XMMWORD PTR $T47[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T47[ebp]
	movaps	XMMWORD PTR _row6$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x2_l$328[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T44[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T44[ebp]
	movaps	XMMWORD PTR _abiased_l$286[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x2_h$327[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T43[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T43[ebp]
	movaps	XMMWORD PTR _abiased_h$285[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$286[ebp]
	paddd	xmm0, XMMWORD PTR _x5_l$304[ebp]
	movaps	XMMWORD PTR $T42[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T42[ebp]
	movaps	XMMWORD PTR _sum_l$284[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$285[ebp]
	paddd	xmm0, XMMWORD PTR _x5_h$303[ebp]
	movaps	XMMWORD PTR $T41[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T41[ebp]
	movaps	XMMWORD PTR _sum_h$283[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$286[ebp]
	psubd	xmm0, XMMWORD PTR _x5_l$304[ebp]
	movaps	XMMWORD PTR $T40[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T40[ebp]
	movaps	XMMWORD PTR _dif_l$282[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$285[ebp]
	psubd	xmm0, XMMWORD PTR _x5_h$303[ebp]
	movaps	XMMWORD PTR $T39[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T39[ebp]
	movaps	XMMWORD PTR _dif_h$281[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$283[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T37[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$284[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T36[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T36[ebp]
	packssdw xmm0, XMMWORD PTR $T37[ebp]
	movaps	XMMWORD PTR $T38[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T38[ebp]
	movaps	XMMWORD PTR _row2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$281[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T34[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$282[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T33[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T33[ebp]
	packssdw xmm0, XMMWORD PTR $T34[ebp]
	movaps	XMMWORD PTR $T35[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T35[ebp]
	movaps	XMMWORD PTR _row5$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x3_l$332[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T32[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T32[ebp]
	movaps	XMMWORD PTR _abiased_l$280[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _x3_h$331[ebp]
	paddd	xmm0, XMMWORD PTR _bias_1$[ebp]
	movaps	XMMWORD PTR $T31[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T31[ebp]
	movaps	XMMWORD PTR _abiased_h$279[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$280[ebp]
	paddd	xmm0, XMMWORD PTR _x4_l$306[ebp]
	movaps	XMMWORD PTR $T30[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T30[ebp]
	movaps	XMMWORD PTR _sum_l$278[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$279[ebp]
	paddd	xmm0, XMMWORD PTR _x4_h$305[ebp]
	movaps	XMMWORD PTR $T29[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T29[ebp]
	movaps	XMMWORD PTR _sum_h$277[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_l$280[ebp]
	psubd	xmm0, XMMWORD PTR _x4_l$306[ebp]
	movaps	XMMWORD PTR $T28[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T28[ebp]
	movaps	XMMWORD PTR _dif_l$276[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _abiased_h$279[ebp]
	psubd	xmm0, XMMWORD PTR _x4_h$305[ebp]
	movaps	XMMWORD PTR $T27[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T27[ebp]
	movaps	XMMWORD PTR _dif_h$275[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_h$277[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T25[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _sum_l$278[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T24[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T24[ebp]
	packssdw xmm0, XMMWORD PTR $T25[ebp]
	movaps	XMMWORD PTR $T26[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T26[ebp]
	movaps	XMMWORD PTR _row3$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_h$275[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T22[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _dif_l$276[ebp]
	psrad	xmm0, 17				; 00000011H
	movaps	XMMWORD PTR $T21[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T21[ebp]
	packssdw xmm0, XMMWORD PTR $T22[ebp]
	movaps	XMMWORD PTR $T23[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T23[ebp]
	movaps	XMMWORD PTR _row4$[ebp], xmm0

; 2479 : 
; 2480 : 	{
; 2481 : 		// pack
; 2482 : 		__m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

	movaps	xmm0, XMMWORD PTR _row0$[ebp]
	packuswb xmm0, XMMWORD PTR _row1$[ebp]
	movaps	XMMWORD PTR $T20[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T20[ebp]
	movaps	XMMWORD PTR _p0$274[ebp], xmm0

; 2483 : 		__m128i p1 = _mm_packus_epi16(row2, row3);

	movaps	xmm0, XMMWORD PTR _row2$[ebp]
	packuswb xmm0, XMMWORD PTR _row3$[ebp]
	movaps	XMMWORD PTR $T19[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T19[ebp]
	movaps	XMMWORD PTR _p1$273[ebp], xmm0

; 2484 : 		__m128i p2 = _mm_packus_epi16(row4, row5);

	movaps	xmm0, XMMWORD PTR _row4$[ebp]
	packuswb xmm0, XMMWORD PTR _row5$[ebp]
	movaps	XMMWORD PTR $T18[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T18[ebp]
	movaps	XMMWORD PTR _p2$272[ebp], xmm0

; 2485 : 		__m128i p3 = _mm_packus_epi16(row6, row7);

	movaps	xmm0, XMMWORD PTR _row6$[ebp]
	packuswb xmm0, XMMWORD PTR _row7$[ebp]
	movaps	XMMWORD PTR $T17[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T17[ebp]
	movaps	XMMWORD PTR _p3$271[ebp], xmm0

; 2486 : 
; 2487 : 		// 8bit 8x8 transpose pass 1
; 2488 : 		dct_interleave8(p0, p2); // a0e0a1e1...

	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	punpcklbw xmm0, XMMWORD PTR _p2$272[ebp]
	movaps	XMMWORD PTR $T16[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T16[ebp]
	movaps	XMMWORD PTR _p0$274[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p2$272[ebp]
	movaps	XMMWORD PTR $T15[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T15[ebp]
	movaps	XMMWORD PTR _p2$272[ebp], xmm0

; 2489 : 		dct_interleave8(p1, p3); // c0g0c1g1...

	movaps	xmm0, XMMWORD PTR _p1$273[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p1$273[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T14[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T14[ebp]
	movaps	XMMWORD PTR _p1$273[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T13[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T13[ebp]
	movaps	XMMWORD PTR _p3$271[ebp], xmm0

; 2490 : 
; 2491 : 		// transpose pass 2
; 2492 : 		dct_interleave8(p0, p1); // a0c0e0g0...

	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	punpcklbw xmm0, XMMWORD PTR _p1$273[ebp]
	movaps	XMMWORD PTR $T12[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T12[ebp]
	movaps	XMMWORD PTR _p0$274[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p1$273[ebp]
	movaps	XMMWORD PTR $T11[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T11[ebp]
	movaps	XMMWORD PTR _p1$273[ebp], xmm0

; 2493 : 		dct_interleave8(p2, p3); // b0d0f0h0...

	movaps	xmm0, XMMWORD PTR _p2$272[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p2$272[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T10[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T10[ebp]
	movaps	XMMWORD PTR _p2$272[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T9[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T9[ebp]
	movaps	XMMWORD PTR _p3$271[ebp], xmm0

; 2494 : 
; 2495 : 		// transpose pass 3
; 2496 : 		dct_interleave8(p0, p2); // a0b0c0d0...

	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	punpcklbw xmm0, XMMWORD PTR _p2$272[ebp]
	movaps	XMMWORD PTR $T8[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T8[ebp]
	movaps	XMMWORD PTR _p0$274[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p2$272[ebp]
	movaps	XMMWORD PTR $T7[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T7[ebp]
	movaps	XMMWORD PTR _p2$272[ebp], xmm0

; 2497 : 		dct_interleave8(p1, p3); // a4b4c4d4...

	movaps	xmm0, XMMWORD PTR _p1$273[ebp]
	movaps	XMMWORD PTR _tmp$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _p1$273[ebp]
	punpcklbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T6[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T6[ebp]
	movaps	XMMWORD PTR _p1$273[ebp], xmm0
	movaps	xmm0, XMMWORD PTR _tmp$[ebp]
	punpckhbw xmm0, XMMWORD PTR _p3$271[ebp]
	movaps	XMMWORD PTR $T5[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T5[ebp]
	movaps	XMMWORD PTR _p3$271[ebp], xmm0

; 2498 : 
; 2499 : 		// store
; 2500 : 		_mm_storel_epi64((__m128i*) out, p0); out += out_stride;

	movaps	xmm0, XMMWORD PTR _p0$274[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2501 : 		_mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p0$274[ebp], 78	; 0000004eH
	movaps	XMMWORD PTR $T4[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T4[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2502 : 		_mm_storel_epi64((__m128i*) out, p2); out += out_stride;

	movaps	xmm0, XMMWORD PTR _p2$272[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2503 : 		_mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p2$272[ebp], 78	; 0000004eH
	movaps	XMMWORD PTR $T3[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T3[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2504 : 		_mm_storel_epi64((__m128i*) out, p1); out += out_stride;

	movaps	xmm0, XMMWORD PTR _p1$273[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2505 : 		_mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

	pshufd	xmm0, XMMWORD PTR _p1$273[ebp], 78	; 0000004eH
	movaps	XMMWORD PTR $T2[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T2[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2506 : 		_mm_storel_epi64((__m128i*) out, p3); out += out_stride;

	movaps	xmm0, XMMWORD PTR _p3$271[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out$[ebx]
	add	eax, DWORD PTR _out_stride$[ebx]
	mov	DWORD PTR _out$[ebx], eax

; 2507 : 		_mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p3, 0x4e));

	pshufd	xmm0, XMMWORD PTR _p3$271[ebp], 78	; 0000004eH
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	mov	eax, DWORD PTR _out$[ebx]
	movq	QWORD PTR [eax], xmm0

; 2508 : 	}
; 2509 : 
; 2510 : #undef dct_const
; 2511 : #undef dct_rot
; 2512 : #undef dct_widen
; 2513 : #undef dct_wadd
; 2514 : #undef dct_wsub
; 2515 : #undef dct_bfly32o
; 2516 : #undef dct_interleave8
; 2517 : #undef dct_interleave16
; 2518 : #undef dct_pass
; 2519 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?stbi__idct_simd@@YAXPAEHQAF@Z ENDP			; stbi__idct_simd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__idct_block@@YAXPAEHQAF@Z
_TEXT	SEGMENT
_x3$1 = -636						; size = 4
_x2$2 = -624						; size = 4
_x1$3 = -612						; size = 4
_x0$4 = -600						; size = 4
_p5$5 = -588						; size = 4
_p4$6 = -576						; size = 4
_p3$7 = -564						; size = 4
_p2$8 = -552						; size = 4
_p1$9 = -540						; size = 4
_t3$10 = -528						; size = 4
_t2$11 = -516						; size = 4
_t1$12 = -504						; size = 4
_t0$13 = -492						; size = 4
_x3$14 = -480						; size = 4
_x2$15 = -468						; size = 4
_x1$16 = -456						; size = 4
_x0$17 = -444						; size = 4
_p5$18 = -432						; size = 4
_p4$19 = -420						; size = 4
_p3$20 = -408						; size = 4
_p2$21 = -396						; size = 4
_p1$22 = -384						; size = 4
_t3$23 = -372						; size = 4
_t2$24 = -360						; size = 4
_t1$25 = -348						; size = 4
_t0$26 = -336						; size = 4
_dcterm$27 = -324					; size = 4
_d$ = -312						; size = 4
_o$ = -300						; size = 4
_v$ = -288						; size = 4
_val$ = -276						; size = 256
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
?stbi__idct_block@@YAXPAEHQAF@Z PROC			; stbi__idct_block, COMDAT

; 2283 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1024]
	mov	ecx, 256				; 00000100H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2284 : 	int i, val[64], * v = val;

	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2285 : 	stbi_uc* o;
; 2286 : 	short* d = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 2287 : 
; 2288 : 	// columns
; 2289 : 	for (i = 0; i < 8; ++i, ++d, ++v) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__idct
$LN2@stbi__idct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 2
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 4
	mov	DWORD PTR _v$[ebp], edx
$LN4@stbi__idct:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@stbi__idct

; 2290 : 		// if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2291 : 		if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
; 2292 : 			&& d[40] == 0 && d[48] == 0 && d[56] == 0) {

	mov	eax, 2
	shl	eax, 3
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN8@stbi__idct
	mov	eax, 2
	shl	eax, 4
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	shl	eax, 5
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	$LN8@stbi__idct

; 2293 : 			//    no shortcut                 0     seconds
; 2294 : 			//    (1|2|3|4|5|6|7)==0          0     seconds
; 2295 : 			//    all separate               -0.047 seconds
; 2296 : 			//    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2297 : 			int dcterm = d[0] * 4;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	shl	eax, 2
	mov	DWORD PTR _dcterm$27[ebp], eax

; 2298 : 			v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	eax, 4
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 5
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _dcterm$27[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 2299 : 		}

	jmp	$LN9@stbi__idct
$LN8@stbi__idct:

; 2300 : 		else {
; 2301 : 			STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])

	mov	eax, 2
	shl	eax, 4
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _p2$21[ebp], edx
	mov	eax, 2
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _p3$20[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	imul	ecx, eax, 2217
	mov	DWORD PTR _p1$22[ebp], ecx
	imul	eax, DWORD PTR _p3$20[ebp], -7567
	add	eax, DWORD PTR _p1$22[ebp]
	mov	DWORD PTR _t2$24[ebp], eax
	imul	eax, DWORD PTR _p2$21[ebp], 3135
	add	eax, DWORD PTR _p1$22[ebp]
	mov	DWORD PTR _t3$23[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _p2$21[ebp], eax
	mov	eax, 2
	shl	eax, 5
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _p3$20[ebp], edx
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t0$26[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	sub	eax, DWORD PTR _p3$20[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _x0$17[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	sub	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _x3$14[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _x1$16[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	sub	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _x2$15[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 56
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t0$26[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, 2
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _t2$24[ebp], eax
	mov	eax, 2
	shl	eax, 3
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _t3$23[ebp], edx
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _p3$20[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _p4$19[ebp], eax
	mov	eax, DWORD PTR _t0$26[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _p1$22[ebp], eax
	mov	eax, DWORD PTR _t1$25[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _p2$21[ebp], eax
	mov	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	imul	ecx, eax, 4816
	mov	DWORD PTR _p5$18[ebp], ecx
	imul	eax, DWORD PTR _t0$26[ebp], 1223
	mov	DWORD PTR _t0$26[ebp], eax
	imul	eax, DWORD PTR _t1$25[ebp], 8410
	mov	DWORD PTR _t1$25[ebp], eax
	imul	eax, DWORD PTR _t2$24[ebp], 12586
	mov	DWORD PTR _t2$24[ebp], eax
	imul	eax, DWORD PTR _t3$23[ebp], 6149
	mov	DWORD PTR _t3$23[ebp], eax
	imul	eax, DWORD PTR _p1$22[ebp], -3685
	add	eax, DWORD PTR _p5$18[ebp]
	mov	DWORD PTR _p1$22[ebp], eax
	imul	eax, DWORD PTR _p2$21[ebp], -10497
	add	eax, DWORD PTR _p5$18[ebp]
	mov	DWORD PTR _p2$21[ebp], eax
	imul	eax, DWORD PTR _p3$20[ebp], -8034
	mov	DWORD PTR _p3$20[ebp], eax
	imul	eax, DWORD PTR _p4$19[ebp], -1597
	mov	DWORD PTR _p4$19[ebp], eax
	mov	eax, DWORD PTR _p1$22[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	mov	DWORD PTR _t3$23[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	mov	DWORD PTR _t2$24[ebp], eax
	mov	eax, DWORD PTR _p2$21[ebp]
	add	eax, DWORD PTR _p4$19[ebp]
	add	eax, DWORD PTR _t1$25[ebp]
	mov	DWORD PTR _t1$25[ebp], eax
	mov	eax, DWORD PTR _p1$22[ebp]
	add	eax, DWORD PTR _p3$20[ebp]
	add	eax, DWORD PTR _t0$26[ebp]
	mov	DWORD PTR _t0$26[ebp], eax

; 2302 : 				// constants scaled things up by 1<<12; let's bring them back
; 2303 : 				// down, but keep 2 extra bits of precision
; 2304 : 				x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	mov	eax, DWORD PTR _x0$17[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x0$17[ebp], eax
	mov	eax, DWORD PTR _x1$16[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x1$16[ebp], eax
	mov	eax, DWORD PTR _x2$15[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x2$15[ebp], eax
	mov	eax, DWORD PTR _x3$14[ebp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR _x3$14[ebp], eax

; 2305 : 			v[0] = (x0 + t3) >> 10;

	mov	eax, DWORD PTR _x0$17[ebp]
	add	eax, DWORD PTR _t3$23[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2306 : 			v[56] = (x0 - t3) >> 10;

	mov	eax, DWORD PTR _x0$17[ebp]
	sub	eax, DWORD PTR _t3$23[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 56
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2307 : 			v[8] = (x1 + t2) >> 10;

	mov	eax, DWORD PTR _x1$16[ebp]
	add	eax, DWORD PTR _t2$24[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 2308 : 			v[48] = (x1 - t2) >> 10;

	mov	eax, DWORD PTR _x1$16[ebp]
	sub	eax, DWORD PTR _t2$24[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 48
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2309 : 			v[16] = (x2 + t1) >> 10;

	mov	eax, DWORD PTR _x2$15[ebp]
	add	eax, DWORD PTR _t1$25[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 2310 : 			v[40] = (x2 - t1) >> 10;

	mov	eax, DWORD PTR _x2$15[ebp]
	sub	eax, DWORD PTR _t1$25[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2311 : 			v[24] = (x3 + t0) >> 10;

	mov	eax, DWORD PTR _x3$14[ebp]
	add	eax, DWORD PTR _t0$26[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	imul	edx, ecx, 24
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2312 : 			v[32] = (x3 - t0) >> 10;

	mov	eax, DWORD PTR _x3$14[ebp]
	sub	eax, DWORD PTR _t0$26[ebp]
	sar	eax, 10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 5
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx], eax
$LN9@stbi__idct:

; 2313 : 		}
; 2314 : 	}

	jmp	$LN2@stbi__idct
$LN3@stbi__idct:

; 2315 : 
; 2316 : 	for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {

	mov	DWORD PTR _i$[ebp], 0
	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _v$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _o$[ebp], ecx
	jmp	SHORT $LN7@stbi__idct
$LN5@stbi__idct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _o$[ebp]
	add	edx, DWORD PTR _out_stride$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN7@stbi__idct:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN1@stbi__idct

; 2317 : 		// no fast case since the first 1D IDCT spread components out
; 2318 : 		STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _p2$8[ebp], edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _p3$7[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	imul	ecx, eax, 2217
	mov	DWORD PTR _p1$9[ebp], ecx
	imul	eax, DWORD PTR _p3$7[ebp], -7567
	add	eax, DWORD PTR _p1$9[ebp]
	mov	DWORD PTR _t2$11[ebp], eax
	imul	eax, DWORD PTR _p2$8[ebp], 3135
	add	eax, DWORD PTR _p1$9[ebp]
	mov	DWORD PTR _t3$10[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _p2$8[ebp], eax
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _p3$7[ebp], edx
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t0$13[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	sub	eax, DWORD PTR _p3$7[ebp]
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _x0$4[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	sub	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _x3$1[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _x1$3[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	sub	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _x2$2[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t0$13[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _t2$11[ebp], eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _t3$10[ebp], edx
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _p3$7[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _p4$6[ebp], eax
	mov	eax, DWORD PTR _t0$13[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _p1$9[ebp], eax
	mov	eax, DWORD PTR _t1$12[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _p2$8[ebp], eax
	mov	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	imul	ecx, eax, 4816
	mov	DWORD PTR _p5$5[ebp], ecx
	imul	eax, DWORD PTR _t0$13[ebp], 1223
	mov	DWORD PTR _t0$13[ebp], eax
	imul	eax, DWORD PTR _t1$12[ebp], 8410
	mov	DWORD PTR _t1$12[ebp], eax
	imul	eax, DWORD PTR _t2$11[ebp], 12586
	mov	DWORD PTR _t2$11[ebp], eax
	imul	eax, DWORD PTR _t3$10[ebp], 6149
	mov	DWORD PTR _t3$10[ebp], eax
	imul	eax, DWORD PTR _p1$9[ebp], -3685
	add	eax, DWORD PTR _p5$5[ebp]
	mov	DWORD PTR _p1$9[ebp], eax
	imul	eax, DWORD PTR _p2$8[ebp], -10497
	add	eax, DWORD PTR _p5$5[ebp]
	mov	DWORD PTR _p2$8[ebp], eax
	imul	eax, DWORD PTR _p3$7[ebp], -8034
	mov	DWORD PTR _p3$7[ebp], eax
	imul	eax, DWORD PTR _p4$6[ebp], -1597
	mov	DWORD PTR _p4$6[ebp], eax
	mov	eax, DWORD PTR _p1$9[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	mov	DWORD PTR _t3$10[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	mov	DWORD PTR _t2$11[ebp], eax
	mov	eax, DWORD PTR _p2$8[ebp]
	add	eax, DWORD PTR _p4$6[ebp]
	add	eax, DWORD PTR _t1$12[ebp]
	mov	DWORD PTR _t1$12[ebp], eax
	mov	eax, DWORD PTR _p1$9[ebp]
	add	eax, DWORD PTR _p3$7[ebp]
	add	eax, DWORD PTR _t0$13[ebp]
	mov	DWORD PTR _t0$13[ebp], eax

; 2319 : 			// constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2320 : 			// loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2321 : 			// we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2322 : 			// so we want to round that, which means adding 0.5 * 1<<17,
; 2323 : 			// aka 65536. Also, we'll end up with -128 to 127 that we want
; 2324 : 			// to encode as 0..255 by adding 128, so we'll add that before the shift
; 2325 : 			x0 += 65536 + (128 << 17);

	mov	eax, DWORD PTR _x0$4[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x0$4[ebp], eax

; 2326 : 		x1 += 65536 + (128 << 17);

	mov	eax, DWORD PTR _x1$3[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x1$3[ebp], eax

; 2327 : 		x2 += 65536 + (128 << 17);

	mov	eax, DWORD PTR _x2$2[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x2$2[ebp], eax

; 2328 : 		x3 += 65536 + (128 << 17);

	mov	eax, DWORD PTR _x3$1[ebp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR _x3$1[ebp], eax

; 2329 : 		// tried computing the shifts into temps, or'ing the temps to see
; 2330 : 		// if any were out of range, but that was slower
; 2331 : 		o[0] = stbi__clamp((x0 + t3) >> 17);

	mov	eax, DWORD PTR _x0$4[ebp]
	add	eax, DWORD PTR _t3$10[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2332 : 		o[7] = stbi__clamp((x0 - t3) >> 17);

	mov	eax, DWORD PTR _x0$4[ebp]
	sub	eax, DWORD PTR _t3$10[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2333 : 		o[1] = stbi__clamp((x1 + t2) >> 17);

	mov	eax, DWORD PTR _x1$3[ebp]
	add	eax, DWORD PTR _t2$11[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2334 : 		o[6] = stbi__clamp((x1 - t2) >> 17);

	mov	eax, DWORD PTR _x1$3[ebp]
	sub	eax, DWORD PTR _t2$11[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2335 : 		o[2] = stbi__clamp((x2 + t1) >> 17);

	mov	eax, DWORD PTR _x2$2[ebp]
	add	eax, DWORD PTR _t1$12[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2336 : 		o[5] = stbi__clamp((x2 - t1) >> 17);

	mov	eax, DWORD PTR _x2$2[ebp]
	sub	eax, DWORD PTR _t1$12[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2337 : 		o[3] = stbi__clamp((x3 + t0) >> 17);

	mov	eax, DWORD PTR _x3$1[ebp]
	add	eax, DWORD PTR _t0$13[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2338 : 		o[4] = stbi__clamp((x3 - t0) >> 17);

	mov	eax, DWORD PTR _x3$1[ebp]
	sub	eax, DWORD PTR _t0$13[ebp]
	sar	eax, 17					; 00000011H
	push	eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 2339 : 	}

	jmp	$LN5@stbi__idct
$LN1@stbi__idct:

; 2340 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__idct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1024				; 00000400H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN13@stbi__idct:
	DD	1
	DD	$LN12@stbi__idct
$LN12@stbi__idct:
	DD	-276					; fffffeecH
	DD	256					; 00000100H
	DD	$LN11@stbi__idct
$LN11@stbi__idct:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?stbi__idct_block@@YAXPAEHQAF@Z ENDP			; stbi__idct_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__clamp@@YAEH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?stbi__clamp@@YAEH@Z PROC				; stbi__clamp, COMDAT

; 2232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2233 : 	// trick to use a single test to catch both cases
; 2234 : 	if ((unsigned int)x > 255) {

	cmp	DWORD PTR _x$[ebp], 255			; 000000ffH
	jbe	SHORT $LN2@stbi__clam

; 2235 : 		if (x < 0) return 0;

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN3@stbi__clam
	xor	al, al
	jmp	SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 2236 : 		if (x > 255) return 255;

	cmp	DWORD PTR _x$[ebp], 255			; 000000ffH
	jle	SHORT $LN2@stbi__clam
	or	al, 255					; 000000ffH
	jmp	SHORT $LN1@stbi__clam
$LN2@stbi__clam:

; 2237 : 	}
; 2238 : 	return (stbi_uc)x;

	mov	al, BYTE PTR _x$[ebp]
$LN1@stbi__clam:

; 2239 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__clamp@@YAEH@Z ENDP				; stbi__clamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block_prog_ac@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@PAF@Z
_TEXT	SEGMENT
_p$1 = -152						; size = 4
_rs$2 = -140						; size = 4
_s$3 = -128						; size = 4
_r$4 = -116						; size = 4
_p$5 = -104						; size = 4
_bit$6 = -92						; size = 2
_rs$7 = -80						; size = 4
_s$8 = -68						; size = 4
_r$9 = -56						; size = 4
_c$10 = -44						; size = 4
_zig$11 = -32						; size = 4
_shift$12 = -20						; size = 4
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hac$ = 16						; size = 4
_fac$ = 20						; size = 4
?stbi__jpeg_decode_block_prog_ac@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@PAF@Z PROC ; stbi__jpeg_decode_block_prog_ac, COMDAT

; 2105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2106 : 	int k;
; 2107 : 	if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18384], 0
	jne	SHORT $LN13@stbi__jpeg
	push	OFFSET ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2108 : 
; 2109 : 	if (j->succ_high == 0) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	$LN14@stbi__jpeg

; 2110 : 		int shift = j->succ_low;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18396]
	mov	DWORD PTR _shift$12[ebp], ecx

; 2111 : 
; 2112 : 		if (j->eob_run) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18400], 0
	je	SHORT $LN16@stbi__jpeg

; 2113 : 			--j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 2114 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 2115 : 		}
; 2116 : 
; 2117 : 		k = j->spec_start;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
$LN4@stbi__jpeg:

; 2118 : 		do {
; 2119 : 			unsigned int zig;
; 2120 : 			int c, r, s;
; 2121 : 			if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN17@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN17@stbi__jpeg:

; 2122 : 			c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$10[ebp], ecx

; 2123 : 			r = fac[c];

	mov	eax, DWORD PTR _c$10[ebp]
	mov	ecx, DWORD PTR _fac$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _r$9[ebp], edx

; 2124 : 			if (r) { // fast-AC path

	cmp	DWORD PTR _r$9[ebp], 0
	je	SHORT $LN18@stbi__jpeg

; 2125 : 				k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR _r$9[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2126 : 				s = r & 15; // combined length

	mov	eax, DWORD PTR _r$9[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$8[ebp], eax

; 2127 : 				j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$8[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 2128 : 				j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$8[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 2129 : 				zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	DWORD PTR _zig$11[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2130 : 				data[zig] = (short)((r >> 8) << shift);

	mov	eax, DWORD PTR _r$9[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _shift$12[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _zig$11[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 2131 : 			}

	jmp	$LN2@stbi__jpeg
$LN18@stbi__jpeg:

; 2132 : 			else {
; 2133 : 				int rs = stbi__jpeg_huff_decode(j, hac);

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$7[ebp], eax

; 2134 : 				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _rs$7[ebp], 0
	jge	SHORT $LN20@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 2135 : 				s = rs & 15;

	mov	eax, DWORD PTR _rs$7[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$8[ebp], eax

; 2136 : 				r = rs >> 4;

	mov	eax, DWORD PTR _rs$7[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$9[ebp], eax

; 2137 : 				if (s == 0) {

	cmp	DWORD PTR _s$8[ebp], 0
	jne	SHORT $LN21@stbi__jpeg

; 2138 : 					if (r < 15) {

	cmp	DWORD PTR _r$9[ebp], 15			; 0000000fH
	jge	SHORT $LN23@stbi__jpeg

; 2139 : 						j->eob_run = (1 << r);

	mov	eax, 1
	mov	ecx, DWORD PTR _r$9[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax

; 2140 : 						if (r)

	cmp	DWORD PTR _r$9[ebp], 0
	je	SHORT $LN24@stbi__jpeg

; 2141 : 							j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	eax, DWORD PTR _r$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_get_bits@@YAHPAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
	add	esp, 8
	mov	edx, DWORD PTR _j$[ebp]
	add	eax, DWORD PTR [edx+18400]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax
$LN24@stbi__jpeg:

; 2142 : 						--j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 2143 : 						break;

	jmp	SHORT $LN3@stbi__jpeg
$LN23@stbi__jpeg:

; 2144 : 					}
; 2145 : 					k += 16;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], eax

; 2146 : 				}

	jmp	SHORT $LN2@stbi__jpeg
$LN21@stbi__jpeg:

; 2147 : 				else {
; 2148 : 					k += r;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, DWORD PTR _r$9[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2149 : 					zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	DWORD PTR _zig$11[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2150 : 					data[zig] = (short)(stbi__extend_receive(j, s) << shift);

	mov	eax, DWORD PTR _s$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z ; stbi__extend_receive
	add	esp, 8
	mov	ecx, DWORD PTR _shift$12[ebp]
	shl	eax, cl
	mov	edx, DWORD PTR _zig$11[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
$LN2@stbi__jpeg:

; 2151 : 				}
; 2152 : 			}
; 2153 : 		} while (k <= j->spec_end);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jle	$LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2154 : 	}

	jmp	$LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 2155 : 	else {
; 2156 : 		// refinement scan for these AC coefficients
; 2157 : 
; 2158 : 		short bit = (short)(1 << j->succ_low);

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+18396]
	shl	edx, cl
	mov	WORD PTR _bit$6[ebp], dx

; 2159 : 
; 2160 : 		if (j->eob_run) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18400], 0
	je	$LN25@stbi__jpeg

; 2161 : 			--j->eob_run;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18400]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18400], ecx

; 2162 : 			for (k = j->spec_start; k <= j->spec_end; ++k) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@stbi__jpeg:
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jg	SHORT $LN6@stbi__jpeg

; 2163 : 				short* p = &data[stbi__jpeg_dezigzag[k]];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	edx, DWORD PTR _data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _p$5[ebp], eax

; 2164 : 				if (*p != 0)

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN27@stbi__jpeg

; 2165 : 					if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@stbi__jpeg

; 2166 : 						if ((*p & bit) == 0) {

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	movsx	edx, WORD PTR _bit$6[ebp]
	and	ecx, edx
	jne	SHORT $LN27@stbi__jpeg

; 2167 : 							if (*p > 0)

	mov	eax, DWORD PTR _p$5[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN30@stbi__jpeg

; 2168 : 								* p += bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$5[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _p$5[ebp]
	mov	WORD PTR [eax], dx
	jmp	SHORT $LN27@stbi__jpeg
$LN30@stbi__jpeg:

; 2169 : 							else
; 2170 : 								*p -= bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$5[ebp]
	movsx	edx, WORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _p$5[ebp]
	mov	WORD PTR [eax], dx
$LN27@stbi__jpeg:

; 2171 : 						}
; 2172 : 			}

	jmp	$LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2173 : 		}

	jmp	$LN15@stbi__jpeg
$LN25@stbi__jpeg:

; 2174 : 		else {
; 2175 : 			k = j->spec_start;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18384]
	mov	DWORD PTR _k$[ebp], ecx
$LN10@stbi__jpeg:

; 2176 : 			do {
; 2177 : 				int r, s;
; 2178 : 				int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$2[ebp], eax

; 2179 : 				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _rs$2[ebp], 0
	jge	SHORT $LN32@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN32@stbi__jpeg:

; 2180 : 				s = rs & 15;

	mov	eax, DWORD PTR _rs$2[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$3[ebp], eax

; 2181 : 				r = rs >> 4;

	mov	eax, DWORD PTR _rs$2[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$4[ebp], eax

; 2182 : 				if (s == 0) {

	cmp	DWORD PTR _s$3[ebp], 0
	jne	SHORT $LN33@stbi__jpeg

; 2183 : 					if (r < 15) {

	cmp	DWORD PTR _r$4[ebp], 15			; 0000000fH
	jge	SHORT $LN36@stbi__jpeg

; 2184 : 						j->eob_run = (1 << r) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _r$4[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax

; 2185 : 						if (r)

	cmp	DWORD PTR _r$4[ebp], 0
	je	SHORT $LN37@stbi__jpeg

; 2186 : 							j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	eax, DWORD PTR _r$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_get_bits@@YAHPAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
	add	esp, 8
	mov	edx, DWORD PTR _j$[ebp]
	add	eax, DWORD PTR [edx+18400]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18400], eax
$LN37@stbi__jpeg:

; 2187 : 						r = 64; // force end of block

	mov	DWORD PTR _r$4[ebp], 64			; 00000040H
$LN36@stbi__jpeg:

; 2188 : 					}
; 2189 : 					else {
; 2190 : 						// r=15 s=0 should write 16 0s, so we just do
; 2191 : 						// a run of 15 0s and then write s (which is 0),
; 2192 : 						// so we don't have to do anything special here
; 2193 : 					}
; 2194 : 				}

	jmp	SHORT $LN11@stbi__jpeg
$LN33@stbi__jpeg:

; 2195 : 				else {
; 2196 : 					if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _s$3[ebp], 1
	je	SHORT $LN38@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN38@stbi__jpeg:

; 2197 : 					// sign bit
; 2198 : 					if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN39@stbi__jpeg

; 2199 : 						s = bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	DWORD PTR _s$3[ebp], eax
	jmp	SHORT $LN11@stbi__jpeg
$LN39@stbi__jpeg:

; 2200 : 					else
; 2201 : 						s = -bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	neg	eax
	mov	DWORD PTR _s$3[ebp], eax
$LN11@stbi__jpeg:

; 2202 : 				}
; 2203 : 
; 2204 : 				// advance by r
; 2205 : 				while (k <= j->spec_end) {

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jg	$LN8@stbi__jpeg

; 2206 : 					short* p = &data[stbi__jpeg_dezigzag[k++]];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	edx, DWORD PTR _data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _p$1[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx

; 2207 : 					if (*p != 0) {

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN41@stbi__jpeg

; 2208 : 						if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN43@stbi__jpeg

; 2209 : 							if ((*p & bit) == 0) {

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	movsx	edx, WORD PTR _bit$6[ebp]
	and	ecx, edx
	jne	SHORT $LN43@stbi__jpeg

; 2210 : 								if (*p > 0)

	mov	eax, DWORD PTR _p$1[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN45@stbi__jpeg

; 2211 : 									* p += bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$1[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _p$1[ebp]
	mov	WORD PTR [eax], dx
	jmp	SHORT $LN43@stbi__jpeg
$LN45@stbi__jpeg:

; 2212 : 								else
; 2213 : 									*p -= bit;

	movsx	eax, WORD PTR _bit$6[ebp]
	mov	ecx, DWORD PTR _p$1[ebp]
	movsx	edx, WORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _p$1[ebp]
	mov	WORD PTR [eax], dx
$LN43@stbi__jpeg:

; 2214 : 							}
; 2215 : 					}

	jmp	SHORT $LN42@stbi__jpeg
$LN41@stbi__jpeg:

; 2216 : 					else {
; 2217 : 						if (r == 0) {

	cmp	DWORD PTR _r$4[ebp], 0
	jne	SHORT $LN47@stbi__jpeg

; 2218 : 							*p = (short)s;

	mov	eax, DWORD PTR _p$1[ebp]
	mov	cx, WORD PTR _s$3[ebp]
	mov	WORD PTR [eax], cx

; 2219 : 							break;

	jmp	SHORT $LN8@stbi__jpeg
$LN47@stbi__jpeg:

; 2220 : 						}
; 2221 : 						--r;

	mov	eax, DWORD PTR _r$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$4[ebp], eax
$LN42@stbi__jpeg:

; 2222 : 					}
; 2223 : 				}

	jmp	$LN11@stbi__jpeg
$LN8@stbi__jpeg:

; 2224 : 			} while (k <= j->spec_end);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18388]
	jle	$LN10@stbi__jpeg
$LN15@stbi__jpeg:

; 2225 : 		}
; 2226 : 	}
; 2227 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 2228 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_decode_block_prog_ac@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@PAF@Z ENDP ; stbi__jpeg_decode_block_prog_ac
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block_prog_dc@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@H@Z
_TEXT	SEGMENT
tv83 = -232						; size = 4
_t$ = -32						; size = 4
_dc$ = -20						; size = 4
_diff$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hdc$ = 16						; size = 4
_b$ = 20						; size = 4
?stbi__jpeg_decode_block_prog_dc@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@H@Z PROC ; stbi__jpeg_decode_block_prog_dc, COMDAT

; 2077 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2078 : 	int diff, dc;
; 2079 : 	int t;
; 2080 : 	if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18388], 0
	je	SHORT $LN2@stbi__jpeg
	push	OFFSET ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 2081 : 
; 2082 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN3@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN3@stbi__jpeg:

; 2083 : 
; 2084 : 	if (j->succ_high == 0) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18392], 0
	jne	$LN4@stbi__jpeg

; 2085 : 		// first scan for DC coefficient, must be first
; 2086 : 		memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now

	push	128					; 00000080H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2087 : 		t = stbi__jpeg_huff_decode(j, hdc);

	mov	eax, DWORD PTR _hdc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 2088 : 		diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN8@stbi__jpeg
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z ; stbi__extend_receive
	add	esp, 8
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@stbi__jpeg
$LN8@stbi__jpeg:
	mov	DWORD PTR tv83[ebp], 0
$LN9@stbi__jpeg:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _diff$[ebp], edx

; 2089 : 
; 2090 : 		dc = j->img_comp[b].dc_pred + diff;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18100]
	add	edx, DWORD PTR _diff$[ebp]
	mov	DWORD PTR _dc$[ebp], edx

; 2091 : 		j->img_comp[b].dc_pred = dc;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	DWORD PTR [ecx+eax+18100], edx

; 2092 : 		data[0] = (short)(dc << j->succ_low);

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	ecx, DWORD PTR [eax+18396]
	shl	edx, cl
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _data$[ebp]
	mov	WORD PTR [eax+ecx], dx

; 2093 : 	}

	jmp	SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 2094 : 	else {
; 2095 : 		// refinement scan for DC coefficient
; 2096 : 		if (stbi__jpeg_get_bit(j))

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@stbi__jpeg

; 2097 : 			data[0] += (short)(1 << j->succ_low);

	mov	eax, 2
	imul	edx, eax, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, 1
	mov	ecx, DWORD PTR [eax+18396]
	shl	esi, cl
	movsx	ecx, si
	mov	eax, DWORD PTR _data$[ebp]
	movsx	edx, WORD PTR [eax+edx]
	add	edx, ecx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _data$[ebp]
	mov	WORD PTR [eax+ecx], dx
$LN5@stbi__jpeg:

; 2098 : 	}
; 2099 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 2100 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_decode_block_prog_dc@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@H@Z ENDP ; stbi__jpeg_decode_block_prog_dc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_decode_block@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@2PAFHPAG@Z
_TEXT	SEGMENT
tv80 = -304						; size = 4
_rs$1 = -104						; size = 4
_s$2 = -92						; size = 4
_r$3 = -80						; size = 4
_c$4 = -68						; size = 4
_zig$5 = -56						; size = 4
_t$ = -44						; size = 4
_k$ = -32						; size = 4
_dc$ = -20						; size = 4
_diff$ = -8						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hdc$ = 16						; size = 4
_hac$ = 20						; size = 4
_fac$ = 24						; size = 4
_b$ = 28						; size = 4
_dequant$ = 32						; size = 4
?stbi__jpeg_decode_block@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@2PAFHPAG@Z PROC ; stbi__jpeg_decode_block, COMDAT

; 2023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 2024 : 	int diff, dc, k;
; 2025 : 	int t;
; 2026 : 
; 2027 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN5@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN5@stbi__jpeg:

; 2028 : 	t = stbi__jpeg_huff_decode(j, hdc);

	mov	eax, DWORD PTR _hdc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 2029 : 	if (t < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _t$[ebp], 0
	jge	SHORT $LN6@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2030 : 
; 2031 : 	// 0 all the ac values now so we can do it 32-bits at a time
; 2032 : 	memset(data, 0, 64 * sizeof(data[0]));

	push	128					; 00000080H
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2033 : 
; 2034 : 	diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN15@stbi__jpeg
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z ; stbi__extend_receive
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN16@stbi__jpeg
$LN15@stbi__jpeg:
	mov	DWORD PTR tv80[ebp], 0
$LN16@stbi__jpeg:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _diff$[ebp], edx

; 2035 : 	dc = j->img_comp[b].dc_pred + diff;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+eax+18100]
	add	edx, DWORD PTR _diff$[ebp]
	mov	DWORD PTR _dc$[ebp], edx

; 2036 : 	j->img_comp[b].dc_pred = dc;

	imul	eax, DWORD PTR _b$[ebp], 72
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dc$[ebp]
	mov	DWORD PTR [ecx+eax+18100], edx

; 2037 : 	data[0] = (short)(dc * dequant[0]);

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dequant$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	imul	eax, DWORD PTR _dc$[ebp]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx], ax

; 2038 : 
; 2039 : 	// decode AC components, see JPEG spec
; 2040 : 	k = 1;

	mov	DWORD PTR _k$[ebp], 1
$LN4@stbi__jpeg:

; 2041 : 	do {
; 2042 : 		unsigned int zig;
; 2043 : 		int c, r, s;
; 2044 : 		if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN7@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN7@stbi__jpeg:

; 2045 : 		c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$4[ebp], ecx

; 2046 : 		r = fac[c];

	mov	eax, DWORD PTR _c$4[ebp]
	mov	ecx, DWORD PTR _fac$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _r$3[ebp], edx

; 2047 : 		if (r) { // fast-AC path

	cmp	DWORD PTR _r$3[ebp], 0
	je	SHORT $LN8@stbi__jpeg

; 2048 : 			k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR _r$3[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2049 : 			s = r & 15; // combined length

	mov	eax, DWORD PTR _r$3[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$2[ebp], eax

; 2050 : 			j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$2[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 2051 : 			j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$2[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 2052 : 			// decode into unzigzag'd location
; 2053 : 			zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	DWORD PTR _zig$5[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2054 : 			data[zig] = (short)((r >> 8) * dequant[zig]);

	mov	eax, DWORD PTR _r$3[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _zig$5[ebp]
	mov	edx, DWORD PTR _dequant$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2]
	imul	eax, ecx
	mov	edx, DWORD PTR _zig$5[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 2055 : 		}

	jmp	$LN2@stbi__jpeg
$LN8@stbi__jpeg:

; 2056 : 		else {
; 2057 : 			int rs = stbi__jpeg_huff_decode(j, hac);

	mov	eax, DWORD PTR _hac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	add	esp, 8
	mov	DWORD PTR _rs$1[ebp], eax

; 2058 : 			if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR _rs$1[ebp], 0
	jge	SHORT $LN10@stbi__jpeg
	push	OFFSET ??_C@_0BB@IIMLINA@bad?5huffman?5code@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 2059 : 			s = rs & 15;

	mov	eax, DWORD PTR _rs$1[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _s$2[ebp], eax

; 2060 : 			r = rs >> 4;

	mov	eax, DWORD PTR _rs$1[ebp]
	sar	eax, 4
	mov	DWORD PTR _r$3[ebp], eax

; 2061 : 			if (s == 0) {

	cmp	DWORD PTR _s$2[ebp], 0
	jne	SHORT $LN11@stbi__jpeg

; 2062 : 				if (rs != 0xf0) break; // end block

	cmp	DWORD PTR _rs$1[ebp], 240		; 000000f0H
	je	SHORT $LN13@stbi__jpeg
	jmp	SHORT $LN3@stbi__jpeg
$LN13@stbi__jpeg:

; 2063 : 				k += 16;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], eax

; 2064 : 			}

	jmp	SHORT $LN2@stbi__jpeg
$LN11@stbi__jpeg:

; 2065 : 			else {
; 2066 : 				k += r;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, DWORD PTR _r$3[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 2067 : 				// decode into unzigzag'd location
; 2068 : 				zig = stbi__jpeg_dezigzag[k++];

	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR ?stbi__jpeg_dezigzag@@3QBEB[eax]
	mov	DWORD PTR _zig$5[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 2069 : 				data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);

	mov	eax, DWORD PTR _s$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z ; stbi__extend_receive
	add	esp, 8
	mov	edx, DWORD PTR _zig$5[ebp]
	mov	ecx, DWORD PTR _dequant$[ebp]
	movzx	edx, WORD PTR [ecx+edx*2]
	imul	eax, edx
	mov	ecx, DWORD PTR _zig$5[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN2@stbi__jpeg:

; 2070 : 			}
; 2071 : 		}
; 2072 : 	} while (k < 64);

	cmp	DWORD PTR _k$[ebp], 64			; 00000040H
	jl	$LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2073 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 2074 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_decode_block@@YAHPAUstbi__jpeg@@QAFPAUstbi__huffman@@2PAFHPAG@Z ENDP ; stbi__jpeg_decode_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = 8							; size = 4
?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z PROC		; stbi__jpeg_get_bit, COMDAT

; 1995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1996 : 	unsigned int k;
; 1997 : 	if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 1
	jge	SHORT $LN2@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN2@stbi__jpeg:

; 1998 : 	k = j->code_buffer;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	mov	DWORD PTR _k$[ebp], ecx

; 1999 : 	j->code_buffer <<= 1;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 2000 : 	--j->code_bits;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 2001 : 	return k & 0x80000000;

	mov	eax, DWORD PTR _k$[ebp]
	and	eax, -2147483648			; 80000000H

; 2002 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_get_bit@@YAHPAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_get_bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_get_bits@@YAHPAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_n$ = 12						; size = 4
?stbi__jpeg_get_bits@@YAHPAUstbi__jpeg@@H@Z PROC	; stbi__jpeg_get_bits, COMDAT

; 1984 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1985 : 	unsigned int k;
; 1986 : 	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN2@stbi__jpeg:

; 1987 : 	k = stbi_lrot(j->code_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18364]
	push	edx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 1988 : 	j->code_buffer = k & ~stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR ?stbi__bmask@@3QBIB[eax*4]
	not	ecx
	and	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 1989 : 	k &= stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, DWORD PTR ?stbi__bmask@@3QBIB[eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 1990 : 	j->code_bits -= n;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1991 : 	return k;

	mov	eax, DWORD PTR _k$[ebp]

; 1992 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_get_bits@@YAHPAUstbi__jpeg@@H@Z ENDP	; stbi__jpeg_get_bits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z
_TEXT	SEGMENT
_sgn$ = -20						; size = 4
_k$ = -8						; size = 4
_j$ = 8							; size = 4
_n$ = 12						; size = 4
?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z PROC	; stbi__extend_receive, COMDAT

; 1968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1969 : 	unsigned int k;
; 1970 : 	int sgn;
; 1971 : 	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	SHORT $LN2@stbi__exte
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN2@stbi__exte:

; 1972 : 
; 1973 : 	sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	sar	ecx, 31					; 0000001fH
	mov	DWORD PTR _sgn$[ebp], ecx

; 1974 : 	k = stbi_lrot(j->code_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx+18364]
	push	edx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax

; 1975 : 	STBI_ASSERT(n >= 0 && n < (int)(sizeof(stbi__bmask) / sizeof(*stbi__bmask)));

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN4@stbi__exte
	cmp	DWORD PTR _n$[ebp], 17			; 00000011H
	jl	SHORT $LN5@stbi__exte
$LN4@stbi__exte:
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z@4JA
	add	eax, 7
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1IA@IKCMGFNK@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@stbi__exte:

; 1976 : 	j->code_buffer = k & ~stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR ?stbi__bmask@@3QBIB[eax*4]
	not	ecx
	and	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18364], ecx

; 1977 : 	k &= stbi__bmask[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, DWORD PTR ?stbi__bmask@@3QBIB[eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 1978 : 	j->code_bits -= n;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1979 : 	return k + (stbi__jbias[n] & ~sgn);

	mov	eax, DWORD PTR _sgn$[ebp]
	not	eax
	mov	ecx, DWORD PTR _n$[ebp]
	and	eax, DWORD PTR ?stbi__jbias@@3QBHB[ecx*4]
	add	eax, DWORD PTR _k$[ebp]

; 1980 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__extend_receive@@YAHPAUstbi__jpeg@@H@Z ENDP	; stbi__extend_receive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z
_TEXT	SEGMENT
_s$1 = -44						; size = 4
_k$ = -32						; size = 4
_c$ = -20						; size = 4
_temp$ = -8						; size = 4
_j$ = 8							; size = 4
_h$ = 12						; size = 4
?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z PROC ; stbi__jpeg_huff_decode, COMDAT

; 1914 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1915 : 	unsigned int temp;
; 1916 : 	int c, k;
; 1917 : 
; 1918 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 16		; 00000010H
	jge	SHORT $LN5@stbi__jpeg
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	add	esp, 4
$LN5@stbi__jpeg:

; 1919 : 
; 1920 : 	// look at the top FAST_BITS and determine what symbol ID it is,
; 1921 : 	// if the code is <= FAST_BITS
; 1922 : 	c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 23					; 00000017H
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _c$[ebp], ecx

; 1923 : 	k = h->fast[c];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _k$[ebp], ecx

; 1924 : 	if (k < 255) {

	cmp	DWORD PTR _k$[ebp], 255			; 000000ffH
	jge	SHORT $LN6@stbi__jpeg

; 1925 : 		int s = h->size[k];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	DWORD PTR _s$1[ebp], ecx

; 1926 : 		if (s > j->code_bits)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$1[ebp]
	cmp	ecx, DWORD PTR [eax+18368]
	jle	SHORT $LN7@stbi__jpeg

; 1927 : 			return -1;

	or	eax, -1
	jmp	$LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 1928 : 		j->code_buffer <<= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _s$1[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 1929 : 		j->code_bits -= s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _s$1[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1930 : 		return h->values[k];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [eax+1024]
	jmp	$LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1931 : 	}
; 1932 : 
; 1933 : 	// naive test is to shift the code_buffer down so k bits are
; 1934 : 	// valid, then test against maxcode. To speed this up, we've
; 1935 : 	// preshifted maxcode left so that it has (16-k) 0s at the
; 1936 : 	// end; in other words, regardless of the number of bits, it
; 1937 : 	// wants to be compared against something shifted to have 16;
; 1938 : 	// that way we don't need to shift inside the loop.
; 1939 : 	temp = j->code_buffer >> 16;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18364]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _temp$[ebp], ecx

; 1940 : 	for (k = FAST_BITS + 1; ; ++k)

	mov	DWORD PTR _k$[ebp], 10			; 0000000aH
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@stbi__jpeg:

; 1941 : 		if (temp < h->maxcode[k])

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+1540]
	jae	SHORT $LN8@stbi__jpeg

; 1942 : 			break;

	jmp	SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
	jmp	SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 1943 : 	if (k == 17) {

	cmp	DWORD PTR _k$[ebp], 17			; 00000011H
	jne	SHORT $LN9@stbi__jpeg

; 1944 : 		// error! code not found
; 1945 : 		j->code_bits -= 16;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1946 : 		return -1;

	or	eax, -1
	jmp	$LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 1947 : 	}
; 1948 : 
; 1949 : 	if (k > j->code_bits)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+18368]
	jle	SHORT $LN10@stbi__jpeg

; 1950 : 		return -1;

	or	eax, -1
	jmp	$LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 1951 : 
; 1952 : 	// convert the huffman code to the symbol id
; 1953 : 	c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	shr	edx, cl
	mov	eax, DWORD PTR _k$[ebp]
	and	edx, DWORD PTR ?stbi__bmask@@3QBIB[eax*4]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	add	edx, DWORD PTR [eax+ecx*4+1612]
	mov	DWORD PTR _c$[ebp], edx

; 1954 : 	STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	edx, 32					; 00000020H
	sub	edx, ecx
	mov	eax, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+18364]
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, DWORD PTR _c$[ebp]
	movzx	edx, BYTE PTR [ecx+1280]
	and	eax, DWORD PTR ?stbi__bmask@@3QBIB[edx*4]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+512]
	cmp	eax, ecx
	je	SHORT $LN12@stbi__jpeg
	mov	edx, DWORD PTR ?__LINE__Var@?0??stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z@4JA
	add	edx, 40					; 00000028H
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@stbi__jpeg:

; 1955 : 
; 1956 : 	// convert the id to a symbol
; 1957 : 	j->code_bits -= k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	sub	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1958 : 	j->code_buffer <<= k;

	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18364], edx

; 1959 : 	return h->values[c];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	movzx	eax, BYTE PTR [eax+1024]
$LN1@stbi__jpeg:

; 1960 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_huff_decode@@YAHPAUstbi__jpeg@@PAUstbi__huffman@@@Z ENDP ; stbi__jpeg_huff_decode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z
_TEXT	SEGMENT
tv70 = -220						; size = 4
_c$1 = -20						; size = 4
_b$2 = -8						; size = 4
_j$ = 8							; size = 4
?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z PROC	; stbi__grow_buffer_unsafe, COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
$LN4@stbi__grow:

; 1893 : 	do {
; 1894 : 		unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18376], 0
	je	SHORT $LN10@stbi__grow
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN11@stbi__grow
$LN10@stbi__grow:
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	eax, al
	mov	DWORD PTR tv70[ebp], eax
$LN11@stbi__grow:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _b$2[ebp], ecx

; 1895 : 		if (b == 0xff) {

	cmp	DWORD PTR _b$2[ebp], 255		; 000000ffH
	jne	SHORT $LN7@stbi__grow

; 1896 : 			int c = stbi__get8(j->s);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _c$1[ebp], edx
$LN5@stbi__grow:

; 1897 : 			while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

	cmp	DWORD PTR _c$1[ebp], 255		; 000000ffH
	jne	SHORT $LN6@stbi__grow
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _c$1[ebp], edx
	jmp	SHORT $LN5@stbi__grow
$LN6@stbi__grow:

; 1898 : 			if (c != 0) {

	cmp	DWORD PTR _c$1[ebp], 0
	je	SHORT $LN7@stbi__grow

; 1899 : 				j->marker = (unsigned char)c;

	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR _c$1[ebp]
	mov	BYTE PTR [eax+18372], cl

; 1900 : 				j->nomore = 1;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+18376], 1

; 1901 : 				return;

	jmp	SHORT $LN1@stbi__grow
$LN7@stbi__grow:

; 1902 : 			}
; 1903 : 		}
; 1904 : 		j->code_buffer |= b << (24 - j->code_bits);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, 24					; 00000018H
	sub	ecx, DWORD PTR [eax+18368]
	mov	edx, DWORD PTR _b$2[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _j$[ebp]
	or	edx, DWORD PTR [eax+18364]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+18364], edx

; 1905 : 		j->code_bits += 8;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+18368]
	add	ecx, 8
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+18368], ecx

; 1906 : 	} while (j->code_bits <= 24);

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+18368], 24		; 00000018H
	jle	$LN4@stbi__grow
$LN1@stbi__grow:

; 1907 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__grow_buffer_unsafe@@YAXPAUstbi__jpeg@@@Z ENDP	; stbi__grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__build_fast_ac@@YAXPAFPAUstbi__huffman@@@Z
_TEXT	SEGMENT
_m$1 = -92						; size = 4
_k$2 = -80						; size = 4
_len$3 = -68						; size = 4
_magbits$4 = -56					; size = 4
_run$5 = -44						; size = 4
_rs$6 = -32						; size = 4
_fast$7 = -17						; size = 1
_i$ = -8						; size = 4
_fast_ac$ = 8						; size = 4
_h$ = 12						; size = 4
?stbi__build_fast_ac@@YAXPAFPAUstbi__huffman@@@Z PROC	; stbi__build_fast_ac, COMDAT

; 1867 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1868 : 	int i;
; 1869 : 	for (i = 0; i < (1 << FAST_BITS); ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__buil
$LN2@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__buil:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	$LN1@stbi__buil

; 1870 : 		stbi_uc fast = h->fast[i];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _fast$7[ebp], cl

; 1871 : 		fast_ac[i] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fast_ac$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 1872 : 		if (fast < 255) {

	movzx	eax, BYTE PTR _fast$7[ebp]
	cmp	eax, 255				; 000000ffH
	jge	$LN5@stbi__buil

; 1873 : 			int rs = h->values[fast];

	movzx	eax, BYTE PTR _fast$7[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1024]
	mov	DWORD PTR _rs$6[ebp], edx

; 1874 : 			int run = (rs >> 4) & 15;

	mov	eax, DWORD PTR _rs$6[ebp]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _run$5[ebp], eax

; 1875 : 			int magbits = rs & 15;

	mov	eax, DWORD PTR _rs$6[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _magbits$4[ebp], eax

; 1876 : 			int len = h->size[fast];

	movzx	eax, BYTE PTR _fast$7[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1280]
	mov	DWORD PTR _len$3[ebp], edx

; 1877 : 
; 1878 : 			if (magbits && len + magbits <= FAST_BITS) {

	cmp	DWORD PTR _magbits$4[ebp], 0
	je	SHORT $LN5@stbi__buil
	mov	eax, DWORD PTR _len$3[ebp]
	add	eax, DWORD PTR _magbits$4[ebp]
	cmp	eax, 9
	jg	SHORT $LN5@stbi__buil

; 1879 : 				// magnitude code followed by receive_extend code
; 1880 : 				int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _len$3[ebp]
	shl	eax, cl
	and	eax, 511				; 000001ffH
	mov	ecx, 9
	sub	ecx, DWORD PTR _magbits$4[ebp]
	sar	eax, cl
	mov	DWORD PTR _k$2[ebp], eax

; 1881 : 				int m = 1 << (magbits - 1);

	mov	ecx, DWORD PTR _magbits$4[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _m$1[ebp], eax

; 1882 : 				if (k < m) k += (~0U << magbits) + 1;

	mov	eax, DWORD PTR _k$2[ebp]
	cmp	eax, DWORD PTR _m$1[ebp]
	jge	SHORT $LN7@stbi__buil
	or	eax, -1
	mov	ecx, DWORD PTR _magbits$4[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _k$2[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _k$2[ebp], edx
$LN7@stbi__buil:

; 1883 : 				// if the result is small enough, we can fit it in fast_ac table
; 1884 : 				if (k >= -128 && k <= 127)

	cmp	DWORD PTR _k$2[ebp], -128		; ffffff80H
	jl	SHORT $LN5@stbi__buil
	cmp	DWORD PTR _k$2[ebp], 127		; 0000007fH
	jg	SHORT $LN5@stbi__buil

; 1885 : 					fast_ac[i] = (stbi__int16)((k * 256) + (run * 16) + (len + magbits));

	mov	eax, DWORD PTR _k$2[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _run$5[ebp]
	shl	ecx, 4
	add	eax, ecx
	mov	edx, DWORD PTR _len$3[ebp]
	add	edx, DWORD PTR _magbits$4[ebp]
	add	eax, edx
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fast_ac$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN5@stbi__buil:

; 1886 : 			}
; 1887 : 		}
; 1888 : 	}

	jmp	$LN2@stbi__buil
$LN1@stbi__buil:

; 1889 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__build_fast_ac@@YAXPAFPAUstbi__huffman@@@Z ENDP	; stbi__build_fast_ac
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__build_huffman@@YAHPAUstbi__huffman@@PAH@Z
_TEXT	SEGMENT
_m$1 = -80						; size = 4
_c$2 = -68						; size = 4
_s$3 = -56						; size = 4
_code$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_h$ = 8							; size = 4
_count$ = 12						; size = 4
?stbi__build_huffman@@YAHPAUstbi__huffman@@PAH@Z PROC	; stbi__build_huffman, COMDAT

; 1823 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1824 : 	int i, j, k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 1825 : 	unsigned int code;
; 1826 : 	// build size list for each symbol (from JPEG spec)
; 1827 : 	for (i = 0; i < 16; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__buil
$LN2@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__buil:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@stbi__buil

; 1828 : 		for (j = 0; j < count[i]; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@stbi__buil
$LN5@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jge	SHORT $LN6@stbi__buil

; 1829 : 			h->size[k++] = (stbi_uc)(i + 1);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx+1280], al
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	jmp	SHORT $LN5@stbi__buil
$LN6@stbi__buil:
	jmp	SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 1830 : 	h->size[k] = 0;

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax+1280], 0

; 1831 : 
; 1832 : 	// compute actual symbols (from jpeg spec)
; 1833 : 	code = 0;

	mov	DWORD PTR _code$[ebp], 0

; 1834 : 	k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 1835 : 	for (j = 1; j <= 16; ++j) {

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN10@stbi__buil
$LN8@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@stbi__buil:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jg	$LN9@stbi__buil

; 1836 : 		// compute delta to add to code to compute symbol id
; 1837 : 		h->delta[j] = k - code;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+ecx*4+1612], eax

; 1838 : 		if (h->size[k] == j) {

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	cmp	ecx, DWORD PTR _j$[ebp]
	jne	SHORT $LN19@stbi__buil
$LN11@stbi__buil:

; 1839 : 			while (h->size[k] == j)

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	cmp	ecx, DWORD PTR _j$[ebp]
	jne	SHORT $LN12@stbi__buil

; 1840 : 				h->code[k++] = (stbi__uint16)(code++);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	dx, WORD PTR _code$[ebp]
	mov	WORD PTR [ecx+eax*2+512], dx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, 1
	mov	DWORD PTR _code$[ebp], ecx
	jmp	SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 1841 : 			if (code - 1 >= (1u << j)) return stbi__err("bad code lengths", "Corrupt JPEG");

	mov	eax, DWORD PTR _code$[ebp]
	sub	eax, 1
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	cmp	eax, edx
	jb	SHORT $LN19@stbi__buil
	push	OFFSET ??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	$LN1@stbi__buil
$LN19@stbi__buil:

; 1842 : 		}
; 1843 : 		// compute largest code + 1 for this size, preshifted as needed later
; 1844 : 		h->maxcode[j] = code << (16 - j);

	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+ecx*4+1540], eax

; 1845 : 		code <<= 1;

	mov	eax, DWORD PTR _code$[ebp]
	shl	eax, 1
	mov	DWORD PTR _code$[ebp], eax

; 1846 : 	}

	jmp	$LN8@stbi__buil
$LN9@stbi__buil:

; 1847 : 	h->maxcode[j] = 0xffffffff;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [ecx+eax*4+1540], -1

; 1848 : 
; 1849 : 	// build non-spec acceleration table; 255 is flag for not-accelerated
; 1850 : 	memset(h->fast, 255, 1 << FAST_BITS);

	push	512					; 00000200H
	push	255					; 000000ffH
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1851 : 	for (i = 0; i < k; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@stbi__buil
$LN13@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@stbi__buil:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN14@stbi__buil

; 1852 : 		int s = h->size[i];

	mov	eax, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+1280]
	mov	DWORD PTR _s$3[ebp], ecx

; 1853 : 		if (s <= FAST_BITS) {

	cmp	DWORD PTR _s$3[ebp], 9
	jg	SHORT $LN21@stbi__buil

; 1854 : 			int c = h->code[i] << (FAST_BITS - s);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+512]
	mov	ecx, 9
	sub	ecx, DWORD PTR _s$3[ebp]
	shl	edx, cl
	mov	DWORD PTR _c$2[ebp], edx

; 1855 : 			int m = 1 << (FAST_BITS - s);

	mov	ecx, 9
	sub	ecx, DWORD PTR _s$3[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _m$1[ebp], eax

; 1856 : 			for (j = 0; j < m; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN18@stbi__buil
$LN16@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN18@stbi__buil:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _m$1[ebp]
	jge	SHORT $LN21@stbi__buil

; 1857 : 				h->fast[c + j] = (stbi_uc)i;

	mov	eax, DWORD PTR _c$2[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 1858 : 			}

	jmp	SHORT $LN16@stbi__buil
$LN21@stbi__buil:

; 1859 : 		}
; 1860 : 	}

	jmp	$LN13@stbi__buil
$LN14@stbi__buil:

; 1861 : 	return 1;

	mov	eax, 1
$LN1@stbi__buil:

; 1862 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__build_huffman@@YAHPAUstbi__huffman@@PAH@Z ENDP	; stbi__build_huffman
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__convert_format16@@YAPAGPAGHHII@Z
_TEXT	SEGMENT
tv95 = -256						; size = 4
tv82 = -256						; size = 4
_dest$1 = -56						; size = 4
_src$2 = -44						; size = 4
_good$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_img_n$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?stbi__convert_format16@@YAPAGPAGHHII@Z PROC		; stbi__convert_format16, COMDAT

; 1633 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1634 : 	int i, j;
; 1635 : 	stbi__uint16* good;
; 1636 : 
; 1637 : 	if (req_comp == img_n) return data;

	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _img_n$[ebp]
	jne	SHORT $LN43@stbi__conv
	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN1@stbi__conv
$LN43@stbi__conv:

; 1638 : 	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	cmp	DWORD PTR _req_comp$[ebp], 1
	jl	SHORT $LN59@stbi__conv
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN60@stbi__conv
$LN59@stbi__conv:
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__convert_format16@@YAPAGPAGHHII@Z@4JA
	add	eax, 5
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN60@stbi__conv:

; 1639 : 
; 1640 : 	good = (stbi__uint16*)stbi__malloc(req_comp * x * y * 2);

	mov	eax, DWORD PTR _req_comp$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	shl	eax, 1
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _good$[ebp], eax

; 1641 : 	if (good == NULL) {

	cmp	DWORD PTR _good$[ebp], 0
	jne	SHORT $LN44@stbi__conv

; 1642 : 		STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1643 : 		return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__conv
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN62@stbi__conv
$LN61@stbi__conv:
	mov	DWORD PTR tv82[ebp], 0
$LN62@stbi__conv:
	mov	eax, DWORD PTR tv82[ebp]
	jmp	$LN1@stbi__conv
$LN44@stbi__conv:

; 1644 : 	}
; 1645 : 
; 1646 : 	for (j = 0; j < (int)y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jge	$LN3@stbi__conv

; 1647 : 		stbi__uint16* src = data + j * x * img_n;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _src$2[ebp], edx

; 1648 : 		stbi__uint16* dest = good + j * x * req_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _req_comp$[ebp]
	mov	ecx, DWORD PTR _good$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _dest$1[ebp], edx

; 1649 : 
; 1650 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1651 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1652 : 		// convert source image with img_n components to one with req_comp components;
; 1653 : 		// avoid switch per pixel, so use switch per scanline and massive macros
; 1654 : 		switch (STBI__COMBO(img_n, req_comp)) {

	mov	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv95[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 25			; 00000019H
	ja	$LN57@stbi__conv
	mov	ecx, DWORD PTR tv95[ebp]
	movzx	edx, BYTE PTR $LN64@stbi__conv[ecx]
	jmp	DWORD PTR $LN65@stbi__conv[edx*4]
$LN45@stbi__conv:

; 1655 : 			STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 0xffff; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN9@stbi__conv
$LN7@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN9@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN8@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [edx+eax], cx
	jmp	SHORT $LN7@stbi__conv
$LN8@stbi__conv:
	jmp	$LN5@stbi__conv
$LN46@stbi__conv:

; 1656 : 			STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@stbi__conv
$LN10@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN12@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN11@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN10@stbi__conv
$LN11@stbi__conv:
	jmp	$LN5@stbi__conv
$LN47@stbi__conv:

; 1657 : 			STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 0xffff; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN15@stbi__conv
$LN13@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN15@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN14@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, 65535				; 0000ffffH
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [eax+ecx], dx
	jmp	$LN13@stbi__conv
$LN14@stbi__conv:
	jmp	$LN5@stbi__conv
$LN48@stbi__conv:

; 1658 : 			STBI__CASE(2, 1) { dest[0] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN18@stbi__conv
$LN16@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN18@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN17@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	jmp	SHORT $LN16@stbi__conv
$LN17@stbi__conv:
	jmp	$LN5@stbi__conv
$LN49@stbi__conv:

; 1659 : 			STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN21@stbi__conv
$LN19@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN21@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN20@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN19@stbi__conv
$LN20@stbi__conv:
	jmp	$LN5@stbi__conv
$LN50@stbi__conv:

; 1660 : 			STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN24@stbi__conv
$LN22@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN24@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN23@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax
	jmp	$LN22@stbi__conv
$LN23@stbi__conv:
	jmp	$LN5@stbi__conv
$LN51@stbi__conv:

; 1661 : 			STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 0xffff; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN27@stbi__conv
$LN25@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 8
	mov	DWORD PTR _dest$1[ebp], edx
$LN27@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN26@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, 65535				; 0000ffffH
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [eax+ecx], dx
	jmp	$LN25@stbi__conv
$LN26@stbi__conv:
	jmp	$LN5@stbi__conv
$LN52@stbi__conv:

; 1662 : 			STBI__CASE(3, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN30@stbi__conv
$LN28@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN30@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN29@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y_16@@YAGHHH@Z		; stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN28@stbi__conv
$LN29@stbi__conv:
	jmp	$LN5@stbi__conv
$LN53@stbi__conv:

; 1663 : 			STBI__CASE(3, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = 0xffff; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN33@stbi__conv
$LN31@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 6
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN33@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN32@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y_16@@YAGHHH@Z		; stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [edx+eax], cx
	jmp	SHORT $LN31@stbi__conv
$LN32@stbi__conv:
	jmp	$LN5@stbi__conv
$LN54@stbi__conv:

; 1664 : 			STBI__CASE(4, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN36@stbi__conv
$LN34@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN36@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN35@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y_16@@YAGHHH@Z		; stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	jmp	SHORT $LN34@stbi__conv
$LN35@stbi__conv:
	jmp	$LN5@stbi__conv
$LN55@stbi__conv:

; 1665 : 			STBI__CASE(4, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = src[3]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN39@stbi__conv
$LN37@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN39@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN38@stbi__conv
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y_16@@YAGHHH@Z		; stbi__compute_y_16
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx
	jmp	$LN37@stbi__conv
$LN38@stbi__conv:
	jmp	$LN5@stbi__conv
$LN56@stbi__conv:

; 1666 : 			STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN42@stbi__conv
$LN40@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 6
	mov	DWORD PTR _dest$1[ebp], edx
$LN42@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN41@stbi__conv
	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax
	jmp	SHORT $LN40@stbi__conv
$LN41@stbi__conv:
	jmp	SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1667 : 		default: STBI_ASSERT(0);

	xor	eax, eax
	jne	SHORT $LN5@stbi__conv
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__convert_format16@@YAPAGPAGHHII@Z@4JA
	add	ecx, 34					; 00000022H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_13COJANIEC@?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@stbi__conv:

; 1668 : 		}
; 1669 : #undef STBI__CASE
; 1670 : 	}

	jmp	$LN2@stbi__conv
$LN3@stbi__conv:

; 1671 : 
; 1672 : 	STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1673 : 	return good;

	mov	eax, DWORD PTR _good$[ebp]
$LN1@stbi__conv:

; 1674 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN65@stbi__conv:
	DD	$LN45@stbi__conv
	DD	$LN46@stbi__conv
	DD	$LN47@stbi__conv
	DD	$LN48@stbi__conv
	DD	$LN49@stbi__conv
	DD	$LN50@stbi__conv
	DD	$LN52@stbi__conv
	DD	$LN53@stbi__conv
	DD	$LN51@stbi__conv
	DD	$LN54@stbi__conv
	DD	$LN55@stbi__conv
	DD	$LN56@stbi__conv
	DD	$LN57@stbi__conv
$LN64@stbi__conv:
	DB	0
	DB	1
	DB	2
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	4
	DB	5
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	6
	DB	7
	DB	12					; 0000000cH
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
?stbi__convert_format16@@YAPAGPAGHHII@Z ENDP		; stbi__convert_format16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__compute_y_16@@YAGHHH@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?stbi__compute_y_16@@YAGHHH@Z PROC			; stbi__compute_y_16, COMDAT

; 1628 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1629 : 	return (stbi__uint16)(((r * 77) + (g * 150) + (29 * b)) >> 8);

	imul	eax, DWORD PTR _r$[ebp], 77
	imul	ecx, DWORD PTR _g$[ebp], 150
	add	eax, ecx
	imul	edx, DWORD PTR _b$[ebp], 29
	add	eax, edx
	sar	eax, 8

; 1630 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__compute_y_16@@YAGHHH@Z ENDP			; stbi__compute_y_16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__convert_format@@YAPAEPAEHHII@Z
_TEXT	SEGMENT
tv93 = -256						; size = 4
tv82 = -256						; size = 4
_dest$1 = -56						; size = 4
_src$2 = -44						; size = 4
_good$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_img_n$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?stbi__convert_format@@YAPAEPAEHHII@Z PROC		; stbi__convert_format, COMDAT

; 1584 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1585 : 	int i, j;
; 1586 : 	unsigned char* good;
; 1587 : 
; 1588 : 	if (req_comp == img_n) return data;

	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _img_n$[ebp]
	jne	SHORT $LN43@stbi__conv
	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN1@stbi__conv
$LN43@stbi__conv:

; 1589 : 	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

	cmp	DWORD PTR _req_comp$[ebp], 1
	jl	SHORT $LN59@stbi__conv
	cmp	DWORD PTR _req_comp$[ebp], 4
	jle	SHORT $LN60@stbi__conv
$LN59@stbi__conv:
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__convert_format@@YAPAEPAEHHII@Z@4JA
	add	eax, 5
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN60@stbi__conv:

; 1590 : 
; 1591 : 	good = (unsigned char*)stbi__malloc_mad3(req_comp, x, y, 0);

	push	0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _good$[ebp], eax

; 1592 : 	if (good == NULL) {

	cmp	DWORD PTR _good$[ebp], 0
	jne	SHORT $LN44@stbi__conv

; 1593 : 		STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1594 : 		return stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__conv
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN62@stbi__conv
$LN61@stbi__conv:
	mov	DWORD PTR tv82[ebp], 0
$LN62@stbi__conv:
	mov	eax, DWORD PTR tv82[ebp]
	jmp	$LN1@stbi__conv
$LN44@stbi__conv:

; 1595 : 	}
; 1596 : 
; 1597 : 	for (j = 0; j < (int)y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@stbi__conv:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jge	$LN3@stbi__conv

; 1598 : 		unsigned char* src = data + j * x * img_n;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _img_n$[ebp]
	add	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _src$2[ebp], eax

; 1599 : 		unsigned char* dest = good + j * x * req_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _req_comp$[ebp]
	add	eax, DWORD PTR _good$[ebp]
	mov	DWORD PTR _dest$1[ebp], eax

; 1600 : 
; 1601 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1602 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1603 : 		// convert source image with img_n components to one with req_comp components;
; 1604 : 		// avoid switch per pixel, so use switch per scanline and massive macros
; 1605 : 		switch (STBI__COMBO(img_n, req_comp)) {

	mov	eax, DWORD PTR _img_n$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv93[ebp], edx
	mov	eax, DWORD PTR tv93[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR tv93[ebp], eax
	cmp	DWORD PTR tv93[ebp], 25			; 00000019H
	ja	$LN57@stbi__conv
	mov	ecx, DWORD PTR tv93[ebp]
	movzx	edx, BYTE PTR $LN64@stbi__conv[ecx]
	jmp	DWORD PTR $LN65@stbi__conv[edx*4]
$LN45@stbi__conv:

; 1606 : 			STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 255; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN9@stbi__conv
$LN7@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN9@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN8@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH
	jmp	SHORT $LN7@stbi__conv
$LN8@stbi__conv:
	jmp	$LN5@stbi__conv
$LN46@stbi__conv:

; 1607 : 			STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@stbi__conv
$LN10@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN12@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN11@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN10@stbi__conv
$LN11@stbi__conv:
	jmp	$LN5@stbi__conv
$LN47@stbi__conv:

; 1608 : 			STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 255; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN15@stbi__conv
$LN13@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN15@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN14@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH
	jmp	$LN13@stbi__conv
$LN14@stbi__conv:
	jmp	$LN5@stbi__conv
$LN48@stbi__conv:

; 1609 : 			STBI__CASE(2, 1) { dest[0] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN18@stbi__conv
$LN16@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN18@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN17@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	jmp	SHORT $LN16@stbi__conv
$LN17@stbi__conv:
	jmp	$LN5@stbi__conv
$LN49@stbi__conv:

; 1610 : 			STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN21@stbi__conv
$LN19@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN21@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN20@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN19@stbi__conv
$LN20@stbi__conv:
	jmp	$LN5@stbi__conv
$LN50@stbi__conv:

; 1611 : 			STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN24@stbi__conv
$LN22@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN24@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN23@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _dest$1[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	jmp	$LN22@stbi__conv
$LN23@stbi__conv:
	jmp	$LN5@stbi__conv
$LN51@stbi__conv:

; 1612 : 			STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 255; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN27@stbi__conv
$LN25@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 4
	mov	DWORD PTR _dest$1[ebp], edx
$LN27@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN26@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH
	jmp	$LN25@stbi__conv
$LN26@stbi__conv:
	jmp	$LN5@stbi__conv
$LN52@stbi__conv:

; 1613 : 			STBI__CASE(3, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN30@stbi__conv
$LN28@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN30@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN29@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN28@stbi__conv
$LN29@stbi__conv:
	jmp	$LN5@stbi__conv
$LN53@stbi__conv:

; 1614 : 			STBI__CASE(3, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = 255; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN33@stbi__conv
$LN31@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 3
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN33@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN32@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH
	jmp	SHORT $LN31@stbi__conv
$LN32@stbi__conv:
	jmp	$LN5@stbi__conv
$LN54@stbi__conv:

; 1615 : 			STBI__CASE(4, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN36@stbi__conv
$LN34@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$1[ebp], edx
$LN36@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN35@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	jmp	SHORT $LN34@stbi__conv
$LN35@stbi__conv:
	jmp	$LN5@stbi__conv
$LN55@stbi__conv:

; 1616 : 			STBI__CASE(4, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = src[3]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN39@stbi__conv
$LN37@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 2
	mov	DWORD PTR _dest$1[ebp], edx
$LN39@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN38@stbi__conv
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$1[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
	jmp	$LN37@stbi__conv
$LN38@stbi__conv:
	jmp	$LN5@stbi__conv
$LN56@stbi__conv:

; 1617 : 			STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN42@stbi__conv
$LN40@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _src$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _src$2[ebp], ecx
	mov	edx, DWORD PTR _dest$1[ebp]
	add	edx, 3
	mov	DWORD PTR _dest$1[ebp], edx
$LN42@stbi__conv:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN41@stbi__conv
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _dest$1[ebp]
	mov	esi, DWORD PTR _src$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	jmp	SHORT $LN40@stbi__conv
$LN41@stbi__conv:
	jmp	SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1618 : 		default: STBI_ASSERT(0);

	xor	eax, eax
	jne	SHORT $LN5@stbi__conv
	mov	ecx, DWORD PTR ?__LINE__Var@?0??stbi__convert_format@@YAPAEPAEHHII@Z@4JA
	add	ecx, 34					; 00000022H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_13COJANIEC@?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@stbi__conv:

; 1619 : 		}
; 1620 : #undef STBI__CASE
; 1621 : 	}

	jmp	$LN2@stbi__conv
$LN3@stbi__conv:

; 1622 : 
; 1623 : 	STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1624 : 	return good;

	mov	eax, DWORD PTR _good$[ebp]
$LN1@stbi__conv:

; 1625 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@stbi__conv:
	DD	$LN45@stbi__conv
	DD	$LN46@stbi__conv
	DD	$LN47@stbi__conv
	DD	$LN48@stbi__conv
	DD	$LN49@stbi__conv
	DD	$LN50@stbi__conv
	DD	$LN52@stbi__conv
	DD	$LN53@stbi__conv
	DD	$LN51@stbi__conv
	DD	$LN54@stbi__conv
	DD	$LN55@stbi__conv
	DD	$LN56@stbi__conv
	DD	$LN57@stbi__conv
$LN64@stbi__conv:
	DB	0
	DB	1
	DB	2
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	4
	DB	5
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	6
	DB	7
	DB	12					; 0000000cH
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
?stbi__convert_format@@YAPAEPAEHHII@Z ENDP		; stbi__convert_format
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__compute_y@@YAEHHH@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?stbi__compute_y@@YAEHHH@Z PROC				; stbi__compute_y, COMDAT

; 1579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1580 : 	return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);

	imul	eax, DWORD PTR _r$[ebp], 77
	imul	ecx, DWORD PTR _g$[ebp], 150
	add	eax, ecx
	imul	edx, DWORD PTR _b$[ebp], 29
	add	eax, edx
	sar	eax, 8

; 1581 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__compute_y@@YAEHHH@Z ENDP				; stbi__compute_y
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get32le@@YAIPAUstbi__context@@@Z
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__get32le@@YAIPAUstbi__context@@@Z PROC		; stbi__get32le, COMDAT

; 1558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1559 : 	stbi__uint32 z = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _z$[ebp], eax

; 1560 : 	return z + (stbi__get16le(s) << 16);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	shl	eax, 16					; 00000010H
	add	eax, DWORD PTR _z$[ebp]

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get32le@@YAIPAUstbi__context@@@Z ENDP		; stbi__get32le
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get16le@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__get16le@@YAHPAUstbi__context@@@Z PROC		; stbi__get16le, COMDAT

; 1550 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1551 : 	int z = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _z$[ebp], ecx

; 1552 : 	return z + (stbi__get8(s) << 8);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	eax, al
	shl	eax, 8
	add	eax, DWORD PTR _z$[ebp]

; 1553 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get16le@@YAHPAUstbi__context@@@Z ENDP		; stbi__get16le
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get32be@@YAIPAUstbi__context@@@Z
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__get32be@@YAIPAUstbi__context@@@Z PROC		; stbi__get32be, COMDAT

; 1541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1542 : 	stbi__uint32 z = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _z$[ebp], eax

; 1543 : 	return (z << 16) + stbi__get16be(s);

	mov	esi, DWORD PTR _z$[ebp]
	shl	esi, 16					; 00000010H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	add	eax, esi

; 1544 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get32be@@YAIPAUstbi__context@@@Z ENDP		; stbi__get32be
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get16be@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_z$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__get16be@@YAHPAUstbi__context@@@Z PROC		; stbi__get16be, COMDAT

; 1535 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1536 : 	int z = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _z$[ebp], ecx

; 1537 : 	return (z << 8) + stbi__get8(s);

	mov	esi, DWORD PTR _z$[ebp]
	shl	esi, 8
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	add	esi, ecx
	mov	eax, esi

; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get16be@@YAHPAUstbi__context@@@Z ENDP		; stbi__get16be
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__getn@@YAHPAUstbi__context@@PAEH@Z
_TEXT	SEGMENT
tv86 = -232						; size = 4
_count$1 = -32						; size = 4
_res$2 = -20						; size = 4
_blen$3 = -8						; size = 4
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_n$ = 16						; size = 4
?stbi__getn@@YAHPAUstbi__context@@PAEH@Z PROC		; stbi__getn, COMDAT

; 1510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1511 : 	if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN2@stbi__getn

; 1512 : 		int blen = (int)(s->img_buffer_end - s->img_buffer);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+172]
	sub	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR _blen$3[ebp], edx

; 1513 : 		if (blen < n) {

	mov	eax, DWORD PTR _blen$3[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN2@stbi__getn

; 1514 : 			int res, count;
; 1515 : 
; 1516 : 			memcpy(buffer, s->img_buffer, blen);

	mov	eax, DWORD PTR _blen$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1517 : 
; 1518 : 			count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$3[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _blen$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _count$1[ebp], eax

; 1519 : 			res = (count == (n - blen));

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$3[ebp]
	cmp	DWORD PTR _count$1[ebp], eax
	jne	SHORT $LN7@stbi__getn
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN8@stbi__getn
$LN7@stbi__getn:
	mov	DWORD PTR tv86[ebp], 0
$LN8@stbi__getn:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _res$2[ebp], ecx

; 1520 : 			s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1521 : 			return res;

	mov	eax, DWORD PTR _res$2[ebp]
	jmp	SHORT $LN1@stbi__getn
$LN2@stbi__getn:

; 1522 : 		}
; 1523 : 	}
; 1524 : 
; 1525 : 	if (s->img_buffer + n <= s->img_buffer_end) {

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	ecx, DWORD PTR [edx+172]
	ja	SHORT $LN4@stbi__getn

; 1526 : 		memcpy(buffer, s->img_buffer, n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1527 : 		s->img_buffer += n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx

; 1528 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__getn

; 1529 : 	}

	jmp	SHORT $LN1@stbi__getn
$LN4@stbi__getn:

; 1530 : 	else
; 1531 : 		return 0;

	xor	eax, eax
$LN1@stbi__getn:

; 1532 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ENDP		; stbi__getn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__skip@@YAXPAUstbi__context@@H@Z
_TEXT	SEGMENT
_blen$1 = -8						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
?stbi__skip@@YAXPAUstbi__context@@H@Z PROC		; stbi__skip, COMDAT

; 1493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1494 : 	if (n < 0) {

	cmp	DWORD PTR _n$[ebp], 0
	jge	SHORT $LN2@stbi__skip

; 1495 : 		s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1496 : 		return;

	jmp	SHORT $LN1@stbi__skip
$LN2@stbi__skip:

; 1497 : 	}
; 1498 : 	if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@stbi__skip

; 1499 : 		int blen = (int)(s->img_buffer_end - s->img_buffer);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+172]
	sub	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR _blen$1[ebp], edx

; 1500 : 		if (blen < n) {

	mov	eax, DWORD PTR _blen$1[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN3@stbi__skip

; 1501 : 			s->img_buffer = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+168], edx

; 1502 : 			(s->io.skip)(s->io_user_data, n - blen);

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _blen$1[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1503 : 			return;

	jmp	SHORT $LN1@stbi__skip
$LN3@stbi__skip:

; 1504 : 		}
; 1505 : 	}
; 1506 : 	s->img_buffer += n;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
$LN1@stbi__skip:

; 1507 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__skip@@YAXPAUstbi__context@@H@Z ENDP		; stbi__skip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__at_eof@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
tv78 = -196						; size = 4
_s$ = 8							; size = 4
?stbi__at_eof@@YAHPAUstbi__context@@@Z PROC		; stbi__at_eof, COMDAT

; 1481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1482 : 	if (s->io.read) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@stbi__at_e

; 1483 : 		if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@stbi__at_e
	xor	eax, eax
	jmp	SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1484 : 		// if feof() is true, check if buffer = end
; 1485 : 		// special case: we've only got the special 0 character at the end
; 1486 : 		if (s->read_from_callbacks == 0) return 1;

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@stbi__at_e
	mov	eax, 1
	jmp	SHORT $LN1@stbi__at_e
$LN2@stbi__at_e:

; 1487 : 	}
; 1488 : 
; 1489 : 	return s->img_buffer >= s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+168]
	cmp	edx, DWORD PTR [ecx+172]
	jb	SHORT $LN6@stbi__at_e
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
	mov	DWORD PTR tv78[ebp], 0
$LN7@stbi__at_e:
	mov	eax, DWORD PTR tv78[ebp]
$LN1@stbi__at_e:

; 1490 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__at_eof@@YAHPAUstbi__context@@@Z ENDP		; stbi__at_eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__get8@@YAEPAUstbi__context@@@Z
_TEXT	SEGMENT
tv81 = -193						; size = 1
tv72 = -193						; size = 1
_s$ = 8							; size = 4
?stbi__get8@@YAEPAUstbi__context@@@Z PROC		; stbi__get8, COMDAT

; 1470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1471 : 	if (s->img_buffer < s->img_buffer_end)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+168]
	cmp	edx, DWORD PTR [ecx+172]
	jae	SHORT $LN2@stbi__get8

; 1472 : 		return *s->img_buffer++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	al, BYTE PTR tv72[ebp]
	jmp	SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1473 : 	if (s->read_from_callbacks) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@stbi__get8

; 1474 : 		stbi__refill_buffer(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__refill_buffer@@YAXPAUstbi__context@@@Z ; stbi__refill_buffer
	add	esp, 4

; 1475 : 		return *s->img_buffer++;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv81[ebp], dl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	al, BYTE PTR tv81[ebp]
	jmp	SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1476 : 	}
; 1477 : 	return 0;

	xor	al, al
$LN1@stbi__get8:

; 1478 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__get8@@YAEPAUstbi__context@@@Z ENDP		; stbi__get8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z
_TEXT	SEGMENT
tv129 = -244						; size = 4
tv89 = -244						; size = 4
_hdr_data$1 = -44					; size = 4
_ri$2 = -32						; size = 12
_data$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z PROC	; stbi__loadf_main, COMDAT

; 1316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1317 : 	unsigned char* data;
; 1318 : #ifndef STBI_NO_HDR
; 1319 : 	if (stbi__hdr_test(s)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__load

; 1320 : 		stbi__result_info ri;
; 1321 : 		float* hdr_data = stbi__hdr_load(s, x, y, comp, req_comp, &ri);

	lea	eax, DWORD PTR _ri$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__hdr_load@@YAPAMPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__hdr_load
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hdr_data$1[ebp], eax

; 1322 : 		if (hdr_data)

	cmp	DWORD PTR _hdr_data$1[ebp], 0
	je	SHORT $LN3@stbi__load

; 1323 : 			stbi__float_postprocess(hdr_data, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hdr_data$1[ebp]
	push	ecx
	call	?stbi__float_postprocess@@YAXPAMPAH11H@Z ; stbi__float_postprocess
	add	esp, 20					; 00000014H
$LN3@stbi__load:

; 1324 : 		return hdr_data;

	mov	eax, DWORD PTR _hdr_data$1[ebp]
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 1325 : 	}
; 1326 : #endif
; 1327 : 	data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _data$[ebp], eax

; 1328 : 	if (data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN4@stbi__load

; 1329 : 		return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN7@stbi__load
$LN6@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
$LN7@stbi__load:
	mov	eax, DWORD PTR tv89[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	?stbi__ldr_to_hdr@@YAPAMPAEHHH@Z	; stbi__ldr_to_hdr
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@stbi__load
$LN4@stbi__load:

; 1330 : 	return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@stbi__load
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN9@stbi__load
$LN8@stbi__load:
	mov	DWORD PTR tv129[ebp], 0
$LN9@stbi__load:
	mov	eax, DWORD PTR tv129[ebp]
$LN1@stbi__load:

; 1331 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@stbi__load:
	DD	1
	DD	$LN11@stbi__load
$LN11@stbi__load:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN10@stbi__load
$LN10@stbi__load:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z ENDP	; stbi__loadf_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__fopen@@YAPAU_iobuf@@PBD0@Z
_TEXT	SEGMENT
_f$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
?stbi__fopen@@YAPAU_iobuf@@PBD0@Z PROC			; stbi__fopen, COMDAT

; 1193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1194 : 	FILE* f;
; 1195 : #if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
; 1196 : 	wchar_t wMode[64];
; 1197 : 	wchar_t wFilename[1024];
; 1198 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
; 1199 : 		return 0;
; 1200 : 
; 1201 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
; 1202 : 		return 0;
; 1203 : 
; 1204 : #if _MSC_VER >= 1400
; 1205 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1206 : 		f = 0;
; 1207 : #else
; 1208 : 	f = _wfopen(wFilename, wMode);
; 1209 : #endif
; 1210 : 
; 1211 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1212 : 	if (0 != fopen_s(&f, filename, mode))

	mov	esi, esp
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f$[ebp]
	push	edx
	call	DWORD PTR __imp__fopen_s
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@stbi__fope

; 1213 : 		f = 0;

	mov	DWORD PTR _f$[ebp], 0
$LN2@stbi__fope:

; 1214 : #else
; 1215 : 	f = fopen(filename, mode);
; 1216 : #endif
; 1217 : 	return f;

	mov	eax, DWORD PTR _f$[ebp]

; 1218 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi__fope
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@stbi__fope:
	DD	1
	DD	$LN5@stbi__fope
$LN5@stbi__fope:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN4@stbi__fope
$LN4@stbi__fope:
	DB	102					; 00000066H
	DB	0
?stbi__fopen@@YAPAU_iobuf@@PBD0@Z ENDP			; stbi__fopen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__float_postprocess@@YAXPAMPAH11H@Z
_TEXT	SEGMENT
tv67 = -208						; size = 4
_channels$1 = -8					; size = 4
_result$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi__float_postprocess@@YAXPAMPAH11H@Z PROC		; stbi__float_postprocess, COMDAT

; 1170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1171 : 	if (stbi__vertically_flip_on_load && result != NULL) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	SHORT $LN1@stbi__floa
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN1@stbi__floa

; 1172 : 		int channels = req_comp ? req_comp : *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN4@stbi__floa
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN5@stbi__floa
$LN4@stbi__floa:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv67[ebp], edx
$LN5@stbi__floa:
	mov	eax, DWORD PTR tv67[ebp]
	mov	DWORD PTR _channels$1[ebp], eax

; 1173 : 		stbi__vertical_flip(result, *x, *y, channels * sizeof(float));

	mov	eax, DWORD PTR _channels$1[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__vertical_flip@@YAXPAXHHH@Z	; stbi__vertical_flip
	add	esp, 16					; 00000010H
$LN1@stbi__floa:

; 1174 : 	}
; 1175 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__float_postprocess@@YAXPAMPAH11H@Z ENDP		; stbi__float_postprocess
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z
_TEXT	SEGMENT
tv89 = -244						; size = 4
tv82 = -244						; size = 4
_channels$1 = -44					; size = 4
_result$ = -32						; size = 4
_ri$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z PROC ; stbi__load_and_postprocess_16bit, COMDAT

; 1144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1145 : 	stbi__result_info ri;
; 1146 : 	void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

	push	16					; 00000010H
	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__load_main@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z ; stbi__load_main
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _result$[ebp], eax

; 1147 : 
; 1148 : 	if (result == NULL)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@stbi__load

; 1149 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 1150 : 
; 1151 : 	if (ri.bits_per_channel != 16) {

	cmp	DWORD PTR _ri$[ebp], 16			; 00000010H
	je	SHORT $LN3@stbi__load

; 1152 : 		STBI_ASSERT(ri.bits_per_channel == 8);

	cmp	DWORD PTR _ri$[ebp], 8
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z@4JA
	add	eax, 8
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DC@NDPEGMEG@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@stbi__load:

; 1153 : 		result = stbi__convert_8_to_16((stbi_uc*)result, *x, *y, req_comp == 0 ? *comp : req_comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN8@stbi__load
$LN7@stbi__load:
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN8@stbi__load:
	mov	eax, DWORD PTR tv82[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__convert_8_to_16@@YAPAGPAEHHH@Z	; stbi__convert_8_to_16
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 1154 : 		ri.bits_per_channel = 16;

	mov	DWORD PTR _ri$[ebp], 16			; 00000010H
$LN3@stbi__load:

; 1155 : 	}
; 1156 : 
; 1157 : 	// @TODO: move stbi__convert_format16 to here
; 1158 : 	// @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1159 : 
; 1160 : 	if (stbi__vertically_flip_on_load) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	SHORT $LN4@stbi__load

; 1161 : 		int channels = req_comp ? req_comp : *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN9@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@stbi__load
$LN9@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
$LN10@stbi__load:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _channels$1[ebp], eax

; 1162 : 		stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

	mov	eax, DWORD PTR _channels$1[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__vertical_flip@@YAXPAXHHH@Z	; stbi__vertical_flip
	add	esp, 16					; 00000010H
$LN4@stbi__load:

; 1163 : 	}
; 1164 : 
; 1165 : 	return (stbi__uint16*)result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi__load:

; 1166 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@stbi__load:
	DD	1
	DD	$LN12@stbi__load
$LN12@stbi__load:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN11@stbi__load
$LN11@stbi__load:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z ENDP ; stbi__load_and_postprocess_16bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z
_TEXT	SEGMENT
tv89 = -244						; size = 4
tv82 = -244						; size = 4
_channels$1 = -44					; size = 4
_result$ = -32						; size = 4
_ri$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z PROC ; stbi__load_and_postprocess_8bit, COMDAT

; 1120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1121 : 	stbi__result_info ri;
; 1122 : 	void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

	push	8
	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__load_main@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z ; stbi__load_main
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _result$[ebp], eax

; 1123 : 
; 1124 : 	if (result == NULL)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@stbi__load

; 1125 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 1126 : 
; 1127 : 	if (ri.bits_per_channel != 8) {

	cmp	DWORD PTR _ri$[ebp], 8
	je	SHORT $LN3@stbi__load

; 1128 : 		STBI_ASSERT(ri.bits_per_channel == 16);

	cmp	DWORD PTR _ri$[ebp], 16			; 00000010H
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z@4JA
	add	eax, 8
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1DE@BAGIOALB@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@stbi__load:

; 1129 : 		result = stbi__convert_16_to_8((stbi__uint16*)result, *x, *y, req_comp == 0 ? *comp : req_comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN8@stbi__load
$LN7@stbi__load:
	mov	edx, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN8@stbi__load:
	mov	eax, DWORD PTR tv82[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__convert_16_to_8@@YAPAEPAGHHH@Z	; stbi__convert_16_to_8
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 1130 : 		ri.bits_per_channel = 8;

	mov	DWORD PTR _ri$[ebp], 8
$LN3@stbi__load:

; 1131 : 	}
; 1132 : 
; 1133 : 	// @TODO: move stbi__convert_format to here
; 1134 : 
; 1135 : 	if (stbi__vertically_flip_on_load) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	SHORT $LN4@stbi__load

; 1136 : 		int channels = req_comp ? req_comp : *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN9@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@stbi__load
$LN9@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv89[ebp], edx
$LN10@stbi__load:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _channels$1[ebp], eax

; 1137 : 		stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

	mov	eax, DWORD PTR _channels$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__vertical_flip@@YAXPAXHHH@Z	; stbi__vertical_flip
	add	esp, 16					; 00000010H
$LN4@stbi__load:

; 1138 : 	}
; 1139 : 
; 1140 : 	return (unsigned char*)result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi__load:

; 1141 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@stbi__load:
	DD	1
	DD	$LN12@stbi__load
$LN12@stbi__load:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN11@stbi__load
$LN11@stbi__load:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z ENDP ; stbi__load_and_postprocess_8bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__vertical_flip_slices@@YAXPAXHHHH@Z
_TEXT	SEGMENT
_bytes$ = -32						; size = 4
_slice_size$ = -20					; size = 4
_slice$ = -8						; size = 4
_image$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_z$ = 20						; size = 4
_bytes_per_pixel$ = 24					; size = 4
?stbi__vertical_flip_slices@@YAXPAXHHHH@Z PROC		; stbi__vertical_flip_slices, COMDAT

; 1107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1108 : 	int slice;
; 1109 : 	int slice_size = w * h * bytes_per_pixel;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _bytes_per_pixel$[ebp]
	mov	DWORD PTR _slice_size$[ebp], eax

; 1110 : 
; 1111 : 	stbi_uc* bytes = (stbi_uc*)image;

	mov	eax, DWORD PTR _image$[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 1112 : 	for (slice = 0; slice < z; ++slice) {

	mov	DWORD PTR _slice$[ebp], 0
	jmp	SHORT $LN4@stbi__vert
$LN2@stbi__vert:
	mov	eax, DWORD PTR _slice$[ebp]
	add	eax, 1
	mov	DWORD PTR _slice$[ebp], eax
$LN4@stbi__vert:
	mov	eax, DWORD PTR _slice$[ebp]
	cmp	eax, DWORD PTR _z$[ebp]
	jge	SHORT $LN1@stbi__vert

; 1113 : 		stbi__vertical_flip(bytes, w, h, bytes_per_pixel);

	mov	eax, DWORD PTR _bytes_per_pixel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?stbi__vertical_flip@@YAXPAXHHH@Z	; stbi__vertical_flip
	add	esp, 16					; 00000010H

; 1114 : 		bytes += slice_size;

	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, DWORD PTR _slice_size$[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 1115 : 	}

	jmp	SHORT $LN2@stbi__vert
$LN1@stbi__vert:

; 1116 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__vertical_flip_slices@@YAXPAXHHHH@Z ENDP		; stbi__vertical_flip_slices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__vertical_flip@@YAXPAXHHH@Z
_TEXT	SEGMENT
tv76 = -3108						; size = 4
_bytes_copy$1 = -2140					; size = 4
_bytes_left$2 = -2128					; size = 4
_row1$3 = -2116						; size = 4
_row0$4 = -2104						; size = 4
_bytes$ = -2092						; size = 4
_temp$ = -2080						; size = 2048
_bytes_per_row$ = -24					; size = 4
_row$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_image$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_bytes_per_pixel$ = 20					; size = 4
?stbi__vertical_flip@@YAXPAXHHH@Z PROC			; stbi__vertical_flip, COMDAT

; 1082 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3108				; 00000c24H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-3108]
	mov	ecx, 777				; 00000309H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1083 : 	int row;
; 1084 : 	size_t bytes_per_row = (size_t)w * bytes_per_pixel;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _bytes_per_pixel$[ebp]
	mov	DWORD PTR _bytes_per_row$[ebp], eax

; 1085 : 	stbi_uc temp[2048];
; 1086 : 	stbi_uc* bytes = (stbi_uc*)image;

	mov	eax, DWORD PTR _image$[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 1087 : 
; 1088 : 	for (row = 0; row < (h >> 1); row++) {

	mov	DWORD PTR _row$[ebp], 0
	jmp	SHORT $LN4@stbi__vert
$LN2@stbi__vert:
	mov	eax, DWORD PTR _row$[ebp]
	add	eax, 1
	mov	DWORD PTR _row$[ebp], eax
$LN4@stbi__vert:
	mov	eax, DWORD PTR _h$[ebp]
	sar	eax, 1
	cmp	DWORD PTR _row$[ebp], eax
	jge	$LN1@stbi__vert

; 1089 : 		stbi_uc* row0 = bytes + row * bytes_per_row;

	mov	eax, DWORD PTR _row$[ebp]
	imul	eax, DWORD PTR _bytes_per_row$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _row0$4[ebp], eax

; 1090 : 		stbi_uc* row1 = bytes + (h - row - 1) * bytes_per_row;

	mov	eax, DWORD PTR _h$[ebp]
	sub	eax, DWORD PTR _row$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _bytes_per_row$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _row1$3[ebp], eax

; 1091 : 		// swap row0 with row1
; 1092 : 		size_t bytes_left = bytes_per_row;

	mov	eax, DWORD PTR _bytes_per_row$[ebp]
	mov	DWORD PTR _bytes_left$2[ebp], eax
$LN5@stbi__vert:

; 1093 : 		while (bytes_left) {

	cmp	DWORD PTR _bytes_left$2[ebp], 0
	je	$LN6@stbi__vert

; 1094 : 			size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

	cmp	DWORD PTR _bytes_left$2[ebp], 2048	; 00000800H
	jae	SHORT $LN8@stbi__vert
	mov	eax, DWORD PTR _bytes_left$2[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN9@stbi__vert
$LN8@stbi__vert:
	mov	DWORD PTR tv76[ebp], 2048		; 00000800H
$LN9@stbi__vert:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _bytes_copy$1[ebp], ecx

; 1095 : 			memcpy(temp, row0, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _row0$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1096 : 			memcpy(row0, row1, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _row1$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _row0$4[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1097 : 			memcpy(row1, temp, bytes_copy);

	mov	eax, DWORD PTR _bytes_copy$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _row1$3[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1098 : 			row0 += bytes_copy;

	mov	eax, DWORD PTR _row0$4[ebp]
	add	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _row0$4[ebp], eax

; 1099 : 			row1 += bytes_copy;

	mov	eax, DWORD PTR _row1$3[ebp]
	add	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _row1$3[ebp], eax

; 1100 : 			bytes_left -= bytes_copy;

	mov	eax, DWORD PTR _bytes_left$2[ebp]
	sub	eax, DWORD PTR _bytes_copy$1[ebp]
	mov	DWORD PTR _bytes_left$2[ebp], eax

; 1101 : 		}

	jmp	$LN5@stbi__vert
$LN6@stbi__vert:

; 1102 : 	}

	jmp	$LN2@stbi__vert
$LN1@stbi__vert:

; 1103 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@stbi__vert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 3108				; 00000c24H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@stbi__vert:
	DD	1
	DD	$LN11@stbi__vert
$LN11@stbi__vert:
	DD	-2080					; fffff7e0H
	DD	2048					; 00000800H
	DD	$LN10@stbi__vert
$LN10@stbi__vert:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?stbi__vertical_flip@@YAXPAXHHH@Z ENDP			; stbi__vertical_flip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__convert_8_to_16@@YAPAGPAEHHH@Z
_TEXT	SEGMENT
tv73 = -232						; size = 4
_enlarged$ = -32					; size = 4
_img_len$ = -20						; size = 4
_i$ = -8						; size = 4
_orig$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_channels$ = 20						; size = 4
?stbi__convert_8_to_16@@YAPAGPAEHHH@Z PROC		; stbi__convert_8_to_16, COMDAT

; 1066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1067 : 	int i;
; 1068 : 	int img_len = w * h * channels;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _channels$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 1069 : 	stbi__uint16* enlarged;
; 1070 : 
; 1071 : 	enlarged = (stbi__uint16*)stbi__malloc(img_len * 2);

	mov	eax, DWORD PTR _img_len$[ebp]
	shl	eax, 1
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _enlarged$[ebp], eax

; 1072 : 	if (enlarged == NULL) return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _enlarged$[ebp], 0
	jne	SHORT $LN5@stbi__conv
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__conv
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	DWORD PTR tv73[ebp], 0
$LN8@stbi__conv:
	mov	eax, DWORD PTR tv73[ebp]
	jmp	SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1073 : 
; 1074 : 	for (i = 0; i < img_len; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jge	SHORT $LN3@stbi__conv

; 1075 : 		enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

	mov	eax, DWORD PTR _orig$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	mov	edx, DWORD PTR _orig$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _enlarged$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	jmp	SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1076 : 
; 1077 : 	STBI_FREE(orig);

	mov	esi, esp
	mov	eax, DWORD PTR _orig$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1078 : 	return enlarged;

	mov	eax, DWORD PTR _enlarged$[ebp]
$LN1@stbi__conv:

; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__convert_8_to_16@@YAPAGPAEHHH@Z ENDP		; stbi__convert_8_to_16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__convert_16_to_8@@YAPAEPAGHHH@Z
_TEXT	SEGMENT
tv72 = -232						; size = 4
_reduced$ = -32						; size = 4
_img_len$ = -20						; size = 4
_i$ = -8						; size = 4
_orig$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_channels$ = 20						; size = 4
?stbi__convert_16_to_8@@YAPAEPAGHHH@Z PROC		; stbi__convert_16_to_8, COMDAT

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1051 : 	int i;
; 1052 : 	int img_len = w * h * channels;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _channels$[ebp]
	mov	DWORD PTR _img_len$[ebp], eax

; 1053 : 	stbi_uc* reduced;
; 1054 : 
; 1055 : 	reduced = (stbi_uc*)stbi__malloc(img_len);

	mov	eax, DWORD PTR _img_len$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _reduced$[ebp], eax

; 1056 : 	if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _reduced$[ebp], 0
	jne	SHORT $LN5@stbi__conv
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__conv
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN8@stbi__conv
$LN7@stbi__conv:
	mov	DWORD PTR tv72[ebp], 0
$LN8@stbi__conv:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1057 : 
; 1058 : 	for (i = 0; i < img_len; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__conv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _img_len$[ebp]
	jge	SHORT $LN3@stbi__conv

; 1059 : 		reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _orig$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	sar	edx, 8
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _reduced$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1060 : 
; 1061 : 	STBI_FREE(orig);

	mov	esi, esp
	mov	eax, DWORD PTR _orig$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1062 : 	return reduced;

	mov	eax, DWORD PTR _reduced$[ebp]
$LN1@stbi__conv:

; 1063 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__convert_16_to_8@@YAPAEPAGHHH@Z ENDP		; stbi__convert_16_to_8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__load_main@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z
_TEXT	SEGMENT
tv203 = -208						; size = 4
tv185 = -208						; size = 4
_hdr$1 = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_bpc$ = 32						; size = 4
?stbi__load_main@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z PROC ; stbi__load_main, COMDAT

; 1005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1006 : 	memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1007 : 	ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax], 8

; 1008 : 	ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1009 : 	ri->num_channels = 0;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1010 : 
; 1011 : #ifndef STBI_NO_JPEG
; 1012 : 	if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__jpeg_test@@YAHPAUstbi__context@@@Z ; stbi__jpeg_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__jpeg_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__jpeg_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 1013 : #endif
; 1014 : #ifndef STBI_NO_PNG
; 1015 : 	if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__png_test@@YAHPAUstbi__context@@@Z ; stbi__png_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__png_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__png_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN3@stbi__load:

; 1016 : #endif
; 1017 : #ifndef STBI_NO_BMP
; 1018 : 	if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__bmp_test@@YAHPAUstbi__context@@@Z ; stbi__bmp_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__bmp_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__bmp_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN4@stbi__load:

; 1019 : #endif
; 1020 : #ifndef STBI_NO_GIF
; 1021 : 	if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_test@@YAHPAUstbi__context@@@Z ; stbi__gif_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__gif_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__gif_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN5@stbi__load:

; 1022 : #endif
; 1023 : #ifndef STBI_NO_PSD
; 1024 : 	if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__psd_test@@YAHPAUstbi__context@@@Z ; stbi__psd_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR _bpc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ri$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__psd_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z ; stbi__psd_load
	add	esp, 28					; 0000001cH
	jmp	$LN1@stbi__load
$LN6@stbi__load:

; 1025 : #endif
; 1026 : #ifndef STBI_NO_PIC
; 1027 : 	if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_test@@YAHPAUstbi__context@@@Z ; stbi__pic_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__pic_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__pic_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN7@stbi__load:

; 1028 : #endif
; 1029 : #ifndef STBI_NO_PNM
; 1030 : 	if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pnm_test@@YAHPAUstbi__context@@@Z ; stbi__pnm_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@stbi__load
	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__pnm_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__pnm_load
	add	esp, 24					; 00000018H
	jmp	$LN1@stbi__load
$LN8@stbi__load:

; 1031 : #endif
; 1032 : 
; 1033 : #ifndef STBI_NO_HDR
; 1034 : 	if (stbi__hdr_test(s)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@stbi__load

; 1035 : 		float* hdr = stbi__hdr_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__hdr_load@@YAPAMPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__hdr_load
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hdr$1[ebp], eax

; 1036 : 		return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN12@stbi__load
	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN13@stbi__load
$LN12@stbi__load:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv185[ebp], edx
$LN13@stbi__load:
	mov	eax, DWORD PTR tv185[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _hdr$1[ebp]
	push	edx
	call	?stbi__hdr_to_ldr@@YAPAEPAMHHH@Z	; stbi__hdr_to_ldr
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@stbi__load
$LN9@stbi__load:

; 1037 : 	}
; 1038 : #endif
; 1039 : 
; 1040 : #ifndef STBI_NO_TGA
; 1041 : 	// test tga last because it's a crappy test!
; 1042 : 	if (stbi__tga_test(s))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__tga_test@@YAHPAUstbi__context@@@Z ; stbi__tga_test
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@stbi__load

; 1043 : 		return stbi__tga_load(s, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ; stbi__tga_load
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@stbi__load
$LN10@stbi__load:

; 1044 : #endif
; 1045 : 
; 1046 : 	return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

	push	OFFSET ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@stbi__load
	mov	DWORD PTR tv203[ebp], 0
	jmp	SHORT $LN15@stbi__load
$LN14@stbi__load:
	mov	DWORD PTR tv203[ebp], 0
$LN15@stbi__load:
	mov	eax, DWORD PTR tv203[ebp]
$LN1@stbi__load:

; 1047 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__load_main@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z ENDP ; stbi__load_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_to_ldr@@YAPAEPAMHHH@Z
_TEXT	SEGMENT
tv180 = -272						; size = 4
tv179 = -268						; size = 4
tv75 = -268						; size = 4
_z$1 = -68						; size = 4
_z$2 = -56						; size = 4
_output$ = -44						; size = 4
_n$ = -32						; size = 4
_k$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__hdr_to_ldr@@YAPAEPAMHHH@Z PROC			; stbi__hdr_to_ldr, COMDAT

; 1704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1705 : 	int i, k, n;
; 1706 : 	stbi_uc* output;
; 1707 : 	if (!data) return NULL;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN8@stbi__hdr_
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1708 : 	output = (stbi_uc*)stbi__malloc_mad3(x, y, comp, 0);

	push	0
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _output$[ebp], eax

; 1709 : 	if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN9@stbi__hdr_
	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@stbi__hdr_
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN19@stbi__hdr_
$LN18@stbi__hdr_:
	mov	DWORD PTR tv75[ebp], 0
$LN19@stbi__hdr_:
	mov	eax, DWORD PTR tv75[ebp]
	jmp	$LN1@stbi__hdr_
$LN9@stbi__hdr_:

; 1710 : 	// compute number of non-alpha components
; 1711 : 	if (comp & 1) n = comp; else n = comp - 1;

	mov	eax, DWORD PTR _comp$[ebp]
	and	eax, 1
	je	SHORT $LN10@stbi__hdr_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN11@stbi__hdr_
$LN10@stbi__hdr_:
	mov	eax, DWORD PTR _comp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN11@stbi__hdr_:

; 1712 : 	for (i = 0; i < x * y; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__hdr_:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@stbi__hdr_

; 1713 : 		for (k = 0; k < n; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@stbi__hdr_:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN6@stbi__hdr_

; 1714 : 			float z = (float)pow(data[i * comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

	cvtss2sd xmm0, DWORD PTR ?stbi__h2l_gamma_i@@3MA
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	mulss	xmm0, DWORD PTR ?stbi__h2l_scale_i@@3MA
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv179[ebp]
	fld	DWORD PTR tv179[ebp]
	fstp	DWORD PTR tv180[ebp]
	movss	xmm0, DWORD PTR tv180[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _z$2[ebp], xmm0

; 1715 : 			if (z < 0) z = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _z$2[ebp]
	jbe	SHORT $LN12@stbi__hdr_
	xorps	xmm0, xmm0
	movss	DWORD PTR _z$2[ebp], xmm0
$LN12@stbi__hdr_:

; 1716 : 			if (z > 255) z = 255;

	movss	xmm0, DWORD PTR _z$2[ebp]
	comiss	xmm0, DWORD PTR __real@437f0000
	jbe	SHORT $LN13@stbi__hdr_
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _z$2[ebp], xmm0
$LN13@stbi__hdr_:

; 1717 : 			output[i * comp + k] = (stbi_uc)stbi__float2int(z);

	cvttss2si eax, DWORD PTR _z$2[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _comp$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _output$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1718 : 		}

	jmp	$LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1719 : 		if (k < comp) {

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _comp$[ebp]
	jge	SHORT $LN14@stbi__hdr_

; 1720 : 			float z = data[i * comp + k] * 255 + 0.5f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _z$1[ebp], xmm0

; 1721 : 			if (z < 0) z = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _z$1[ebp]
	jbe	SHORT $LN15@stbi__hdr_
	xorps	xmm0, xmm0
	movss	DWORD PTR _z$1[ebp], xmm0
$LN15@stbi__hdr_:

; 1722 : 			if (z > 255) z = 255;

	movss	xmm0, DWORD PTR _z$1[ebp]
	comiss	xmm0, DWORD PTR __real@437f0000
	jbe	SHORT $LN16@stbi__hdr_
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _z$1[ebp], xmm0
$LN16@stbi__hdr_:

; 1723 : 			output[i * comp + k] = (stbi_uc)stbi__float2int(z);

	cvttss2si eax, DWORD PTR _z$1[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _comp$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _output$[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN14@stbi__hdr_:

; 1724 : 		}
; 1725 : 	}

	jmp	$LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1726 : 	STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1727 : 	return output;

	mov	eax, DWORD PTR _output$[ebp]
$LN1@stbi__hdr_:

; 1728 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__hdr_to_ldr@@YAPAEPAMHHH@Z ENDP			; stbi__hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__ldr_to_hdr@@YAPAMPAEHHH@Z
_TEXT	SEGMENT
tv178 = -248						; size = 8
tv76 = -244						; size = 4
_output$ = -44						; size = 4
_n$ = -32						; size = 4
_k$ = -20						; size = 4
_i$ = -8						; size = 4
_data$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__ldr_to_hdr@@YAPAMPAEHHH@Z PROC			; stbi__ldr_to_hdr, COMDAT

; 1678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1679 : 	int i, k, n;
; 1680 : 	float* output;
; 1681 : 	if (!data) return NULL;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN11@stbi__ldr_
	xor	eax, eax
	jmp	$LN1@stbi__ldr_
$LN11@stbi__ldr_:

; 1682 : 	output = (float*)stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

	push	0
	push	4
	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	?stbi__malloc_mad4@@YAPAXHHHHH@Z	; stbi__malloc_mad4
	add	esp, 20					; 00000014H
	mov	DWORD PTR _output$[ebp], eax

; 1683 : 	if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN12@stbi__ldr_
	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@stbi__ldr_
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN18@stbi__ldr_
$LN17@stbi__ldr_:
	mov	DWORD PTR tv76[ebp], 0
$LN18@stbi__ldr_:
	mov	eax, DWORD PTR tv76[ebp]
	jmp	$LN1@stbi__ldr_
$LN12@stbi__ldr_:

; 1684 : 	// compute number of non-alpha components
; 1685 : 	if (comp & 1) n = comp; else n = comp - 1;

	mov	eax, DWORD PTR _comp$[ebp]
	and	eax, 1
	je	SHORT $LN13@stbi__ldr_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN14@stbi__ldr_
$LN13@stbi__ldr_:
	mov	eax, DWORD PTR _comp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN14@stbi__ldr_:

; 1686 : 	for (i = 0; i < x * y; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__ldr_:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@stbi__ldr_

; 1687 : 		for (k = 0; k < n; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@stbi__ldr_:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN6@stbi__ldr_

; 1688 : 			output[i * comp + k] = (float)(pow(data[i * comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

	cvtss2sd xmm0, DWORD PTR ?stbi__l2h_gamma@@3MA
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv178[ebp]
	movsd	xmm0, QWORD PTR tv178[ebp]
	cvtss2sd xmm1, DWORD PTR ?stbi__l2h_scale@@3MA
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 1689 : 		}

	jmp	$LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1690 : 	}

	jmp	$LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1691 : 	if (n < comp) {

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _comp$[ebp]
	jge	SHORT $LN9@stbi__ldr_

; 1692 : 		for (i = 0; i < x * y; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@stbi__ldr_
$LN8@stbi__ldr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__ldr_:
	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN9@stbi__ldr_

; 1693 : 			output[i * comp + n] = data[i * comp + n] / 255.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _comp$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 1694 : 		}

	jmp	SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:

; 1695 : 	}
; 1696 : 	STBI_FREE(data);

	mov	esi, esp
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1697 : 	return output;

	mov	eax, DWORD PTR _output$[ebp]
$LN1@stbi__ldr_:

; 1698 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__ldr_to_hdr@@YAPAMPAEHHH@Z ENDP			; stbi__ldr_to_hdr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__malloc_mad4@@YAPAXHHHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_add$ = 24						; size = 4
?stbi__malloc_mad4@@YAPAXHHHHH@Z PROC			; stbi__malloc_mad4, COMDAT

; 963  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 964  : 	if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__mad4sizes_valid@@YAHHHHHH@Z	; stbi__mad4sizes_valid
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN2@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 965  : 	return stbi__malloc(a * b * c * d + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	imul	eax, DWORD PTR _c$[ebp]
	imul	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
$LN1@stbi__mall:

; 966  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__malloc_mad4@@YAPAXHHHHH@Z ENDP			; stbi__malloc_mad4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__malloc_mad3@@YAPAXHHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_add$ = 20						; size = 4
?stbi__malloc_mad3@@YAPAXHHHH@Z PROC			; stbi__malloc_mad3, COMDAT

; 956  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 957  : 	if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 958  : 	return stbi__malloc(a * b * c + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	imul	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
$LN1@stbi__mall:

; 959  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__malloc_mad3@@YAPAXHHHH@Z ENDP			; stbi__malloc_mad3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__malloc_mad2@@YAPAXHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_add$ = 16						; size = 4
?stbi__malloc_mad2@@YAPAXHHH@Z PROC			; stbi__malloc_mad2, COMDAT

; 950  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 951  : 	if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__mad2sizes_valid@@YAHHHH@Z	; stbi__mad2sizes_valid
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@stbi__mall
	xor	eax, eax
	jmp	SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 952  : 	return stbi__malloc(a * b + add);

	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _add$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
$LN1@stbi__mall:

; 953  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__malloc_mad2@@YAPAXHHH@Z ENDP			; stbi__malloc_mad2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__mad4sizes_valid@@YAHHHHHH@Z
_TEXT	SEGMENT
tv86 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_add$ = 24						; size = 4
?stbi__mad4sizes_valid@@YAHHHHHH@Z PROC			; stbi__mad4sizes_valid, COMDAT

; 942  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 943  : 	return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	imul	edx, DWORD PTR _b$[ebp]
	imul	edx, DWORD PTR _c$[ebp]
	push	edx
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	imul	ecx, DWORD PTR _b$[ebp]
	imul	ecx, DWORD PTR _c$[ebp]
	imul	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	?stbi__addsizes_valid@@YAHHH@Z		; stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad4
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
	mov	DWORD PTR tv86[ebp], 0
$LN4@stbi__mad4:
	mov	eax, DWORD PTR tv86[ebp]

; 944  : 		stbi__mul2sizes_valid(a * b * c, d) && stbi__addsizes_valid(a * b * c * d, add);
; 945  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__mad4sizes_valid@@YAHHHHHH@Z ENDP			; stbi__mad4sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__mad3sizes_valid@@YAHHHHH@Z
_TEXT	SEGMENT
tv79 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_add$ = 20						; size = 4
?stbi__mad3sizes_valid@@YAHHHHH@Z PROC			; stbi__mad3sizes_valid, COMDAT

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 935  : 	return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	ecx, DWORD PTR _add$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	imul	edx, DWORD PTR _b$[ebp]
	imul	edx, DWORD PTR _c$[ebp]
	push	edx
	call	?stbi__addsizes_valid@@YAHHH@Z		; stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad3
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
	mov	DWORD PTR tv79[ebp], 0
$LN4@stbi__mad3:
	mov	eax, DWORD PTR tv79[ebp]

; 936  : 		stbi__addsizes_valid(a * b * c, add);
; 937  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__mad3sizes_valid@@YAHHHHH@Z ENDP			; stbi__mad3sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__mad2sizes_valid@@YAHHHH@Z
_TEXT	SEGMENT
tv73 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_add$ = 16						; size = 4
?stbi__mad2sizes_valid@@YAHHHH@Z PROC			; stbi__mad2sizes_valid, COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 929  : 	return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a * b, add);

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__mul2sizes_valid@@YAHHH@Z		; stbi__mul2sizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad2
	mov	edx, DWORD PTR _add$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	imul	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbi__addsizes_valid@@YAHHH@Z		; stbi__addsizes_valid
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@stbi__mad2
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
	mov	DWORD PTR tv73[ebp], 0
$LN4@stbi__mad2:
	mov	eax, DWORD PTR tv73[ebp]

; 930  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__mad2sizes_valid@@YAHHHH@Z ENDP			; stbi__mad2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__mul2sizes_valid@@YAHHH@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?stbi__mul2sizes_valid@@YAHHH@Z PROC			; stbi__mul2sizes_valid, COMDAT

; 919  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 920  : 	if (a < 0 || b < 0) return 0;

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN3@stbi__mul2
	cmp	DWORD PTR _b$[ebp], 0
	jge	SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
	xor	eax, eax
	jmp	SHORT $LN1@stbi__mul2
$LN2@stbi__mul2:

; 921  : 	if (b == 0) return 1; // mul-by-0 is always safe

	cmp	DWORD PTR _b$[ebp], 0
	jne	SHORT $LN4@stbi__mul2
	mov	eax, 1
	jmp	SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 922  : 	// portable way to check for no overflows in a*b
; 923  : 	return a <= INT_MAX / b;

	mov	eax, 2147483647				; 7fffffffH
	cdq
	idiv	DWORD PTR _b$[ebp]
	cmp	DWORD PTR _a$[ebp], eax
	jg	SHORT $LN6@stbi__mul2
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
	mov	DWORD PTR tv69[ebp], 0
$LN7@stbi__mul2:
	mov	eax, DWORD PTR tv69[ebp]
$LN1@stbi__mul2:

; 924  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__mul2sizes_valid@@YAHHH@Z ENDP			; stbi__mul2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__addsizes_valid@@YAHHH@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?stbi__addsizes_valid@@YAHHH@Z PROC			; stbi__addsizes_valid, COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 908  : 	if (b < 0) return 0;

	cmp	DWORD PTR _b$[ebp], 0
	jge	SHORT $LN2@stbi__adds
	xor	eax, eax
	jmp	SHORT $LN1@stbi__adds
$LN2@stbi__adds:

; 909  : 	// now 0 <= b <= INT_MAX, hence also
; 910  : 	// 0 <= INT_MAX - b <= INTMAX.
; 911  : 	// And "a + b <= INT_MAX" (which might overflow) is the
; 912  : 	// same as a <= INT_MAX - b (no overflow)
; 913  : 	return a <= INT_MAX - b;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, DWORD PTR _b$[ebp]
	cmp	DWORD PTR _a$[ebp], eax
	jg	SHORT $LN4@stbi__adds
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN5@stbi__adds
$LN4@stbi__adds:
	mov	DWORD PTR tv67[ebp], 0
$LN5@stbi__adds:
	mov	eax, DWORD PTR tv67[ebp]
$LN1@stbi__adds:

; 914  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__addsizes_valid@@YAHHH@Z ENDP			; stbi__addsizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__malloc@@YAPAXI@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?stbi__malloc@@YAPAXI@Z PROC				; stbi__malloc, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 891  : 	return STBI_MALLOC(size);

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 892  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__malloc@@YAPAXI@Z ENDP				; stbi__malloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__err@@YAHPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?stbi__err@@YAHPBD@Z PROC				; stbi__err, COMDAT

; 884  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 885  : 	stbi__g_failure_reason = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR ?stbi__g_failure_reason@@3PBDB, eax

; 886  : 	return 0;

	xor	eax, eax

; 887  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__err@@YAHPBD@Z ENDP				; stbi__err
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
tv81 = -260						; size = 4
_t$ = -57						; size = 1
_p$ = -45						; size = 1
_c$ = -33						; size = 1
_dummy$ = -24						; size = 4
_maxv$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__pnm_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__pnm_info, COMDAT

; 7263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7264 : 	int maxv, dummy;
; 7265 : 	char c, p, t;
; 7266 : 
; 7267 : 	if (!x) x = &dummy;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@stbi__pnm_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN2@stbi__pnm_:

; 7268 : 	if (!y) y = &dummy;

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN3@stbi__pnm_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _y$[ebp], eax
$LN3@stbi__pnm_:

; 7269 : 	if (!comp) comp = &dummy;

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN4@stbi__pnm_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN4@stbi__pnm_:

; 7270 : 
; 7271 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7272 : 
; 7273 : 	// Get identifier
; 7274 : 	p = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _p$[ebp], al

; 7275 : 	t = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _t$[ebp], al

; 7276 : 	if (p != 'P' || (t != '5' && t != '6')) {

	movsx	eax, BYTE PTR _p$[ebp]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN6@stbi__pnm_
	movsx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 53					; 00000035H
	je	SHORT $LN5@stbi__pnm_
	movsx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 54					; 00000036H
	je	SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7277 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7278 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7279 : 	}
; 7280 : 
; 7281 : 	*comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

	movsx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 54					; 00000036H
	jne	SHORT $LN10@stbi__pnm_
	mov	DWORD PTR tv81[ebp], 3
	jmp	SHORT $LN11@stbi__pnm_
$LN10@stbi__pnm_:
	mov	DWORD PTR tv81[ebp], 1
$LN11@stbi__pnm_:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [ecx], edx

; 7282 : 
; 7283 : 	c = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _c$[ebp], al

; 7284 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z ; stbi__pnm_skip_whitespace
	add	esp, 8

; 7285 : 
; 7286 : 	*x = stbi__pnm_getinteger(s, &c); // read width

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z ; stbi__pnm_getinteger
	add	esp, 8
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx], eax

; 7287 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z ; stbi__pnm_skip_whitespace
	add	esp, 8

; 7288 : 
; 7289 : 	*y = stbi__pnm_getinteger(s, &c); // read height

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z ; stbi__pnm_getinteger
	add	esp, 8
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], eax

; 7290 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_skip_whitespace@@YAXPAUstbi__context@@PAD@Z ; stbi__pnm_skip_whitespace
	add	esp, 8

; 7291 : 
; 7292 : 	maxv = stbi__pnm_getinteger(s, &c);  // read max value

	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pnm_getinteger@@YAHPAUstbi__context@@PAD@Z ; stbi__pnm_getinteger
	add	esp, 8
	mov	DWORD PTR _maxv$[ebp], eax

; 7293 : 
; 7294 : 	if (maxv > 255)

	cmp	DWORD PTR _maxv$[ebp], 255		; 000000ffH
	jle	SHORT $LN7@stbi__pnm_

; 7295 : 		return stbi__err("max value > 255", "PPM image not 8-bit");

	push	OFFSET ??_C@_0BA@OLLEAHAM@max?5value?5?$DO?5255@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi__pnm_
	jmp	SHORT $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7296 : 	else
; 7297 : 		return 1;

	mov	eax, 1
$LN1@stbi__pnm_:

; 7298 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@stbi__pnm_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@stbi__pnm_:
	DD	2
	DD	$LN14@stbi__pnm_
$LN14@stbi__pnm_:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN12@stbi__pnm_
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN13@stbi__pnm_
$LN13@stbi__pnm_:
	DB	99					; 00000063H
	DB	0
$LN12@stbi__pnm_:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
?stbi__pnm_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__pnm_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv134 = -208						; size = 4
tv89 = -208						; size = 4
_out$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__pnm_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__pnm_load, COMDAT

; 7201 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7202 : 	stbi_uc* out;
; 7203 : 	STBI_NOTUSED(ri);
; 7204 : 
; 7205 : 	if (!stbi__pnm_info(s, (int*)& s->img_x, (int*)& s->img_y, (int*)& s->img_n))

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pnm_info@@YAHPAUstbi__context@@PAH11@Z ; stbi__pnm_info
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@stbi__pnm_

; 7206 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7207 : 
; 7208 : 	*x = s->img_x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 7209 : 	*y = s->img_y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 7210 : 	if (comp)* comp = s->img_n;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN3@stbi__pnm_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
$LN3@stbi__pnm_:

; 7211 : 
; 7212 : 	if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@stbi__pnm_

; 7213 : 		return stbi__errpuc("too large", "PNM too large");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@stbi__pnm_
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN10@stbi__pnm_
$LN9@stbi__pnm_:
	mov	DWORD PTR tv89[ebp], 0
$LN10@stbi__pnm_:
	mov	eax, DWORD PTR tv89[ebp]
	jmp	$LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7214 : 
; 7215 : 	out = (stbi_uc*)stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 7216 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN5@stbi__pnm_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@stbi__pnm_
	mov	DWORD PTR tv134[ebp], 0
	jmp	SHORT $LN12@stbi__pnm_
$LN11@stbi__pnm_:
	mov	DWORD PTR tv134[ebp], 0
$LN12@stbi__pnm_:
	mov	eax, DWORD PTR tv134[ebp]
	jmp	SHORT $LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7217 : 	stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _s$[ebp]
	imul	edx, DWORD PTR [eax+4]
	push	edx
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ; stbi__getn
	add	esp, 12					; 0000000cH

; 7218 : 
; 7219 : 	if (req_comp && req_comp != s->img_n) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN6@stbi__pnm_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _req_comp$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN6@stbi__pnm_

; 7220 : 		out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 7221 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN6@stbi__pnm_
	mov	eax, DWORD PTR _out$[ebp]
	jmp	SHORT $LN1@stbi__pnm_
$LN6@stbi__pnm_:

; 7222 : 	}
; 7223 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@stbi__pnm_:

; 7224 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__pnm_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pnm_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_t$ = -17						; size = 1
_p$ = -5						; size = 1
_s$ = 8							; size = 4
?stbi__pnm_test@@YAHPAUstbi__context@@@Z PROC		; stbi__pnm_test, COMDAT

; 7189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7190 : 	char p, t;
; 7191 : 	p = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _p$[ebp], al

; 7192 : 	t = (char)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _t$[ebp], al

; 7193 : 	if (p != 'P' || (t != '5' && t != '6')) {

	movsx	eax, BYTE PTR _p$[ebp]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 53					; 00000035H
	je	SHORT $LN2@stbi__pnm_
	movsx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 54					; 00000036H
	je	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7194 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7195 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7196 : 	}
; 7197 : 	return 1;

	mov	eax, 1
$LN1@stbi__pnm_:

; 7198 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pnm_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__pnm_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__gif_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__gif_info, COMDAT

; 6777 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6778 : 	return stbi__gif_info_raw(s, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_info_raw@@YAHPAUstbi__context@@PAH11@Z ; stbi__gif_info_raw
	add	esp, 16					; 00000010H

; 6779 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__gif_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__load_gif_main@@YAPAXPAUstbi__context@@PAPAHPAH222H@Z
_TEXT	SEGMENT
tv174 = -36516						; size = 4
_stride$1 = -34972					; size = 4
_g$2 = -34960						; size = 34904
_two_back$3 = -48					; size = 4
_out$4 = -36						; size = 4
_u$5 = -24						; size = 4
_layers$6 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_delays$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_z$ = 24						; size = 4
_comp$ = 28						; size = 4
_req_comp$ = 32						; size = 4
?stbi__load_gif_main@@YAPAXPAUstbi__context@@PAPAHPAH222H@Z PROC ; stbi__load_gif_main, COMDAT

; 6683 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 36516				; 00008ea4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36516]
	mov	ecx, 9129				; 000023a9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6684 : 	if (stbi__gif_test(s)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_test@@YAHPAUstbi__context@@@Z ; stbi__gif_test
	add	esp, 4
	test	eax, eax
	je	$LN5@stbi__load

; 6685 : 		int layers = 0;

	mov	DWORD PTR _layers$6[ebp], 0

; 6686 : 		stbi_uc* u = 0;

	mov	DWORD PTR _u$5[ebp], 0

; 6687 : 		stbi_uc* out = 0;

	mov	DWORD PTR _out$4[ebp], 0

; 6688 : 		stbi_uc* two_back = 0;

	mov	DWORD PTR _two_back$3[ebp], 0

; 6689 : 		stbi__gif g;
; 6690 : 		int stride;
; 6691 : 		memset(&g, 0, sizeof(g));

	push	34904					; 00008858H
	push	0
	lea	eax, DWORD PTR _g$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 6692 : 		if (delays) {

	cmp	DWORD PTR _delays$[ebp], 0
	je	SHORT $LN4@stbi__load

; 6693 : 			*delays = 0;

	mov	eax, DWORD PTR _delays$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@stbi__load:

; 6694 : 		}
; 6695 : 
; 6696 : 		do {
; 6697 : 			u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);

	mov	eax, DWORD PTR _two_back$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	lea	eax, DWORD PTR _g$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__gif_load_next@@YAPAEPAUstbi__context@@PAUstbi__gif@@PAHHPAE@Z ; stbi__gif_load_next
	add	esp, 20					; 00000014H
	mov	DWORD PTR _u$5[ebp], eax

; 6698 : 			if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

	mov	eax, DWORD PTR _u$5[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	jne	SHORT $LN8@stbi__load
	mov	DWORD PTR _u$5[ebp], 0
$LN8@stbi__load:

; 6699 : 
; 6700 : 			if (u) {

	cmp	DWORD PTR _u$5[ebp], 0
	je	$LN2@stbi__load

; 6701 : 				*x = g.w;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _g$2[ebp]
	mov	DWORD PTR [eax], ecx

; 6702 : 				*y = g.h;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _g$2[ebp+4]
	mov	DWORD PTR [eax], ecx

; 6703 : 				++layers;

	mov	eax, DWORD PTR _layers$6[ebp]
	add	eax, 1
	mov	DWORD PTR _layers$6[ebp], eax

; 6704 : 				stride = g.w * g.h * 4;

	mov	eax, DWORD PTR _g$2[ebp]
	imul	eax, DWORD PTR _g$2[ebp+4]
	shl	eax, 2
	mov	DWORD PTR _stride$1[ebp], eax

; 6705 : 
; 6706 : 				if (out) {

	cmp	DWORD PTR _out$4[ebp], 0
	je	SHORT $LN10@stbi__load

; 6707 : 					out = (stbi_uc*)STBI_REALLOC(out, layers * stride);

	xor	ecx, ecx
	mov	eax, DWORD PTR _layers$6[ebp]
	mul	DWORD PTR _stride$1[ebp]
	seto	cl
	neg	ecx
	or	ecx, eax
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _out$4[ebp]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _out$4[ebp], eax

; 6708 : 					if (delays) {

	cmp	DWORD PTR _delays$[ebp], 0
	je	SHORT $LN12@stbi__load

; 6709 : 						*delays = (int*)STBI_REALLOC(*delays, sizeof(int) * layers);

	xor	ecx, ecx
	mov	eax, DWORD PTR _layers$6[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR _delays$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _delays$[ebp]
	mov	DWORD PTR [edx], eax
$LN12@stbi__load:

; 6710 : 					}
; 6711 : 				}

	jmp	SHORT $LN11@stbi__load
$LN10@stbi__load:

; 6712 : 				else {
; 6713 : 					out = (stbi_uc*)stbi__malloc(layers * stride);

	mov	eax, DWORD PTR _layers$6[ebp]
	imul	eax, DWORD PTR _stride$1[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _out$4[ebp], eax

; 6714 : 					if (delays) {

	cmp	DWORD PTR _delays$[ebp], 0
	je	SHORT $LN11@stbi__load

; 6715 : 						*delays = (int*)stbi__malloc(layers * sizeof(int));

	mov	eax, DWORD PTR _layers$6[ebp]
	shl	eax, 2
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _delays$[ebp]
	mov	DWORD PTR [ecx], eax
$LN11@stbi__load:

; 6716 : 					}
; 6717 : 				}
; 6718 : 				memcpy(out + ((layers - 1) * stride), u, stride);

	mov	eax, DWORD PTR _stride$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _layers$6[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _stride$1[ebp]
	add	edx, DWORD PTR _out$4[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6719 : 				if (layers >= 2) {

	cmp	DWORD PTR _layers$6[ebp], 2
	jl	SHORT $LN14@stbi__load

; 6720 : 					two_back = out - 2 * stride;

	mov	eax, DWORD PTR _stride$1[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _out$4[ebp]
	sub	ecx, eax
	mov	DWORD PTR _two_back$3[ebp], ecx
$LN14@stbi__load:

; 6721 : 				}
; 6722 : 
; 6723 : 				if (delays) {

	cmp	DWORD PTR _delays$[ebp], 0
	je	SHORT $LN2@stbi__load

; 6724 : 					(*delays)[layers - 1U] = g.delay;

	mov	eax, DWORD PTR _delays$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _layers$6[ebp]
	mov	eax, DWORD PTR _g$2[ebp+34900]
	mov	DWORD PTR [ecx+edx*4-4], eax
$LN2@stbi__load:

; 6725 : 				}
; 6726 : 			}
; 6727 : 		} while (u != 0);

	cmp	DWORD PTR _u$5[ebp], 0
	jne	$LN4@stbi__load

; 6728 : 
; 6729 : 		// free temp buffer; 
; 6730 : 		STBI_FREE(g.out);

	mov	esi, esp
	mov	eax, DWORD PTR _g$2[ebp+8]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6731 : 		STBI_FREE(g.history);

	mov	esi, esp
	mov	eax, DWORD PTR _g$2[ebp+16]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6732 : 		STBI_FREE(g.background);

	mov	esi, esp
	mov	eax, DWORD PTR _g$2[ebp+12]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6733 : 
; 6734 : 		// do the final conversion after loading everything; 
; 6735 : 		if (req_comp && req_comp != 4)

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN16@stbi__load
	cmp	DWORD PTR _req_comp$[ebp], 4
	je	SHORT $LN16@stbi__load

; 6736 : 			out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

	mov	eax, DWORD PTR _g$2[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _layers$6[ebp]
	imul	ecx, DWORD PTR _g$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _out$4[ebp]
	push	eax
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$4[ebp], eax
$LN16@stbi__load:

; 6737 : 
; 6738 : 		*z = layers;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _layers$6[ebp]
	mov	DWORD PTR [eax], ecx

; 6739 : 		return out;

	mov	eax, DWORD PTR _out$4[ebp]
	jmp	SHORT $LN1@stbi__load

; 6740 : 	}

	jmp	SHORT $LN1@stbi__load
$LN5@stbi__load:

; 6741 : 	else {
; 6742 : 		return stbi__errpuc("not GIF", "Image was not as a gif type.");

	push	OFFSET ??_C@_07KMJLPAII@not?5GIF@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@stbi__load
	mov	DWORD PTR tv174[ebp], 0
	jmp	SHORT $LN19@stbi__load
$LN18@stbi__load:
	mov	DWORD PTR tv174[ebp], 0
$LN19@stbi__load:
	mov	eax, DWORD PTR tv174[ebp]
$LN1@stbi__load:

; 6743 : 	}
; 6744 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@stbi__load
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 36516				; 00008ea4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@stbi__load:
	DD	1
	DD	$LN21@stbi__load
$LN21@stbi__load:
	DD	-34960					; ffff7770H
	DD	34904					; 00008858H
	DD	$LN20@stbi__load
$LN20@stbi__load:
	DB	103					; 00000067H
	DB	0
?stbi__load_gif_main@@YAPAXPAUstbi__context@@PAPAHPAH222H@Z ENDP ; stbi__load_gif_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
_g$ = -34924						; size = 34904
_u$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__gif_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__gif_load, COMDAT

; 6747 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 36464				; 00008e70H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36464]
	mov	ecx, 9116				; 0000239cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6748 : 	stbi_uc* u = 0;

	mov	DWORD PTR _u$[ebp], 0

; 6749 : 	stbi__gif g;
; 6750 : 	memset(&g, 0, sizeof(g));

	push	34904					; 00008858H
	push	0
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 6751 : 	STBI_NOTUSED(ri);
; 6752 : 
; 6753 : 	u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

	push	0
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _g$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_load_next@@YAPAEPAUstbi__context@@PAUstbi__gif@@PAHHPAE@Z ; stbi__gif_load_next
	add	esp, 20					; 00000014H
	mov	DWORD PTR _u$[ebp], eax

; 6754 : 	if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

	mov	eax, DWORD PTR _u$[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	jne	SHORT $LN2@stbi__gif_
	mov	DWORD PTR _u$[ebp], 0
$LN2@stbi__gif_:

; 6755 : 	if (u) {

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN3@stbi__gif_

; 6756 : 		*x = g.w;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax], ecx

; 6757 : 		*y = g.h;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _g$[ebp+4]
	mov	DWORD PTR [eax], ecx

; 6758 : 
; 6759 : 		// moved conversion to after successful load so that the same
; 6760 : 		// can be done for multiple frames. 
; 6761 : 		if (req_comp && req_comp != 4)

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN5@stbi__gif_
	cmp	DWORD PTR _req_comp$[ebp], 4
	je	SHORT $LN5@stbi__gif_

; 6762 : 			u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

	mov	eax, DWORD PTR _g$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _u$[ebp], eax
$LN5@stbi__gif_:

; 6763 : 	}

	jmp	SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:

; 6764 : 	else if (g.out) {

	cmp	DWORD PTR _g$[ebp+8], 0
	je	SHORT $LN4@stbi__gif_

; 6765 : 		// if there was an error and we allocated an image buffer, free it!
; 6766 : 		STBI_FREE(g.out);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp+8]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@stbi__gif_:

; 6767 : 	}
; 6768 : 
; 6769 : 	// free buffers needed for multiple frame loading; 
; 6770 : 	STBI_FREE(g.history);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp+16]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6771 : 	STBI_FREE(g.background);

	mov	esi, esp
	mov	eax, DWORD PTR _g$[ebp+12]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6772 : 
; 6773 : 	return u;

	mov	eax, DWORD PTR _u$[ebp]

; 6774 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@stbi__gif_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 36464				; 00008e70H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@stbi__gif_:
	DD	1
	DD	$LN9@stbi__gif_
$LN9@stbi__gif_:
	DD	-34924					; ffff7794H
	DD	34904					; 00008858H
	DD	$LN8@stbi__gif_
$LN8@stbi__gif_:
	DB	103					; 00000067H
	DB	0
?stbi__gif_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__gif_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__gif_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__gif_test@@YAHPAUstbi__context@@@Z PROC		; stbi__gif_test, COMDAT

; 6312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6313 : 	int r = stbi__gif_test_raw(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__gif_test_raw@@YAHPAUstbi__context@@@Z ; stbi__gif_test_raw
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 6314 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 6315 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 6316 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__gif_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__gif_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
tv150 = -300						; size = 4
_packet$1 = -100					; size = 4
_packets$ = -88						; size = 30
_dummy$ = -48						; size = 4
_chained$ = -36						; size = 4
_num_packets$ = -24					; size = 4
_act_comp$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__pic_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__pic_info, COMDAT

; 7117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7118 : 	int act_comp = 0, num_packets = 0, chained, dummy;

	mov	DWORD PTR _act_comp$[ebp], 0
	mov	DWORD PTR _num_packets$[ebp], 0

; 7119 : 	stbi__pic_packet packets[10];
; 7120 : 
; 7121 : 	if (!x) x = &dummy;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN5@stbi__pic_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN5@stbi__pic_:

; 7122 : 	if (!y) y = &dummy;

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN6@stbi__pic_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _y$[ebp], eax
$LN6@stbi__pic_:

; 7123 : 	if (!comp) comp = &dummy;

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN7@stbi__pic_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN7@stbi__pic_:

; 7124 : 
; 7125 : 	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {

	push	OFFSET ??_C@_04KBFEPHFH@S?$IA?v4@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_is4@@YAHPAUstbi__context@@PBD@Z ; stbi__pic_is4
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@stbi__pic_

; 7126 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7127 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN8@stbi__pic_:

; 7128 : 	}
; 7129 : 
; 7130 : 	stbi__skip(s, 88);

	push	88					; 00000058H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 7131 : 
; 7132 : 	*x = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], eax

; 7133 : 	*y = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx], eax

; 7134 : 	if (stbi__at_eof(s)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@stbi__pic_

; 7135 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7136 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN9@stbi__pic_:

; 7137 : 	}
; 7138 : 	if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@stbi__pic_
	mov	ecx, DWORD PTR _x$[ebp]
	mov	eax, 268435456				; 10000000H
	cdq
	idiv	DWORD PTR [ecx]
	mov	edx, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN10@stbi__pic_

; 7139 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7140 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN10@stbi__pic_:

; 7141 : 	}
; 7142 : 
; 7143 : 	stbi__skip(s, 8);

	push	8
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8
$LN4@stbi__pic_:

; 7144 : 
; 7145 : 	do {
; 7146 : 		stbi__pic_packet* packet;
; 7147 : 
; 7148 : 		if (num_packets == sizeof(packets) / sizeof(packets[0]))

	cmp	DWORD PTR _num_packets$[ebp], 10	; 0000000aH
	jne	SHORT $LN11@stbi__pic_

; 7149 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN11@stbi__pic_:

; 7150 : 
; 7151 : 		packet = &packets[num_packets++];

	imul	eax, DWORD PTR _num_packets$[ebp], 3
	lea	ecx, DWORD PTR _packets$[ebp+eax]
	mov	DWORD PTR _packet$1[ebp], ecx
	mov	edx, DWORD PTR _num_packets$[ebp]
	add	edx, 1
	mov	DWORD PTR _num_packets$[ebp], edx

; 7152 : 		chained = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _chained$[ebp], ecx

; 7153 : 		packet->size = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$1[ebp]
	mov	BYTE PTR [ecx], al

; 7154 : 		packet->type = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$1[ebp]
	mov	BYTE PTR [ecx+1], al

; 7155 : 		packet->channel = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _packet$1[ebp]
	mov	BYTE PTR [ecx+2], al

; 7156 : 		act_comp |= packet->channel;

	mov	eax, DWORD PTR _packet$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	or	ecx, DWORD PTR _act_comp$[ebp]
	mov	DWORD PTR _act_comp$[ebp], ecx

; 7157 : 
; 7158 : 		if (stbi__at_eof(s)) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@stbi__pic_

; 7159 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7160 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN12@stbi__pic_:

; 7161 : 		}
; 7162 : 		if (packet->size != 8) {

	mov	eax, DWORD PTR _packet$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 8
	je	SHORT $LN2@stbi__pic_

; 7163 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7164 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN2@stbi__pic_:

; 7165 : 		}
; 7166 : 	} while (chained);

	cmp	DWORD PTR _chained$[ebp], 0
	jne	$LN4@stbi__pic_

; 7167 : 
; 7168 : 	*comp = (act_comp & 0x10 ? 4 : 3);

	mov	eax, DWORD PTR _act_comp$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN15@stbi__pic_
	mov	DWORD PTR tv150[ebp], 4
	jmp	SHORT $LN16@stbi__pic_
$LN15@stbi__pic_:
	mov	DWORD PTR tv150[ebp], 3
$LN16@stbi__pic_:
	mov	ecx, DWORD PTR _comp$[ebp]
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR [ecx], edx

; 7169 : 
; 7170 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 7171 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@stbi__pic_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@stbi__pic_:
	DD	2
	DD	$LN19@stbi__pic_
$LN19@stbi__pic_:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN17@stbi__pic_
	DD	-88					; ffffffa8H
	DD	30					; 0000001eH
	DD	$LN18@stbi__pic_
$LN18@stbi__pic_:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN17@stbi__pic_:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
?stbi__pic_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__pic_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv88 = -260						; size = 4
tv78 = -260						; size = 4
_internal_comp$ = -60					; size = 4
_y$ = -48						; size = 4
_x$ = -36						; size = 4
_i$ = -24						; size = 4
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_px$ = 12						; size = 4
_py$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__pic_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__pic_load, COMDAT

; 6227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6228 : 	stbi_uc* result;
; 6229 : 	int i, x, y, internal_comp;
; 6230 : 	STBI_NOTUSED(ri);
; 6231 : 
; 6232 : 	if (!comp) comp = &internal_comp;

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN5@stbi__pic_
	lea	eax, DWORD PTR _internal_comp$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN5@stbi__pic_:

; 6233 : 
; 6234 : 	for (i = 0; i < 92; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR _i$[ebp], 92			; 0000005cH
	jge	SHORT $LN3@stbi__pic_

; 6235 : 		stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6236 : 
; 6237 : 	x = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _x$[ebp], eax

; 6238 : 	y = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _y$[ebp], eax

; 6239 : 	if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__at_eof@@YAHPAUstbi__context@@@Z	; stbi__at_eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@stbi__pic_
	push	OFFSET ??_C@_08GGMBIFE@bad?5file@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@stbi__pic_
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN12@stbi__pic_
$LN11@stbi__pic_:
	mov	DWORD PTR tv78[ebp], 0
$LN12@stbi__pic_:
	mov	eax, DWORD PTR tv78[ebp]
	jmp	$LN1@stbi__pic_
$LN6@stbi__pic_:

; 6240 : 	if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

	push	0
	push	4
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN7@stbi__pic_
	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@stbi__pic_
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN14@stbi__pic_
$LN13@stbi__pic_:
	mov	DWORD PTR tv88[ebp], 0
$LN14@stbi__pic_:
	mov	eax, DWORD PTR tv88[ebp]
	jmp	$LN1@stbi__pic_
$LN7@stbi__pic_:

; 6241 : 
; 6242 : 	stbi__get32be(s); //skip `ratio'

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4

; 6243 : 	stbi__get16be(s); //skip `fields'

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4

; 6244 : 	stbi__get16be(s); //skip `pad'

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4

; 6245 : 
; 6246 : 	// intermediate buffer is RGBA
; 6247 : 	result = (stbi_uc*)stbi__malloc_mad3(x, y, 4, 0);

	push	0
	push	4
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 6248 : 	memset(result, 0xff, x * y * 4);

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	shl	eax, 2
	push	eax
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6249 : 
; 6250 : 	if (!stbi__pic_load_core(s, x, y, comp, result)) {

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__pic_load_core@@YAPAEPAUstbi__context@@HHPAHPAE@Z ; stbi__pic_load_core
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN8@stbi__pic_

; 6251 : 		STBI_FREE(result);

	mov	esi, esp
	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6252 : 		result = 0;

	mov	DWORD PTR _result$[ebp], 0
$LN8@stbi__pic_:

; 6253 : 	}
; 6254 : 	*px = x;

	mov	eax, DWORD PTR _px$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [eax], ecx

; 6255 : 	*py = y;

	mov	eax, DWORD PTR _py$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [eax], ecx

; 6256 : 	if (req_comp == 0) req_comp = *comp;

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN9@stbi__pic_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _req_comp$[ebp], ecx
$LN9@stbi__pic_:

; 6257 : 	result = stbi__convert_format(result, 4, req_comp, x, y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 6258 : 
; 6259 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi__pic_:

; 6260 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@stbi__pic_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@stbi__pic_:
	DD	1
	DD	$LN16@stbi__pic_
$LN16@stbi__pic_:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN15@stbi__pic_
$LN15@stbi__pic_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?stbi__pic_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__pic_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__pic_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__pic_test@@YAHPAUstbi__context@@@Z PROC		; stbi__pic_test, COMDAT

; 6263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6264 : 	int r = stbi__pic_test_core(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__pic_test_core@@YAHPAUstbi__context@@@Z ; stbi__pic_test_core
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 6265 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 6266 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 6267 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__pic_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__pic_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_dummy$ = -1068						; size = 4
_valid$ = -1056						; size = 4
_token$ = -1044						; size = 4
_buffer$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__hdr_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__hdr_info, COMDAT

; 6989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1648				; 00000670H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1648]
	mov	ecx, 412				; 0000019cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6990 : 	char buffer[STBI__HDR_BUFLEN];
; 6991 : 	char* token;
; 6992 : 	int valid = 0;

	mov	DWORD PTR _valid$[ebp], 0

; 6993 : 	int dummy;
; 6994 : 
; 6995 : 	if (!x) x = &dummy;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN7@stbi__hdr_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN7@stbi__hdr_:

; 6996 : 	if (!y) y = &dummy;

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN8@stbi__hdr_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _y$[ebp], eax
$LN8@stbi__hdr_:

; 6997 : 	if (!comp) comp = &dummy;

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN9@stbi__hdr_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN9@stbi__hdr_:

; 6998 : 
; 6999 : 	if (stbi__hdr_test(s) == 0) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@stbi__hdr_

; 7000 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7001 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN4@stbi__hdr_:

; 7002 : 	}
; 7003 : 
; 7004 : 	for (;;) {
; 7005 : 		token = stbi__hdr_gettoken(s, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ; stbi__hdr_gettoken
	add	esp, 8
	mov	DWORD PTR _token$[ebp], eax

; 7006 : 		if (token[0] == 0) break;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN11@stbi__hdr_
	jmp	SHORT $LN3@stbi__hdr_
$LN11@stbi__hdr_:

; 7007 : 		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

	push	OFFSET ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@stbi__hdr_
	mov	DWORD PTR _valid$[ebp], 1
$LN12@stbi__hdr_:

; 7008 : 	}

	jmp	SHORT $LN4@stbi__hdr_
$LN3@stbi__hdr_:

; 7009 : 
; 7010 : 	if (!valid) {

	cmp	DWORD PTR _valid$[ebp], 0
	jne	SHORT $LN13@stbi__hdr_

; 7011 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7012 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN13@stbi__hdr_:

; 7013 : 	}
; 7014 : 	token = stbi__hdr_gettoken(s, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ; stbi__hdr_gettoken
	add	esp, 8
	mov	DWORD PTR _token$[ebp], eax

; 7015 : 	if (strncmp(token, "-Y ", 3)) {

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03HKAKGGJN@?9Y?5@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN14@stbi__hdr_

; 7016 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7017 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN14@stbi__hdr_:

; 7018 : 	}
; 7019 : 	token += 3;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 3
	mov	DWORD PTR _token$[ebp], eax

; 7020 : 	*y = (int)strtol(token, &token, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], eax
$LN5@stbi__hdr_:

; 7021 : 	while (*token == ' ') ++token;

	mov	eax, DWORD PTR _token$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN6@stbi__hdr_
	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 1
	mov	DWORD PTR _token$[ebp], eax
	jmp	SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7022 : 	if (strncmp(token, "+X ", 3)) {

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03FOKDFDHG@?$CLX?5@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN15@stbi__hdr_

; 7023 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7024 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__hdr_
$LN15@stbi__hdr_:

; 7025 : 	}
; 7026 : 	token += 3;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 3
	mov	DWORD PTR _token$[ebp], eax

; 7027 : 	*x = (int)strtol(token, NULL, 10);

	mov	esi, esp
	push	10					; 0000000aH
	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], eax

; 7028 : 	*comp = 3;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax], 3

; 7029 : 	return 1;

	mov	eax, 1
$LN1@stbi__hdr_:

; 7030 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@stbi__hdr_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1648				; 00000670H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@stbi__hdr_:
	DD	3
	DD	$LN20@stbi__hdr_
$LN20@stbi__hdr_:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN17@stbi__hdr_
	DD	-1044					; fffffbecH
	DD	4
	DD	$LN18@stbi__hdr_
	DD	-1068					; fffffbd4H
	DD	4
	DD	$LN19@stbi__hdr_
$LN19@stbi__hdr_:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
$LN18@stbi__hdr_:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN17@stbi__hdr_:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?stbi__hdr_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__hdr_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_load@@YAPAMPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv292 = -1844						; size = 4
tv276 = -1844						; size = 4
tv255 = -1844						; size = 4
tv244 = -1844						; size = 4
tv184 = -1844						; size = 4
tv173 = -1844						; size = 4
tv155 = -1844						; size = 4
tv138 = -1844						; size = 4
tv94 = -1844						; size = 4
tv78 = -1844						; size = 4
_nleft$1 = -1260					; size = 4
_rgbe$2 = -1248						; size = 4
_rgbe$3 = -1236						; size = 4
_headerToken$ = -1224					; size = 4
_z$ = -1212						; size = 4
_c2$ = -1200						; size = 4
_c1$ = -1188						; size = 4
_k$ = -1176						; size = 4
_j$ = -1164						; size = 4
_i$ = -1152						; size = 4
_value$ = -1137						; size = 1
_count$ = -1125						; size = 1
_len$ = -1116						; size = 4
_hdr_data$ = -1104					; size = 4
_scanline$ = -1092					; size = 4
_height$ = -1080					; size = 4
_width$ = -1068						; size = 4
_valid$ = -1056						; size = 4
_token$ = -1044						; size = 4
_buffer$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__hdr_load@@YAPAMPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__hdr_load, COMDAT

; 6859 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1844				; 00000734H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1844]
	mov	ecx, 461				; 000001cdH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6860 : 	char buffer[STBI__HDR_BUFLEN];
; 6861 : 	char* token;
; 6862 : 	int valid = 0;

	mov	DWORD PTR _valid$[ebp], 0

; 6863 : 	int width, height;
; 6864 : 	stbi_uc* scanline;
; 6865 : 	float* hdr_data;
; 6866 : 	int len;
; 6867 : 	unsigned char count, value;
; 6868 : 	int i, j, k, c1, c2, z;
; 6869 : 	const char* headerToken;
; 6870 : 	STBI_NOTUSED(ri);
; 6871 : 
; 6872 : 	// Check identifier
; 6873 : 	headerToken = stbi__hdr_gettoken(s, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ; stbi__hdr_gettoken
	add	esp, 8
	mov	DWORD PTR _headerToken$[ebp], eax

; 6874 : 	if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

	push	OFFSET ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
	mov	eax, DWORD PTR _headerToken$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@stbi__hdr_
	push	OFFSET ??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
	mov	eax, DWORD PTR _headerToken$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@stbi__hdr_

; 6875 : 		return stbi__errpf("not HDR", "Corrupt HDR image");

	push	OFFSET ??_C@_07NCIOKENI@not?5HDR@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN54@stbi__hdr_
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN55@stbi__hdr_
$LN54@stbi__hdr_:
	mov	DWORD PTR tv78[ebp], 0
$LN55@stbi__hdr_:
	mov	eax, DWORD PTR tv78[ebp]
	jmp	$LN1@stbi__hdr_
$LN4@stbi__hdr_:

; 6876 : 
; 6877 : 	// Parse header
; 6878 : 	for (;;) {
; 6879 : 		token = stbi__hdr_gettoken(s, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ; stbi__hdr_gettoken
	add	esp, 8
	mov	DWORD PTR _token$[ebp], eax

; 6880 : 		if (token[0] == 0) break;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN31@stbi__hdr_
	jmp	SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 6881 : 		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

	push	OFFSET ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@stbi__hdr_
	mov	DWORD PTR _valid$[ebp], 1
$LN32@stbi__hdr_:

; 6882 : 	}

	jmp	SHORT $LN4@stbi__hdr_
$LN3@stbi__hdr_:

; 6883 : 
; 6884 : 	if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	cmp	DWORD PTR _valid$[ebp], 0
	jne	SHORT $LN33@stbi__hdr_
	push	OFFSET ??_C@_0BD@NKJFFLKL@unsupported?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN56@stbi__hdr_
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN57@stbi__hdr_
$LN56@stbi__hdr_:
	mov	DWORD PTR tv94[ebp], 0
$LN57@stbi__hdr_:
	mov	eax, DWORD PTR tv94[ebp]
	jmp	$LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 6885 : 
; 6886 : 	// Parse width and height
; 6887 : 	// can't use sscanf() if we're not using stdio!
; 6888 : 	token = stbi__hdr_gettoken(s, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__hdr_gettoken@@YAPADPAUstbi__context@@PAD@Z ; stbi__hdr_gettoken
	add	esp, 8
	mov	DWORD PTR _token$[ebp], eax

; 6889 : 	if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03HKAKGGJN@?9Y?5@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN34@stbi__hdr_
	push	OFFSET ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN58@stbi__hdr_
	mov	DWORD PTR tv138[ebp], 0
	jmp	SHORT $LN59@stbi__hdr_
$LN58@stbi__hdr_:
	mov	DWORD PTR tv138[ebp], 0
$LN59@stbi__hdr_:
	mov	eax, DWORD PTR tv138[ebp]
	jmp	$LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 6890 : 	token += 3;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 3
	mov	DWORD PTR _token$[ebp], eax

; 6891 : 	height = (int)strtol(token, &token, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _height$[ebp], eax
$LN5@stbi__hdr_:

; 6892 : 	while (*token == ' ') ++token;

	mov	eax, DWORD PTR _token$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN6@stbi__hdr_
	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 1
	mov	DWORD PTR _token$[ebp], eax
	jmp	SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 6893 : 	if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03FOKDFDHG@?$CLX?5@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN35@stbi__hdr_
	push	OFFSET ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN60@stbi__hdr_
	mov	DWORD PTR tv155[ebp], 0
	jmp	SHORT $LN61@stbi__hdr_
$LN60@stbi__hdr_:
	mov	DWORD PTR tv155[ebp], 0
$LN61@stbi__hdr_:
	mov	eax, DWORD PTR tv155[ebp]
	jmp	$LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 6894 : 	token += 3;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, 3
	mov	DWORD PTR _token$[ebp], eax

; 6895 : 	width = (int)strtol(token, NULL, 10);

	mov	esi, esp
	push	10					; 0000000aH
	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _width$[ebp], eax

; 6896 : 
; 6897 : 	*x = width;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax], ecx

; 6898 : 	*y = height;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax], ecx

; 6899 : 
; 6900 : 	if (comp)* comp = 3;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN36@stbi__hdr_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax], 3
$LN36@stbi__hdr_:

; 6901 : 	if (req_comp == 0) req_comp = 3;

	cmp	DWORD PTR _req_comp$[ebp], 0
	jne	SHORT $LN37@stbi__hdr_
	mov	DWORD PTR _req_comp$[ebp], 3
$LN37@stbi__hdr_:

; 6902 : 
; 6903 : 	if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))

	push	0
	push	4
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	?stbi__mad4sizes_valid@@YAHHHHHH@Z	; stbi__mad4sizes_valid
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN38@stbi__hdr_

; 6904 : 		return stbi__errpf("too large", "HDR image is too large");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@stbi__hdr_
	mov	DWORD PTR tv173[ebp], 0
	jmp	SHORT $LN63@stbi__hdr_
$LN62@stbi__hdr_:
	mov	DWORD PTR tv173[ebp], 0
$LN63@stbi__hdr_:
	mov	eax, DWORD PTR tv173[ebp]
	jmp	$LN1@stbi__hdr_
$LN38@stbi__hdr_:

; 6905 : 
; 6906 : 	// Read data
; 6907 : 	hdr_data = (float*)stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);

	push	0
	push	4
	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	?stbi__malloc_mad4@@YAPAXHHHHH@Z	; stbi__malloc_mad4
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hdr_data$[ebp], eax

; 6908 : 	if (!hdr_data)

	cmp	DWORD PTR _hdr_data$[ebp], 0
	jne	SHORT $LN39@stbi__hdr_

; 6909 : 		return stbi__errpf("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN64@stbi__hdr_
	mov	DWORD PTR tv184[ebp], 0
	jmp	SHORT $LN65@stbi__hdr_
$LN64@stbi__hdr_:
	mov	DWORD PTR tv184[ebp], 0
$LN65@stbi__hdr_:
	mov	eax, DWORD PTR tv184[ebp]
	jmp	$LN1@stbi__hdr_
$LN39@stbi__hdr_:

; 6910 : 
; 6911 : 	// Load image data
; 6912 : 	// image data is stored as some number of sca
; 6913 : 	if (width < 8 || width >= 32768) {

	cmp	DWORD PTR _width$[ebp], 8
	jl	SHORT $LN42@stbi__hdr_
	cmp	DWORD PTR _width$[ebp], 32768		; 00008000H
	jl	$LN40@stbi__hdr_
$LN42@stbi__hdr_:

; 6914 : 		// Read flat data
; 6915 : 		for (j = 0; j < height; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@stbi__hdr_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	$LN8@stbi__hdr_

; 6916 : 			for (i = 0; i < width; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jge	SHORT $LN11@stbi__hdr_
$main_decode_loop$80:

; 6917 : 				stbi_uc rgbe[4];
; 6918 : 			main_decode_loop:
; 6919 : 				stbi__getn(s, rgbe, 4);

	push	4
	lea	eax, DWORD PTR _rgbe$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ; stbi__getn
	add	esp, 12					; 0000000cH

; 6920 : 				stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgbe$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, DWORD PTR _width$[ebp]
	imul	edx, DWORD PTR _req_comp$[ebp]
	mov	eax, DWORD PTR _hdr_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _req_comp$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?stbi__hdr_convert@@YAXPAMPAEH@Z	; stbi__hdr_convert
	add	esp, 12					; 0000000cH

; 6921 : 			}

	jmp	SHORT $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 6922 : 		}

	jmp	$LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 6923 : 	}

	jmp	$LN41@stbi__hdr_
$LN40@stbi__hdr_:

; 6924 : 	else {
; 6925 : 		// Read RLE-encoded data
; 6926 : 		scanline = NULL;

	mov	DWORD PTR _scanline$[ebp], 0

; 6927 : 
; 6928 : 		for (j = 0; j < height; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN15@stbi__hdr_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	$LN14@stbi__hdr_

; 6929 : 			c1 = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _c1$[ebp], ecx

; 6930 : 			c2 = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _c2$[ebp], ecx

; 6931 : 			len = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _len$[ebp], ecx

; 6932 : 			if (c1 != 2 || c2 != 2 || (len & 0x80)) {

	cmp	DWORD PTR _c1$[ebp], 2
	jne	SHORT $LN44@stbi__hdr_
	cmp	DWORD PTR _c2$[ebp], 2
	jne	SHORT $LN44@stbi__hdr_
	mov	eax, DWORD PTR _len$[ebp]
	and	eax, 128				; 00000080H
	je	$LN43@stbi__hdr_
$LN44@stbi__hdr_:

; 6933 : 				// not run-length encoded, so we have to actually use THIS data as a decoded
; 6934 : 				// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 6935 : 				stbi_uc rgbe[4];
; 6936 : 				rgbe[0] = (stbi_uc)c1;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _c1$[ebp]
	mov	BYTE PTR _rgbe$2[ebp+ecx], dl

; 6937 : 				rgbe[1] = (stbi_uc)c2;

	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR _c2$[ebp]
	mov	BYTE PTR _rgbe$2[ebp+eax], cl

; 6938 : 				rgbe[2] = (stbi_uc)len;

	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR _len$[ebp]
	mov	BYTE PTR _rgbe$2[ebp+eax], cl

; 6939 : 				rgbe[3] = (stbi_uc)stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _rgbe$2[ebp+edx], al

; 6940 : 				stbi__hdr_convert(hdr_data, rgbe, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgbe$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _hdr_data$[ebp]
	push	edx
	call	?stbi__hdr_convert@@YAXPAMPAEH@Z	; stbi__hdr_convert
	add	esp, 12					; 0000000cH

; 6941 : 				i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 6942 : 				j = 0;

	mov	DWORD PTR _j$[ebp], 0

; 6943 : 				STBI_FREE(scanline);

	mov	esi, esp
	mov	eax, DWORD PTR _scanline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6944 : 				goto main_decode_loop; // yes, this makes no sense

	jmp	$main_decode_loop$80
$LN43@stbi__hdr_:

; 6945 : 			}
; 6946 : 			len <<= 8;

	mov	eax, DWORD PTR _len$[ebp]
	shl	eax, 8
	mov	DWORD PTR _len$[ebp], eax

; 6947 : 			len |= stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	or	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 6948 : 			if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	je	SHORT $LN45@stbi__hdr_
	mov	esi, esp
	mov	eax, DWORD PTR _hdr_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _scanline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@stbi__hdr_
	mov	DWORD PTR tv244[ebp], 0
	jmp	SHORT $LN67@stbi__hdr_
$LN66@stbi__hdr_:
	mov	DWORD PTR tv244[ebp], 0
$LN67@stbi__hdr_:
	mov	eax, DWORD PTR tv244[ebp]
	jmp	$LN1@stbi__hdr_
$LN45@stbi__hdr_:

; 6949 : 			if (scanline == NULL) {

	cmp	DWORD PTR _scanline$[ebp], 0
	jne	SHORT $LN46@stbi__hdr_

; 6950 : 				scanline = (stbi_uc*)stbi__malloc_mad2(width, 4, 0);

	push	0
	push	4
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	?stbi__malloc_mad2@@YAPAXHHH@Z		; stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _scanline$[ebp], eax

; 6951 : 				if (!scanline) {

	cmp	DWORD PTR _scanline$[ebp], 0
	jne	SHORT $LN46@stbi__hdr_

; 6952 : 					STBI_FREE(hdr_data);

	mov	esi, esp
	mov	eax, DWORD PTR _hdr_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6953 : 					return stbi__errpf("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN68@stbi__hdr_
	mov	DWORD PTR tv255[ebp], 0
	jmp	SHORT $LN69@stbi__hdr_
$LN68@stbi__hdr_:
	mov	DWORD PTR tv255[ebp], 0
$LN69@stbi__hdr_:
	mov	eax, DWORD PTR tv255[ebp]
	jmp	$LN1@stbi__hdr_
$LN46@stbi__hdr_:

; 6954 : 				}
; 6955 : 			}
; 6956 : 
; 6957 : 			for (k = 0; k < 4; ++k) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN18@stbi__hdr_:
	cmp	DWORD PTR _k$[ebp], 4
	jge	$LN17@stbi__hdr_

; 6958 : 				int nleft;
; 6959 : 				i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN19@stbi__hdr_:

; 6960 : 				while ((nleft = width - i) > 0) {

	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _nleft$1[ebp], eax
	cmp	DWORD PTR _nleft$1[ebp], 0
	jle	$LN20@stbi__hdr_

; 6961 : 					count = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _count$[ebp], al

; 6962 : 					if (count > 128) {

	movzx	eax, BYTE PTR _count$[ebp]
	cmp	eax, 128				; 00000080H
	jle	$LN48@stbi__hdr_

; 6963 : 						// Run
; 6964 : 						value = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	BYTE PTR _value$[ebp], al

; 6965 : 						count -= 128;

	movzx	eax, BYTE PTR _count$[ebp]
	sub	eax, 128				; 00000080H
	mov	BYTE PTR _count$[ebp], al

; 6966 : 						if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	movzx	eax, BYTE PTR _count$[ebp]
	cmp	eax, DWORD PTR _nleft$1[ebp]
	jle	SHORT $LN50@stbi__hdr_
	mov	esi, esp
	mov	eax, DWORD PTR _hdr_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _scanline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_07DPPMCAKL@corrupt@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@stbi__hdr_
	mov	DWORD PTR tv276[ebp], 0
	jmp	SHORT $LN71@stbi__hdr_
$LN70@stbi__hdr_:
	mov	DWORD PTR tv276[ebp], 0
$LN71@stbi__hdr_:
	mov	eax, DWORD PTR tv276[ebp]
	jmp	$LN1@stbi__hdr_
$LN50@stbi__hdr_:

; 6967 : 						for (z = 0; z < count; ++z)

	mov	DWORD PTR _z$[ebp], 0
	jmp	SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
	mov	eax, DWORD PTR _z$[ebp]
	add	eax, 1
	mov	DWORD PTR _z$[ebp], eax
$LN23@stbi__hdr_:
	movzx	eax, BYTE PTR _count$[ebp]
	cmp	DWORD PTR _z$[ebp], eax
	jge	SHORT $LN22@stbi__hdr_

; 6968 : 							scanline[i++ * 4 + k] = value;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _scanline$[ebp]
	mov	cl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 6969 : 					}

	jmp	$LN49@stbi__hdr_
$LN48@stbi__hdr_:

; 6970 : 					else {
; 6971 : 						// Dump
; 6972 : 						if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

	movzx	eax, BYTE PTR _count$[ebp]
	cmp	eax, DWORD PTR _nleft$1[ebp]
	jle	SHORT $LN51@stbi__hdr_
	mov	esi, esp
	mov	eax, DWORD PTR _hdr_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR _scanline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_07DPPMCAKL@corrupt@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN72@stbi__hdr_
	mov	DWORD PTR tv292[ebp], 0
	jmp	SHORT $LN73@stbi__hdr_
$LN72@stbi__hdr_:
	mov	DWORD PTR tv292[ebp], 0
$LN73@stbi__hdr_:
	mov	eax, DWORD PTR tv292[ebp]
	jmp	$LN1@stbi__hdr_
$LN51@stbi__hdr_:

; 6973 : 						for (z = 0; z < count; ++z)

	mov	DWORD PTR _z$[ebp], 0
	jmp	SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
	mov	eax, DWORD PTR _z$[ebp]
	add	eax, 1
	mov	DWORD PTR _z$[ebp], eax
$LN26@stbi__hdr_:
	movzx	eax, BYTE PTR _count$[ebp]
	cmp	DWORD PTR _z$[ebp], eax
	jge	SHORT $LN49@stbi__hdr_

; 6974 : 							scanline[i++ * 4 + k] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _scanline$[ebp]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN24@stbi__hdr_
$LN49@stbi__hdr_:

; 6975 : 					}
; 6976 : 				}

	jmp	$LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 6977 : 			}

	jmp	$LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 6978 : 			for (i = 0; i < width; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN29@stbi__hdr_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jge	SHORT $LN28@stbi__hdr_

; 6979 : 				stbi__hdr_convert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _scanline$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR _width$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _req_comp$[ebp]
	mov	edx, DWORD PTR _hdr_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?stbi__hdr_convert@@YAXPAMPAEH@Z	; stbi__hdr_convert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 6980 : 		}

	jmp	$LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 6981 : 		if (scanline)

	cmp	DWORD PTR _scanline$[ebp], 0
	je	SHORT $LN41@stbi__hdr_

; 6982 : 			STBI_FREE(scanline);

	mov	esi, esp
	mov	eax, DWORD PTR _scanline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN41@stbi__hdr_:

; 6983 : 	}
; 6984 : 
; 6985 : 	return hdr_data;

	mov	eax, DWORD PTR _hdr_data$[ebp]
$LN1@stbi__hdr_:

; 6986 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN79@stbi__hdr_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1844				; 00000734H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN79@stbi__hdr_:
	DD	4
	DD	$LN78@stbi__hdr_
$LN78@stbi__hdr_:
	DD	-1032					; fffffbf8H
	DD	1024					; 00000400H
	DD	$LN74@stbi__hdr_
	DD	-1044					; fffffbecH
	DD	4
	DD	$LN75@stbi__hdr_
	DD	-1236					; fffffb2cH
	DD	4
	DD	$LN76@stbi__hdr_
	DD	-1248					; fffffb20H
	DD	4
	DD	$LN77@stbi__hdr_
$LN77@stbi__hdr_:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	0
$LN76@stbi__hdr_:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	0
$LN75@stbi__hdr_:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN74@stbi__hdr_:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?stbi__hdr_load@@YAPAMPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__hdr_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__hdr_test@@YAHPAUstbi__context@@@Z PROC		; stbi__hdr_test, COMDAT

; 6797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 6798 : 	int r = stbi__hdr_test_core(s, "#?RADIANCE\n");

	push	OFFSET ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test_core@@YAHPAUstbi__context@@PBD@Z ; stbi__hdr_test_core
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 6799 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 6800 : 	if (!r) {

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN2@stbi__hdr_

; 6801 : 		r = stbi__hdr_test_core(s, "#?RGBE\n");

	push	OFFSET ??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test_core@@YAHPAUstbi__context@@PBD@Z ; stbi__hdr_test_core
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 6802 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4
$LN2@stbi__hdr_:

; 6803 : 	}
; 6804 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 6805 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__hdr_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__psd_is16@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_depth$ = -20						; size = 4
_channelCount$ = -8					; size = 4
_s$ = 8							; size = 4
?stbi__psd_is16@@YAHPAUstbi__context@@@Z PROC		; stbi__psd_is16, COMDAT

; 7088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7089 : 	int channelCount, depth;
; 7090 : 	if (stbi__get32be(s) != 0x38425053) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN2@stbi__psd_

; 7091 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7092 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN2@stbi__psd_:

; 7093 : 	}
; 7094 : 	if (stbi__get16be(s) != 1) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN3@stbi__psd_

; 7095 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7096 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN3@stbi__psd_:

; 7097 : 	}
; 7098 : 	stbi__skip(s, 6);

	push	6
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 7099 : 	channelCount = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _channelCount$[ebp], eax

; 7100 : 	if (channelCount < 0 || channelCount > 16) {

	cmp	DWORD PTR _channelCount$[ebp], 0
	jl	SHORT $LN5@stbi__psd_
	cmp	DWORD PTR _channelCount$[ebp], 16	; 00000010H
	jle	SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 7101 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7102 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 7103 : 	}
; 7104 : 	(void)stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4

; 7105 : 	(void)stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4

; 7106 : 	depth = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _depth$[ebp], eax

; 7107 : 	if (depth != 16) {

	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	je	SHORT $LN6@stbi__psd_

; 7108 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7109 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7110 : 	}
; 7111 : 	return 1;

	mov	eax, 1
$LN1@stbi__psd_:

; 7112 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__psd_is16@@YAHPAUstbi__context@@@Z ENDP		; stbi__psd_is16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__psd_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_depth$ = -36						; size = 4
_dummy$ = -24						; size = 4
_channelCount$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__psd_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__psd_info, COMDAT

; 7053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7054 : 	int channelCount, dummy, depth;
; 7055 : 	if (!x) x = &dummy;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@stbi__psd_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN2@stbi__psd_:

; 7056 : 	if (!y) y = &dummy;

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN3@stbi__psd_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _y$[ebp], eax
$LN3@stbi__psd_:

; 7057 : 	if (!comp) comp = &dummy;

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $LN4@stbi__psd_
	lea	eax, DWORD PTR _dummy$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN4@stbi__psd_:

; 7058 : 	if (stbi__get32be(s) != 0x38425053) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN5@stbi__psd_

; 7059 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7060 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN5@stbi__psd_:

; 7061 : 	}
; 7062 : 	if (stbi__get16be(s) != 1) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN6@stbi__psd_

; 7063 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7064 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN6@stbi__psd_:

; 7065 : 	}
; 7066 : 	stbi__skip(s, 6);

	push	6
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 7067 : 	channelCount = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _channelCount$[ebp], eax

; 7068 : 	if (channelCount < 0 || channelCount > 16) {

	cmp	DWORD PTR _channelCount$[ebp], 0
	jl	SHORT $LN8@stbi__psd_
	cmp	DWORD PTR _channelCount$[ebp], 16	; 00000010H
	jle	SHORT $LN7@stbi__psd_
$LN8@stbi__psd_:

; 7069 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7070 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN7@stbi__psd_:

; 7071 : 	}
; 7072 : 	*y = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx], eax

; 7073 : 	*x = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], eax

; 7074 : 	depth = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _depth$[ebp], eax

; 7075 : 	if (depth != 8 && depth != 16) {

	cmp	DWORD PTR _depth$[ebp], 8
	je	SHORT $LN9@stbi__psd_
	cmp	DWORD PTR _depth$[ebp], 16		; 00000010H
	je	SHORT $LN9@stbi__psd_

; 7076 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7077 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN9@stbi__psd_:

; 7078 : 	}
; 7079 : 	if (stbi__get16be(s) != 3) {

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 3
	je	SHORT $LN10@stbi__psd_

; 7080 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7081 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN10@stbi__psd_:

; 7082 : 	}
; 7083 : 	*comp = 4;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax], 4

; 7084 : 	return 1;

	mov	eax, 1
$LN1@stbi__psd_:

; 7085 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@stbi__psd_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@stbi__psd_:
	DD	1
	DD	$LN13@stbi__psd_
$LN13@stbi__psd_:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN12@stbi__psd_
$LN12@stbi__psd_:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	0
?stbi__psd_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__psd_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__psd_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z
_TEXT	SEGMENT
tv227 = -484						; size = 4
tv220 = -484						; size = 4
tv211 = -484						; size = 4
tv200 = -484						; size = 4
tv185 = -484						; size = 4
tv167 = -484						; size = 4
tv157 = -484						; size = 4
tv138 = -484						; size = 4
tv131 = -484						; size = 4
tv87 = -484						; size = 4
tv77 = -484						; size = 4
tv70 = -484						; size = 4
_inv_a$1 = -284						; size = 4
_ra$2 = -272						; size = 4
_a$3 = -260						; size = 4
_pixel$4 = -248						; size = 4
_inv_a$5 = -236						; size = 4
_ra$6 = -224						; size = 4
_a$7 = -212						; size = 4
_pixel$8 = -200						; size = 4
_p$9 = -188						; size = 4
_q$10 = -176						; size = 4
_val$11 = -161						; size = 1
_p$12 = -152						; size = 4
_val$13 = -140						; size = 2
_q$14 = -128						; size = 4
_p$15 = -116						; size = 4
_out$ = -104						; size = 4
_h$ = -92						; size = 4
_w$ = -80						; size = 4
_bitdepth$ = -68					; size = 4
_i$ = -56						; size = 4
_channel$ = -44						; size = 4
_compression$ = -32					; size = 4
_channelCount$ = -20					; size = 4
_pixelCount$ = -8					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
_bpc$ = 32						; size = 4
?stbi__psd_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z PROC ; stbi__psd_load, COMDAT

; 5847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-484]
	mov	ecx, 121				; 00000079H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5848 : 	int pixelCount;
; 5849 : 	int channelCount, compression;
; 5850 : 	int channel, i;
; 5851 : 	int bitdepth;
; 5852 : 	int w, h;
; 5853 : 	stbi_uc* out;
; 5854 : 	STBI_NOTUSED(ri);
; 5855 : 
; 5856 : 	// Check identifier
; 5857 : 	if (stbi__get32be(s) != 0x38425053)   // "8BPS"

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN32@stbi__psd_

; 5858 : 		return stbi__errpuc("not PSD", "Corrupt PSD image");

	push	OFFSET ??_C@_07ECNCNLIK@not?5PSD@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN67@stbi__psd_
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN68@stbi__psd_
$LN67@stbi__psd_:
	mov	DWORD PTR tv70[ebp], 0
$LN68@stbi__psd_:
	mov	eax, DWORD PTR tv70[ebp]
	jmp	$LN1@stbi__psd_
$LN32@stbi__psd_:

; 5859 : 
; 5860 : 	// Check file type version.
; 5861 : 	if (stbi__get16be(s) != 1)

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 1
	je	SHORT $LN33@stbi__psd_

; 5862 : 		return stbi__errpuc("wrong version", "Unsupported version of PSD image");

	push	OFFSET ??_C@_0O@CHBCDKKC@wrong?5version@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN69@stbi__psd_
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN70@stbi__psd_
$LN69@stbi__psd_:
	mov	DWORD PTR tv77[ebp], 0
$LN70@stbi__psd_:
	mov	eax, DWORD PTR tv77[ebp]
	jmp	$LN1@stbi__psd_
$LN33@stbi__psd_:

; 5863 : 
; 5864 : 	// Skip 6 reserved bytes.
; 5865 : 	stbi__skip(s, 6);

	push	6
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5866 : 
; 5867 : 	// Read the number of channels (R, G, B, A, etc).
; 5868 : 	channelCount = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _channelCount$[ebp], eax

; 5869 : 	if (channelCount < 0 || channelCount > 16)

	cmp	DWORD PTR _channelCount$[ebp], 0
	jl	SHORT $LN35@stbi__psd_
	cmp	DWORD PTR _channelCount$[ebp], 16	; 00000010H
	jle	SHORT $LN34@stbi__psd_
$LN35@stbi__psd_:

; 5870 : 		return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

	push	OFFSET ??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN71@stbi__psd_
	mov	DWORD PTR tv87[ebp], 0
	jmp	SHORT $LN72@stbi__psd_
$LN71@stbi__psd_:
	mov	DWORD PTR tv87[ebp], 0
$LN72@stbi__psd_:
	mov	eax, DWORD PTR tv87[ebp]
	jmp	$LN1@stbi__psd_
$LN34@stbi__psd_:

; 5871 : 
; 5872 : 	// Read the rows and columns of the image.
; 5873 : 	h = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	DWORD PTR _h$[ebp], eax

; 5874 : 	w = stbi__get32be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	mov	DWORD PTR _w$[ebp], eax

; 5875 : 
; 5876 : 	// Make sure the depth is 8 bits.
; 5877 : 	bitdepth = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _bitdepth$[ebp], eax

; 5878 : 	if (bitdepth != 8 && bitdepth != 16)

	cmp	DWORD PTR _bitdepth$[ebp], 8
	je	SHORT $LN36@stbi__psd_
	cmp	DWORD PTR _bitdepth$[ebp], 16		; 00000010H
	je	SHORT $LN36@stbi__psd_

; 5879 : 		return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

	push	OFFSET ??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN73@stbi__psd_
	mov	DWORD PTR tv131[ebp], 0
	jmp	SHORT $LN74@stbi__psd_
$LN73@stbi__psd_:
	mov	DWORD PTR tv131[ebp], 0
$LN74@stbi__psd_:
	mov	eax, DWORD PTR tv131[ebp]
	jmp	$LN1@stbi__psd_
$LN36@stbi__psd_:

; 5880 : 
; 5881 : 	// Make sure the color mode is RGB.
; 5882 : 	// Valid options are:
; 5883 : 	//   0: Bitmap
; 5884 : 	//   1: Grayscale
; 5885 : 	//   2: Indexed color
; 5886 : 	//   3: RGB color
; 5887 : 	//   4: CMYK color
; 5888 : 	//   7: Multichannel
; 5889 : 	//   8: Duotone
; 5890 : 	//   9: Lab color
; 5891 : 	if (stbi__get16be(s) != 3)

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	cmp	eax, 3
	je	SHORT $LN37@stbi__psd_

; 5892 : 		return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

	push	OFFSET ??_C@_0BD@IOGGBMNK@wrong?5color?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN75@stbi__psd_
	mov	DWORD PTR tv138[ebp], 0
	jmp	SHORT $LN76@stbi__psd_
$LN75@stbi__psd_:
	mov	DWORD PTR tv138[ebp], 0
$LN76@stbi__psd_:
	mov	eax, DWORD PTR tv138[ebp]
	jmp	$LN1@stbi__psd_
$LN37@stbi__psd_:

; 5893 : 
; 5894 : 	// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 5895 : 	stbi__skip(s, stbi__get32be(s));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5896 : 
; 5897 : 	// Skip the image resources.  (resolution, pen tool paths, etc)
; 5898 : 	stbi__skip(s, stbi__get32be(s));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5899 : 
; 5900 : 	// Skip the reserved data.
; 5901 : 	stbi__skip(s, stbi__get32be(s));

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5902 : 
; 5903 : 	// Find out if the data is compressed.
; 5904 : 	// Known values:
; 5905 : 	//   0: no compression
; 5906 : 	//   1: RLE compressed
; 5907 : 	compression = stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	DWORD PTR _compression$[ebp], eax

; 5908 : 	if (compression > 1)

	cmp	DWORD PTR _compression$[ebp], 1
	jle	SHORT $LN38@stbi__psd_

; 5909 : 		return stbi__errpuc("bad compression", "PSD has an unknown compression format");

	push	OFFSET ??_C@_0BA@MCNBDLPD@bad?5compression@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN77@stbi__psd_
	mov	DWORD PTR tv157[ebp], 0
	jmp	SHORT $LN78@stbi__psd_
$LN77@stbi__psd_:
	mov	DWORD PTR tv157[ebp], 0
$LN78@stbi__psd_:
	mov	eax, DWORD PTR tv157[ebp]
	jmp	$LN1@stbi__psd_
$LN38@stbi__psd_:

; 5910 : 
; 5911 : 	// Check size
; 5912 : 	if (!stbi__mad3sizes_valid(4, w, h, 0))

	push	0
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	push	4
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN39@stbi__psd_

; 5913 : 		return stbi__errpuc("too large", "Corrupt PSD");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN79@stbi__psd_
	mov	DWORD PTR tv167[ebp], 0
	jmp	SHORT $LN80@stbi__psd_
$LN79@stbi__psd_:
	mov	DWORD PTR tv167[ebp], 0
$LN80@stbi__psd_:
	mov	eax, DWORD PTR tv167[ebp]
	jmp	$LN1@stbi__psd_
$LN39@stbi__psd_:

; 5914 : 
; 5915 : 	// Create the destination image.
; 5916 : 
; 5917 : 	if (!compression && bitdepth == 16 && bpc == 16) {

	cmp	DWORD PTR _compression$[ebp], 0
	jne	SHORT $LN40@stbi__psd_
	cmp	DWORD PTR _bitdepth$[ebp], 16		; 00000010H
	jne	SHORT $LN40@stbi__psd_
	cmp	DWORD PTR _bpc$[ebp], 16		; 00000010H
	jne	SHORT $LN40@stbi__psd_

; 5918 : 		out = (stbi_uc*)stbi__malloc_mad3(8, w, h, 0);

	push	0
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	push	8
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 5919 : 		ri->bits_per_channel = 16;

	mov	eax, DWORD PTR _ri$[ebp]
	mov	DWORD PTR [eax], 16			; 00000010H

; 5920 : 	}

	jmp	SHORT $LN41@stbi__psd_
$LN40@stbi__psd_:

; 5921 : 	else
; 5922 : 		out = (stbi_uc*)stbi__malloc(4 * w * h);

	mov	eax, DWORD PTR _w$[ebp]
	shl	eax, 2
	imul	eax, DWORD PTR _h$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _out$[ebp], eax
$LN41@stbi__psd_:

; 5923 : 
; 5924 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN42@stbi__psd_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN81@stbi__psd_
	mov	DWORD PTR tv185[ebp], 0
	jmp	SHORT $LN82@stbi__psd_
$LN81@stbi__psd_:
	mov	DWORD PTR tv185[ebp], 0
$LN82@stbi__psd_:
	mov	eax, DWORD PTR tv185[ebp]
	jmp	$LN1@stbi__psd_
$LN42@stbi__psd_:

; 5925 : 	pixelCount = w * h;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _pixelCount$[ebp], eax

; 5926 : 
; 5927 : 	// Initialize the data to zero.
; 5928 : 	//memset( out, 0, pixelCount * 4 );
; 5929 : 
; 5930 : 	// Finally, the image data.
; 5931 : 	if (compression) {

	cmp	DWORD PTR _compression$[ebp], 0
	je	$LN43@stbi__psd_

; 5932 : 		// RLE as used by .PSD and .TIFF
; 5933 : 		// Loop until you get the number of unpacked bytes you are expecting:
; 5934 : 		//     Read the next source byte into n.
; 5935 : 		//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 5936 : 		//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 5937 : 		//     Else if n is 128, noop.
; 5938 : 		// Endloop
; 5939 : 
; 5940 : 		// The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 5941 : 		// which we're going to just skip.
; 5942 : 		stbi__skip(s, h * channelCount * 2);

	mov	eax, DWORD PTR _h$[ebp]
	imul	eax, DWORD PTR _channelCount$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5943 : 
; 5944 : 		// Read the RLE data by channel.
; 5945 : 		for (channel = 0; channel < 4; channel++) {

	mov	DWORD PTR _channel$[ebp], 0
	jmp	SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
	mov	eax, DWORD PTR _channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _channel$[ebp], eax
$LN4@stbi__psd_:
	cmp	DWORD PTR _channel$[ebp], 4
	jge	$LN3@stbi__psd_

; 5946 : 			stbi_uc* p;
; 5947 : 
; 5948 : 			p = out + channel;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _channel$[ebp]
	mov	DWORD PTR _p$15[ebp], eax

; 5949 : 			if (channel >= channelCount) {

	mov	eax, DWORD PTR _channel$[ebp]
	cmp	eax, DWORD PTR _channelCount$[ebp]
	jl	SHORT $LN45@stbi__psd_

; 5950 : 				// Fill this channel with default data.
; 5951 : 				for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$15[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$15[ebp], ecx
$LN7@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN6@stbi__psd_

; 5952 : 					* p = (channel == 3 ? 255 : 0);

	cmp	DWORD PTR _channel$[ebp], 3
	jne	SHORT $LN83@stbi__psd_
	mov	DWORD PTR tv200[ebp], 255		; 000000ffH
	jmp	SHORT $LN84@stbi__psd_
$LN83@stbi__psd_:
	mov	DWORD PTR tv200[ebp], 0
$LN84@stbi__psd_:
	mov	eax, DWORD PTR _p$15[ebp]
	mov	cl, BYTE PTR tv200[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 5953 : 			}

	jmp	SHORT $LN47@stbi__psd_
$LN45@stbi__psd_:

; 5954 : 			else {
; 5955 : 				// Read the RLE data.
; 5956 : 				if (!stbi__psd_decode_rle(s, p, pixelCount)) {

	mov	eax, DWORD PTR _pixelCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__psd_decode_rle@@YAHPAUstbi__context@@PAEH@Z ; stbi__psd_decode_rle
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN47@stbi__psd_

; 5957 : 					STBI_FREE(out);

	mov	esi, esp
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5958 : 					return stbi__errpuc("corrupt", "bad RLE data");

	push	OFFSET ??_C@_07DPPMCAKL@corrupt@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN85@stbi__psd_
	mov	DWORD PTR tv211[ebp], 0
	jmp	SHORT $LN86@stbi__psd_
$LN85@stbi__psd_:
	mov	DWORD PTR tv211[ebp], 0
$LN86@stbi__psd_:
	mov	eax, DWORD PTR tv211[ebp]
	jmp	$LN1@stbi__psd_
$LN47@stbi__psd_:

; 5959 : 				}
; 5960 : 			}
; 5961 : 		}

	jmp	$LN2@stbi__psd_
$LN3@stbi__psd_:

; 5962 : 
; 5963 : 	}

	jmp	$LN9@stbi__psd_
$LN43@stbi__psd_:

; 5964 : 	else {
; 5965 : 		// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 5966 : 		// where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 5967 : 
; 5968 : 		// Read the data by channel.
; 5969 : 		for (channel = 0; channel < 4; channel++) {

	mov	DWORD PTR _channel$[ebp], 0
	jmp	SHORT $LN10@stbi__psd_
$LN8@stbi__psd_:
	mov	eax, DWORD PTR _channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _channel$[ebp], eax
$LN10@stbi__psd_:
	cmp	DWORD PTR _channel$[ebp], 4
	jge	$LN9@stbi__psd_

; 5970 : 			if (channel >= channelCount) {

	mov	eax, DWORD PTR _channel$[ebp]
	cmp	eax, DWORD PTR _channelCount$[ebp]
	jl	$LN48@stbi__psd_

; 5971 : 				// Fill this channel with default data.
; 5972 : 				if (bitdepth == 16 && bpc == 16) {

	cmp	DWORD PTR _bitdepth$[ebp], 16		; 00000010H
	jne	SHORT $LN50@stbi__psd_
	cmp	DWORD PTR _bpc$[ebp], 16		; 00000010H
	jne	SHORT $LN50@stbi__psd_

; 5973 : 					stbi__uint16* q = ((stbi__uint16*)out) + channel;

	mov	eax, DWORD PTR _channel$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _q$14[ebp], edx

; 5974 : 					stbi__uint16 val = channel == 3 ? 65535 : 0;

	cmp	DWORD PTR _channel$[ebp], 3
	jne	SHORT $LN87@stbi__psd_
	mov	DWORD PTR tv220[ebp], 65535		; 0000ffffH
	jmp	SHORT $LN88@stbi__psd_
$LN87@stbi__psd_:
	mov	DWORD PTR tv220[ebp], 0
$LN88@stbi__psd_:
	mov	ax, WORD PTR tv220[ebp]
	mov	WORD PTR _val$13[ebp], ax

; 5975 : 					for (i = 0; i < pixelCount; i++, q += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@stbi__psd_
$LN11@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _q$14[ebp]
	add	ecx, 8
	mov	DWORD PTR _q$14[ebp], ecx
$LN13@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN12@stbi__psd_

; 5976 : 						* q = val;

	mov	eax, DWORD PTR _q$14[ebp]
	mov	cx, WORD PTR _val$13[ebp]
	mov	WORD PTR [eax], cx
	jmp	SHORT $LN11@stbi__psd_
$LN12@stbi__psd_:

; 5977 : 				}

	jmp	SHORT $LN15@stbi__psd_
$LN50@stbi__psd_:

; 5978 : 				else {
; 5979 : 					stbi_uc* p = out + channel;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _channel$[ebp]
	mov	DWORD PTR _p$12[ebp], eax

; 5980 : 					stbi_uc val = channel == 3 ? 255 : 0;

	cmp	DWORD PTR _channel$[ebp], 3
	jne	SHORT $LN89@stbi__psd_
	mov	DWORD PTR tv227[ebp], 255		; 000000ffH
	jmp	SHORT $LN90@stbi__psd_
$LN89@stbi__psd_:
	mov	DWORD PTR tv227[ebp], 0
$LN90@stbi__psd_:
	mov	al, BYTE PTR tv227[ebp]
	mov	BYTE PTR _val$11[ebp], al

; 5981 : 					for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$12[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$12[ebp], ecx
$LN16@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN15@stbi__psd_

; 5982 : 						* p = val;

	mov	eax, DWORD PTR _p$12[ebp]
	mov	cl, BYTE PTR _val$11[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN14@stbi__psd_
$LN15@stbi__psd_:

; 5983 : 				}
; 5984 : 			}

	jmp	$LN24@stbi__psd_
$LN48@stbi__psd_:

; 5985 : 			else {
; 5986 : 				if (ri->bits_per_channel == 16) {    // output bpc

	mov	eax, DWORD PTR _ri$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $LN52@stbi__psd_

; 5987 : 					stbi__uint16* q = ((stbi__uint16*)out) + channel;

	mov	eax, DWORD PTR _channel$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _q$10[ebp], edx

; 5988 : 					for (i = 0; i < pixelCount; i++, q += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _q$10[ebp]
	add	ecx, 8
	mov	DWORD PTR _q$10[ebp], ecx
$LN19@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN18@stbi__psd_

; 5989 : 						* q = (stbi__uint16)stbi__get16be(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	mov	ecx, DWORD PTR _q$10[ebp]
	mov	WORD PTR [ecx], ax
	jmp	SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 5990 : 				}

	jmp	$LN24@stbi__psd_
$LN52@stbi__psd_:

; 5991 : 				else {
; 5992 : 					stbi_uc* p = out + channel;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _channel$[ebp]
	mov	DWORD PTR _p$9[ebp], eax

; 5993 : 					if (bitdepth == 16) {  // input bpc

	cmp	DWORD PTR _bitdepth$[ebp], 16		; 00000010H
	jne	SHORT $LN54@stbi__psd_

; 5994 : 						for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$9[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$9[ebp], ecx
$LN22@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN21@stbi__psd_

; 5995 : 							* p = (stbi_uc)(stbi__get16be(s) >> 8);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16be@@YAHPAUstbi__context@@@Z	; stbi__get16be
	add	esp, 4
	sar	eax, 8
	mov	ecx, DWORD PTR _p$9[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 5996 : 					}

	jmp	SHORT $LN24@stbi__psd_
$LN54@stbi__psd_:

; 5997 : 					else {
; 5998 : 						for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$9[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$9[ebp], ecx
$LN25@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _pixelCount$[ebp]
	jge	SHORT $LN24@stbi__psd_

; 5999 : 							* p = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _p$9[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN23@stbi__psd_
$LN24@stbi__psd_:

; 6000 : 					}
; 6001 : 				}
; 6002 : 			}
; 6003 : 		}

	jmp	$LN8@stbi__psd_
$LN9@stbi__psd_:

; 6004 : 	}
; 6005 : 
; 6006 : 	// remove weird white matte from PSD
; 6007 : 	if (channelCount >= 4) {

	cmp	DWORD PTR _channelCount$[ebp], 4
	jl	$LN30@stbi__psd_

; 6008 : 		if (ri->bits_per_channel == 16) {

	mov	eax, DWORD PTR _ri$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	$LN57@stbi__psd_

; 6009 : 			for (i = 0; i < w * h; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN28@stbi__psd_
$LN26@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN28@stbi__psd_:
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN27@stbi__psd_

; 6010 : 				stbi__uint16* pixel = (stbi__uint16*)out + 4 * i;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pixel$8[ebp], edx

; 6011 : 				if (pixel[3] != 0 && pixel[3] != 65535) {

	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$8[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	je	$LN59@stbi__psd_
	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$8[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	cmp	eax, 65535				; 0000ffffH
	je	$LN59@stbi__psd_

; 6012 : 					float a = pixel[3] / 65535.0f;

	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$8[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR _a$7[ebp], xmm0

; 6013 : 					float ra = 1.0f / a;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _a$7[ebp]
	movss	DWORD PTR _ra$6[ebp], xmm0

; 6014 : 					float inv_a = 65535.0f * (1 - ra);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _ra$6[ebp]
	mulss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR _inv_a$5[ebp], xmm0

; 6015 : 					pixel[0] = (stbi__uint16)(pixel[0] * ra + inv_a);

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pixel$8[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _ra$6[ebp]
	addss	xmm0, DWORD PTR _inv_a$5[ebp]
	cvttss2si ecx, xmm0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pixel$8[ebp]
	mov	WORD PTR [edx+eax], cx

; 6016 : 					pixel[1] = (stbi__uint16)(pixel[1] * ra + inv_a);

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _pixel$8[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _ra$6[ebp]
	addss	xmm0, DWORD PTR _inv_a$5[ebp]
	cvttss2si eax, xmm0
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _pixel$8[ebp]
	mov	WORD PTR [edx+ecx], ax

; 6017 : 					pixel[2] = (stbi__uint16)(pixel[2] * ra + inv_a);

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _pixel$8[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _ra$6[ebp]
	addss	xmm0, DWORD PTR _inv_a$5[ebp]
	cvttss2si eax, xmm0
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _pixel$8[ebp]
	mov	WORD PTR [edx+ecx], ax
$LN59@stbi__psd_:

; 6018 : 				}
; 6019 : 			}

	jmp	$LN26@stbi__psd_
$LN27@stbi__psd_:

; 6020 : 		}

	jmp	$LN30@stbi__psd_
$LN57@stbi__psd_:

; 6021 : 		else {
; 6022 : 			for (i = 0; i < w * h; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@stbi__psd_
$LN29@stbi__psd_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN31@stbi__psd_:
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN30@stbi__psd_

; 6023 : 				unsigned char* pixel = out + 4 * i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pixel$4[ebp], edx

; 6024 : 				if (pixel[3] != 0 && pixel[3] != 255) {

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN60@stbi__psd_
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 255				; 000000ffH
	je	$LN60@stbi__psd_

; 6025 : 					float a = pixel[3] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _a$3[ebp], xmm0

; 6026 : 					float ra = 1.0f / a;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _a$3[ebp]
	movss	DWORD PTR _ra$2[ebp], xmm0

; 6027 : 					float inv_a = 255.0f * (1 - ra);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _ra$2[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _inv_a$1[ebp], xmm0

; 6028 : 					pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pixel$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _ra$2[ebp]
	addss	xmm0, DWORD PTR _inv_a$1[ebp]
	cvttss2si ecx, xmm0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pixel$4[ebp]
	mov	BYTE PTR [edx+eax], cl

; 6029 : 					pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pixel$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _ra$2[ebp]
	addss	xmm0, DWORD PTR _inv_a$1[ebp]
	cvttss2si eax, xmm0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pixel$4[ebp]
	mov	BYTE PTR [edx+ecx], al

; 6030 : 					pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pixel$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _ra$2[ebp]
	addss	xmm0, DWORD PTR _inv_a$1[ebp]
	cvttss2si eax, xmm0
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pixel$4[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN60@stbi__psd_:

; 6031 : 				}
; 6032 : 			}

	jmp	$LN29@stbi__psd_
$LN30@stbi__psd_:

; 6033 : 		}
; 6034 : 	}
; 6035 : 
; 6036 : 	// convert to desired output format
; 6037 : 	if (req_comp && req_comp != 4) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN64@stbi__psd_
	cmp	DWORD PTR _req_comp$[ebp], 4
	je	SHORT $LN64@stbi__psd_

; 6038 : 		if (ri->bits_per_channel == 16)

	mov	eax, DWORD PTR _ri$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $LN62@stbi__psd_

; 6039 : 			out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, 4, req_comp, w, h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?stbi__convert_format16@@YAPAGPAGHHII@Z	; stbi__convert_format16
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	jmp	SHORT $LN63@stbi__psd_
$LN62@stbi__psd_:

; 6040 : 		else
; 6041 : 			out = stbi__convert_format(out, 4, req_comp, w, h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
$LN63@stbi__psd_:

; 6042 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN64@stbi__psd_
	mov	eax, DWORD PTR _out$[ebp]
	jmp	SHORT $LN1@stbi__psd_
$LN64@stbi__psd_:

; 6043 : 	}
; 6044 : 
; 6045 : 	if (comp)* comp = 4;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN65@stbi__psd_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [eax], 4
$LN65@stbi__psd_:

; 6046 : 	*y = h;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 6047 : 	*x = w;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax], ecx

; 6048 : 
; 6049 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@stbi__psd_:

; 6050 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 484				; 000001e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__psd_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@H@Z ENDP ; stbi__psd_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__psd_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
tv67 = -208						; size = 4
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__psd_test@@YAHPAUstbi__context@@@Z PROC		; stbi__psd_test, COMDAT

; 5800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5801 : 	int r = (stbi__get32be(s) == 0x38425053);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get32be@@YAIPAUstbi__context@@@Z	; stbi__get32be
	add	esp, 4
	cmp	eax, 943870035				; 38425053H
	jne	SHORT $LN3@stbi__psd_
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
	mov	DWORD PTR tv67[ebp], 0
$LN4@stbi__psd_:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], ecx

; 5802 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5803 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 5804 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__psd_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__psd_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__tga_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
tv153 = -292						; size = 4
_tga_colormap_type$ = -92				; size = 4
_sz$ = -80						; size = 4
_tga_colormap_bpp$ = -68				; size = 4
_tga_bits_per_pixel$ = -56				; size = 4
_tga_image_type$ = -44					; size = 4
_tga_comp$ = -32					; size = 4
_tga_h$ = -20						; size = 4
_tga_w$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__tga_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__tga_info, COMDAT

; 5476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5477 : 	int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5478 : 	int sz, tga_colormap_type;
; 5479 : 	stbi__get8(s);                   // discard Offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4

; 5480 : 	tga_colormap_type = stbi__get8(s); // colormap type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_colormap_type$[ebp], ecx

; 5481 : 	if (tga_colormap_type > 1) {

	cmp	DWORD PTR _tga_colormap_type$[ebp], 1
	jle	SHORT $LN2@stbi__tga_

; 5482 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5483 : 		return 0;      // only RGB or indexed allowed

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN2@stbi__tga_:

; 5484 : 	}
; 5485 : 	tga_image_type = stbi__get8(s); // image type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_image_type$[ebp], ecx

; 5486 : 	if (tga_colormap_type == 1) { // colormapped (paletted) image

	cmp	DWORD PTR _tga_colormap_type$[ebp], 1
	jne	$LN3@stbi__tga_

; 5487 : 		if (tga_image_type != 1 && tga_image_type != 9) {

	cmp	DWORD PTR _tga_image_type$[ebp], 1
	je	SHORT $LN5@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 9
	je	SHORT $LN5@stbi__tga_

; 5488 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5489 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN5@stbi__tga_:

; 5490 : 		}
; 5491 : 		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5492 : 		sz = stbi__get8(s);    //   check bits per palette color entry

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5493 : 		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN6@stbi__tga_

; 5494 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5495 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN6@stbi__tga_:

; 5496 : 		}
; 5497 : 		stbi__skip(s, 4);       // skip image x and y origin

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5498 : 		tga_colormap_bpp = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _tga_colormap_bpp$[ebp], eax

; 5499 : 	}

	jmp	SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5500 : 	else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
; 5501 : 		if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {

	cmp	DWORD PTR _tga_image_type$[ebp], 2
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 3
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 10	; 0000000aH
	je	SHORT $LN7@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 11	; 0000000bH
	je	SHORT $LN7@stbi__tga_

; 5502 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5503 : 			return 0; // only RGB or grey allowed, +/- RLE

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN7@stbi__tga_:

; 5504 : 		}
; 5505 : 		stbi__skip(s, 9); // skip colormap specification and image x/y origin

	push	9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5506 : 		tga_colormap_bpp = 0;

	mov	DWORD PTR _tga_colormap_bpp$[ebp], 0
$LN4@stbi__tga_:

; 5507 : 	}
; 5508 : 	tga_w = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_w$[ebp], eax

; 5509 : 	if (tga_w < 1) {

	cmp	DWORD PTR _tga_w$[ebp], 1
	jge	SHORT $LN8@stbi__tga_

; 5510 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5511 : 		return 0;   // test width

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN8@stbi__tga_:

; 5512 : 	}
; 5513 : 	tga_h = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_h$[ebp], eax

; 5514 : 	if (tga_h < 1) {

	cmp	DWORD PTR _tga_h$[ebp], 1
	jge	SHORT $LN9@stbi__tga_

; 5515 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5516 : 		return 0;   // test height

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN9@stbi__tga_:

; 5517 : 	}
; 5518 : 	tga_bits_per_pixel = stbi__get8(s); // bits per pixel

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_bits_per_pixel$[ebp], ecx

; 5519 : 	stbi__get8(s); // ignore alpha bits

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4

; 5520 : 	if (tga_colormap_bpp != 0) {

	cmp	DWORD PTR _tga_colormap_bpp$[ebp], 0
	je	SHORT $LN10@stbi__tga_

; 5521 : 		if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 8
	je	SHORT $LN12@stbi__tga_
	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 16	; 00000010H
	je	SHORT $LN12@stbi__tga_

; 5522 : 			// when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5523 : 			// I don't think anything but 8 or 16bit indexes makes sense
; 5524 : 			stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5525 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN12@stbi__tga_:

; 5526 : 		}
; 5527 : 		tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _tga_colormap_bpp$[ebp]
	push	eax
	call	?stbi__tga_get_comp@@YAHHHPAH@Z		; stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax

; 5528 : 	}

	jmp	SHORT $LN11@stbi__tga_
$LN10@stbi__tga_:

; 5529 : 	else {
; 5530 : 		tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

	cmp	DWORD PTR _tga_image_type$[ebp], 3
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _tga_image_type$[ebp], 11	; 0000000bH
	je	SHORT $LN18@stbi__tga_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
	mov	DWORD PTR tv153[ebp], 1
$LN19@stbi__tga_:
	push	0
	mov	eax, DWORD PTR tv153[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_bits_per_pixel$[ebp]
	push	ecx
	call	?stbi__tga_get_comp@@YAHHHPAH@Z		; stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
$LN11@stbi__tga_:

; 5531 : 	}
; 5532 : 	if (!tga_comp) {

	cmp	DWORD PTR _tga_comp$[ebp], 0
	jne	SHORT $LN13@stbi__tga_

; 5533 : 		stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5534 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__tga_
$LN13@stbi__tga_:

; 5535 : 	}
; 5536 : 	if (x)* x = tga_w;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN14@stbi__tga_
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _tga_w$[ebp]
	mov	DWORD PTR [eax], ecx
$LN14@stbi__tga_:

; 5537 : 	if (y)* y = tga_h;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN15@stbi__tga_
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tga_h$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@stbi__tga_:

; 5538 : 	if (comp)* comp = tga_comp;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN16@stbi__tga_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN16@stbi__tga_:

; 5539 : 	return 1;                   // seems to have passed everything

	mov	eax, 1
$LN1@stbi__tga_:

; 5540 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__tga_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__tga_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv278 = -596						; size = 4
tv257 = -596						; size = 4
tv201 = -596						; size = 4
tv181 = -596						; size = 4
tv170 = -596						; size = 4
tv160 = -596						; size = 4
tv149 = -596						; size = 4
tv142 = -596						; size = 4
_temp$1 = -393						; size = 1
_tga_pixel$2 = -384					; size = 4
_temp$3 = -369						; size = 1
_index2$4 = -360					; size = 4
_index1$5 = -348					; size = 4
_pal_idx$6 = -336					; size = 4
_RLE_cmd$7 = -324					; size = 4
_pal_entry$8 = -312					; size = 4
_tga_row$9 = -300					; size = 4
_row$10 = -288						; size = 4
_read_next_pixel$ = -276				; size = 4
_RLE_repeating$ = -264					; size = 4
_RLE_count$ = -252					; size = 4
_raw_data$ = -240					; size = 4
_j$ = -228						; size = 4
_i$ = -216						; size = 4
_tga_palette$ = -204					; size = 4
_tga_data$ = -192					; size = 4
_tga_inverted$ = -180					; size = 4
_tga_rgb16$ = -168					; size = 4
_tga_comp$ = -156					; size = 4
_tga_bits_per_pixel$ = -144				; size = 4
_tga_height$ = -132					; size = 4
_tga_width$ = -120					; size = 4
_tga_y_origin$ = -108					; size = 4
_tga_x_origin$ = -96					; size = 4
_tga_palette_bits$ = -84				; size = 4
_tga_palette_len$ = -72					; size = 4
_tga_palette_start$ = -60				; size = 4
_tga_is_RLE$ = -48					; size = 4
_tga_image_type$ = -36					; size = 4
_tga_indexed$ = -24					; size = 4
_tga_offset$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__tga_load, COMDAT

; 5595 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-596]
	mov	ecx, 149				; 00000095H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5596 : 	//   read in the TGA header stuff
; 5597 : 	int tga_offset = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_offset$[ebp], ecx

; 5598 : 	int tga_indexed = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_indexed$[ebp], ecx

; 5599 : 	int tga_image_type = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_image_type$[ebp], ecx

; 5600 : 	int tga_is_RLE = 0;

	mov	DWORD PTR _tga_is_RLE$[ebp], 0

; 5601 : 	int tga_palette_start = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_palette_start$[ebp], eax

; 5602 : 	int tga_palette_len = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_palette_len$[ebp], eax

; 5603 : 	int tga_palette_bits = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_palette_bits$[ebp], ecx

; 5604 : 	int tga_x_origin = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_x_origin$[ebp], eax

; 5605 : 	int tga_y_origin = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_y_origin$[ebp], eax

; 5606 : 	int tga_width = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_width$[ebp], eax

; 5607 : 	int tga_height = stbi__get16le(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR _tga_height$[ebp], eax

; 5608 : 	int tga_bits_per_pixel = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_bits_per_pixel$[ebp], ecx

; 5609 : 	int tga_comp, tga_rgb16 = 0;

	mov	DWORD PTR _tga_rgb16$[ebp], 0

; 5610 : 	int tga_inverted = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_inverted$[ebp], ecx

; 5611 : 	// int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5612 : 	//   image data
; 5613 : 	unsigned char* tga_data;
; 5614 : 	unsigned char* tga_palette = NULL;

	mov	DWORD PTR _tga_palette$[ebp], 0

; 5615 : 	int i, j;
; 5616 : 	unsigned char raw_data[4] = { 0 };

	xor	eax, eax
	mov	DWORD PTR _raw_data$[ebp], eax

; 5617 : 	int RLE_count = 0;

	mov	DWORD PTR _RLE_count$[ebp], 0

; 5618 : 	int RLE_repeating = 0;

	mov	DWORD PTR _RLE_repeating$[ebp], 0

; 5619 : 	int read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1

; 5620 : 	STBI_NOTUSED(ri);
; 5621 : 
; 5622 : 	//   do a tiny bit of precessing
; 5623 : 	if (tga_image_type >= 8)

	cmp	DWORD PTR _tga_image_type$[ebp], 8
	jl	SHORT $LN29@stbi__tga_

; 5624 : 	{
; 5625 : 		tga_image_type -= 8;

	mov	eax, DWORD PTR _tga_image_type$[ebp]
	sub	eax, 8
	mov	DWORD PTR _tga_image_type$[ebp], eax

; 5626 : 		tga_is_RLE = 1;

	mov	DWORD PTR _tga_is_RLE$[ebp], 1
$LN29@stbi__tga_:

; 5627 : 	}
; 5628 : 	tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	mov	eax, DWORD PTR _tga_inverted$[ebp]
	sar	eax, 5
	and	eax, 1
	mov	ecx, 1
	sub	ecx, eax
	mov	DWORD PTR _tga_inverted$[ebp], ecx

; 5629 : 
; 5630 : 	//   If I'm paletted, then I'll use the number of bits from the palette
; 5631 : 	if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	SHORT $LN30@stbi__tga_
	lea	eax, DWORD PTR _tga_rgb16$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _tga_palette_bits$[ebp]
	push	ecx
	call	?stbi__tga_get_comp@@YAHHHPAH@Z		; stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
	jmp	SHORT $LN31@stbi__tga_
$LN30@stbi__tga_:

; 5632 : 	else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

	cmp	DWORD PTR _tga_image_type$[ebp], 3
	jne	SHORT $LN59@stbi__tga_
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN60@stbi__tga_
$LN59@stbi__tga_:
	mov	DWORD PTR tv142[ebp], 0
$LN60@stbi__tga_:
	lea	eax, DWORD PTR _tga_rgb16$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv142[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_bits_per_pixel$[ebp]
	push	edx
	call	?stbi__tga_get_comp@@YAHHHPAH@Z		; stbi__tga_get_comp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_comp$[ebp], eax
$LN31@stbi__tga_:

; 5633 : 
; 5634 : 	if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

	cmp	DWORD PTR _tga_comp$[ebp], 0
	jne	SHORT $LN32@stbi__tga_

; 5635 : 		return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

	push	OFFSET ??_C@_0L@DMAPJJO@bad?5format@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@stbi__tga_
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN62@stbi__tga_
$LN61@stbi__tga_:
	mov	DWORD PTR tv149[ebp], 0
$LN62@stbi__tga_:
	mov	eax, DWORD PTR tv149[ebp]
	jmp	$LN1@stbi__tga_
$LN32@stbi__tga_:

; 5636 : 
; 5637 : 	//   tga info
; 5638 : 	*x = tga_width;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _tga_width$[ebp]
	mov	DWORD PTR [eax], ecx

; 5639 : 	*y = tga_height;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tga_height$[ebp]
	mov	DWORD PTR [eax], ecx

; 5640 : 	if (comp)* comp = tga_comp;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN33@stbi__tga_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN33@stbi__tga_:

; 5641 : 
; 5642 : 	if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_width$[ebp]
	push	edx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN34@stbi__tga_

; 5643 : 		return stbi__errpuc("too large", "Corrupt TGA");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN63@stbi__tga_
	mov	DWORD PTR tv160[ebp], 0
	jmp	SHORT $LN64@stbi__tga_
$LN63@stbi__tga_:
	mov	DWORD PTR tv160[ebp], 0
$LN64@stbi__tga_:
	mov	eax, DWORD PTR tv160[ebp]
	jmp	$LN1@stbi__tga_
$LN34@stbi__tga_:

; 5644 : 
; 5645 : 	tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tga_width$[ebp]
	push	edx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tga_data$[ebp], eax

; 5646 : 	if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _tga_data$[ebp], 0
	jne	SHORT $LN35@stbi__tga_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN65@stbi__tga_
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN66@stbi__tga_
$LN65@stbi__tga_:
	mov	DWORD PTR tv170[ebp], 0
$LN66@stbi__tga_:
	mov	eax, DWORD PTR tv170[ebp]
	jmp	$LN1@stbi__tga_
$LN35@stbi__tga_:

; 5647 : 
; 5648 : 	// skip to the data's starting position (offset usually = 0)
; 5649 : 	stbi__skip(s, tga_offset);

	mov	eax, DWORD PTR _tga_offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5650 : 
; 5651 : 	if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	jne	$LN36@stbi__tga_
	cmp	DWORD PTR _tga_is_RLE$[ebp], 0
	jne	$LN36@stbi__tga_
	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	jne	$LN36@stbi__tga_

; 5652 : 		for (i = 0; i < tga_height; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tga_height$[ebp]
	jge	SHORT $LN3@stbi__tga_

; 5653 : 			int row = tga_inverted ? tga_height - i - 1 : i;

	cmp	DWORD PTR _tga_inverted$[ebp], 0
	je	SHORT $LN67@stbi__tga_
	mov	eax, DWORD PTR _tga_height$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv181[ebp], eax
	jmp	SHORT $LN68@stbi__tga_
$LN67@stbi__tga_:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv181[ebp], ecx
$LN68@stbi__tga_:
	mov	edx, DWORD PTR tv181[ebp]
	mov	DWORD PTR _row$10[ebp], edx

; 5654 : 			stbi_uc* tga_row = tga_data + row * tga_width * tga_comp;

	mov	eax, DWORD PTR _row$10[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	add	eax, DWORD PTR _tga_data$[ebp]
	mov	DWORD PTR _tga_row$9[ebp], eax

; 5655 : 			stbi__getn(s, tga_row, tga_width * tga_comp);

	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_row$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ; stbi__getn
	add	esp, 12					; 0000000cH

; 5656 : 		}

	jmp	$LN2@stbi__tga_
$LN3@stbi__tga_:

; 5657 : 	}

	jmp	$LN37@stbi__tga_
$LN36@stbi__tga_:

; 5658 : 	else {
; 5659 : 		//   do I need to load a palette?
; 5660 : 		if (tga_indexed)

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	$LN38@stbi__tga_

; 5661 : 		{
; 5662 : 			//   any data to skip? (offset usually = 0)
; 5663 : 			stbi__skip(s, tga_palette_start);

	mov	eax, DWORD PTR _tga_palette_start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5664 : 			//   load the palette
; 5665 : 			tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

	push	0
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_palette_len$[ebp]
	push	ecx
	call	?stbi__malloc_mad2@@YAPAXHHH@Z		; stbi__malloc_mad2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tga_palette$[ebp], eax

; 5666 : 			if (!tga_palette) {

	cmp	DWORD PTR _tga_palette$[ebp], 0
	jne	SHORT $LN39@stbi__tga_

; 5667 : 				STBI_FREE(tga_data);

	mov	esi, esp
	mov	eax, DWORD PTR _tga_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5668 : 				return stbi__errpuc("outofmem", "Out of memory");

	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN69@stbi__tga_
	mov	DWORD PTR tv201[ebp], 0
	jmp	SHORT $LN70@stbi__tga_
$LN69@stbi__tga_:
	mov	DWORD PTR tv201[ebp], 0
$LN70@stbi__tga_:
	mov	eax, DWORD PTR tv201[ebp]
	jmp	$LN1@stbi__tga_
$LN39@stbi__tga_:

; 5669 : 			}
; 5670 : 			if (tga_rgb16) {

	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	je	$LN40@stbi__tga_

; 5671 : 				stbi_uc* pal_entry = tga_palette;

	mov	eax, DWORD PTR _tga_palette$[ebp]
	mov	DWORD PTR _pal_entry$8[ebp], eax

; 5672 : 				STBI_ASSERT(tga_comp == STBI_rgb);

	cmp	DWORD PTR _tga_comp$[ebp], 3
	je	SHORT $LN71@stbi__tga_
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z@4JA
	add	eax, 77					; 0000004dH
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN71@stbi__tga_:

; 5673 : 				for (i = 0; i < tga_palette_len; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tga_palette_len$[ebp]
	jge	SHORT $LN6@stbi__tga_

; 5674 : 					stbi__tga_read_rgb16(s, pal_entry);

	mov	eax, DWORD PTR _pal_entry$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__tga_read_rgb16@@YAXPAUstbi__context@@PAE@Z ; stbi__tga_read_rgb16
	add	esp, 8

; 5675 : 					pal_entry += tga_comp;

	mov	eax, DWORD PTR _pal_entry$8[ebp]
	add	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _pal_entry$8[ebp], eax

; 5676 : 				}

	jmp	SHORT $LN5@stbi__tga_
$LN6@stbi__tga_:

; 5677 : 			}

	jmp	$LN38@stbi__tga_
$LN40@stbi__tga_:

; 5678 : 			else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

	mov	eax, DWORD PTR _tga_palette_len$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_palette$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__getn@@YAHPAUstbi__context@@PAEH@Z ; stbi__getn
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN38@stbi__tga_

; 5679 : 				STBI_FREE(tga_data);

	mov	esi, esp
	mov	eax, DWORD PTR _tga_data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5680 : 				STBI_FREE(tga_palette);

	mov	esi, esp
	mov	eax, DWORD PTR _tga_palette$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5681 : 				return stbi__errpuc("bad palette", "Corrupt TGA");

	push	OFFSET ??_C@_0M@ILLOCNCO@bad?5palette@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN72@stbi__tga_
	mov	DWORD PTR tv257[ebp], 0
	jmp	SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
	mov	DWORD PTR tv257[ebp], 0
$LN73@stbi__tga_:
	mov	eax, DWORD PTR tv257[ebp]
	jmp	$LN1@stbi__tga_
$LN38@stbi__tga_:

; 5682 : 			}
; 5683 : 		}
; 5684 : 		//   load the data
; 5685 : 		for (i = 0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__tga_:
	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN9@stbi__tga_

; 5686 : 		{
; 5687 : 			//   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5688 : 			if (tga_is_RLE)

	cmp	DWORD PTR _tga_is_RLE$[ebp], 0
	je	SHORT $LN43@stbi__tga_

; 5689 : 			{
; 5690 : 				if (RLE_count == 0)

	cmp	DWORD PTR _RLE_count$[ebp], 0
	jne	SHORT $LN45@stbi__tga_

; 5691 : 				{
; 5692 : 					//   yep, get the next byte as a RLE command
; 5693 : 					int RLE_cmd = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _RLE_cmd$7[ebp], ecx

; 5694 : 					RLE_count = 1 + (RLE_cmd & 127);

	mov	eax, DWORD PTR _RLE_cmd$7[ebp]
	and	eax, 127				; 0000007fH
	add	eax, 1
	mov	DWORD PTR _RLE_count$[ebp], eax

; 5695 : 					RLE_repeating = RLE_cmd >> 7;

	mov	eax, DWORD PTR _RLE_cmd$7[ebp]
	sar	eax, 7
	mov	DWORD PTR _RLE_repeating$[ebp], eax

; 5696 : 					read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1

; 5697 : 				}

	jmp	SHORT $LN46@stbi__tga_
$LN45@stbi__tga_:

; 5698 : 				else if (!RLE_repeating)

	cmp	DWORD PTR _RLE_repeating$[ebp], 0
	jne	SHORT $LN46@stbi__tga_

; 5699 : 				{
; 5700 : 					read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1
$LN46@stbi__tga_:

; 5701 : 				}
; 5702 : 			}

	jmp	SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:

; 5703 : 			else
; 5704 : 			{
; 5705 : 				read_next_pixel = 1;

	mov	DWORD PTR _read_next_pixel$[ebp], 1
$LN44@stbi__tga_:

; 5706 : 			}
; 5707 : 			//   OK, if I need to read a pixel, do it now
; 5708 : 			if (read_next_pixel)

	cmp	DWORD PTR _read_next_pixel$[ebp], 0
	je	$LN48@stbi__tga_

; 5709 : 			{
; 5710 : 				//   load however much data we did have
; 5711 : 				if (tga_indexed)

	cmp	DWORD PTR _tga_indexed$[ebp], 0
	je	$LN49@stbi__tga_

; 5712 : 				{
; 5713 : 					// read in index, then perform the lookup
; 5714 : 					int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

	cmp	DWORD PTR _tga_bits_per_pixel$[ebp], 8
	jne	SHORT $LN74@stbi__tga_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv278[ebp], ecx
	jmp	SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR tv278[ebp], eax
$LN75@stbi__tga_:
	mov	eax, DWORD PTR tv278[ebp]
	mov	DWORD PTR _pal_idx$6[ebp], eax

; 5715 : 					if (pal_idx >= tga_palette_len) {

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	cmp	eax, DWORD PTR _tga_palette_len$[ebp]
	jl	SHORT $LN51@stbi__tga_

; 5716 : 						// invalid index
; 5717 : 						pal_idx = 0;

	mov	DWORD PTR _pal_idx$6[ebp], 0
$LN51@stbi__tga_:

; 5718 : 					}
; 5719 : 					pal_idx *= tga_comp;

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _pal_idx$6[ebp], eax

; 5720 : 					for (j = 0; j < tga_comp; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN12@stbi__tga_

; 5721 : 						raw_data[j] = tga_palette[pal_idx + j];

	mov	eax, DWORD PTR _pal_idx$6[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _tga_palette$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _raw_data$[ebp+ecx], al

; 5722 : 					}

	jmp	SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:

; 5723 : 				}

	jmp	$LN50@stbi__tga_
$LN49@stbi__tga_:

; 5724 : 				else if (tga_rgb16) {

	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	je	SHORT $LN52@stbi__tga_

; 5725 : 					STBI_ASSERT(tga_comp == STBI_rgb);

	cmp	DWORD PTR _tga_comp$[ebp], 3
	je	SHORT $LN76@stbi__tga_
	mov	eax, DWORD PTR ?__LINE__Var@?0??stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z@4JA
	add	eax, 130				; 00000082H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1BFK@ENAMFAGH@?$AAD?$AA?3?$AA?2?$AAP?$AAl?$AAa?$AAt?$AAf?$AAo?$AAr?$AAm?$AAe?$AAr?$AA?2?$AAC@
	push	OFFSET ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN76@stbi__tga_:

; 5726 : 					stbi__tga_read_rgb16(s, raw_data);

	lea	eax, DWORD PTR _raw_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__tga_read_rgb16@@YAXPAUstbi__context@@PAE@Z ; stbi__tga_read_rgb16
	add	esp, 8

; 5727 : 				}

	jmp	SHORT $LN50@stbi__tga_
$LN52@stbi__tga_:

; 5728 : 				else {
; 5729 : 					//   read in the data raw
; 5730 : 					for (j = 0; j < tga_comp; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN50@stbi__tga_

; 5731 : 						raw_data[j] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _raw_data$[ebp+ecx], al

; 5732 : 					}

	jmp	SHORT $LN14@stbi__tga_
$LN50@stbi__tga_:

; 5733 : 				}
; 5734 : 				//   clear the reading flag for the next pixel
; 5735 : 				read_next_pixel = 0;

	mov	DWORD PTR _read_next_pixel$[ebp], 0
$LN48@stbi__tga_:

; 5736 : 			} // end of reading a pixel
; 5737 : 
; 5738 : 			// copy data
; 5739 : 			for (j = 0; j < tga_comp; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	jge	SHORT $LN18@stbi__tga_

; 5740 : 				tga_data[i * tga_comp + j] = raw_data[j];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _tga_data$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR _raw_data$[ebp+edx]
	mov	BYTE PTR [ecx+eax], dl
	jmp	SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 5741 : 
; 5742 : 			//   in case we're in RLE mode, keep counting down
; 5743 : 			--RLE_count;

	mov	eax, DWORD PTR _RLE_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _RLE_count$[ebp], eax

; 5744 : 		}

	jmp	$LN8@stbi__tga_
$LN9@stbi__tga_:

; 5745 : 		//   do I need to invert the image?
; 5746 : 		if (tga_inverted)

	cmp	DWORD PTR _tga_inverted$[ebp], 0
	je	$LN54@stbi__tga_

; 5747 : 		{
; 5748 : 			for (j = 0; j * 2 < tga_height; ++j)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@stbi__tga_:
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	cmp	eax, DWORD PTR _tga_height$[ebp]
	jge	$LN54@stbi__tga_

; 5749 : 			{
; 5750 : 				int index1 = j * tga_width * tga_comp;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _index1$5[ebp], eax

; 5751 : 				int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

	mov	eax, DWORD PTR _tga_height$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _j$[ebp]
	imul	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _index2$4[ebp], eax

; 5752 : 				for (i = tga_width * tga_comp; i > 0; --i)

	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN25@stbi__tga_:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN24@stbi__tga_

; 5753 : 				{
; 5754 : 					unsigned char temp = tga_data[index1];

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index1$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _temp$3[ebp], cl

; 5755 : 					tga_data[index1] = tga_data[index2];

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index1$5[ebp]
	mov	ecx, DWORD PTR _tga_data$[ebp]
	add	ecx, DWORD PTR _index2$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 5756 : 					tga_data[index2] = temp;

	mov	eax, DWORD PTR _tga_data$[ebp]
	add	eax, DWORD PTR _index2$4[ebp]
	mov	cl, BYTE PTR _temp$3[ebp]
	mov	BYTE PTR [eax], cl

; 5757 : 					++index1;

	mov	eax, DWORD PTR _index1$5[ebp]
	add	eax, 1
	mov	DWORD PTR _index1$5[ebp], eax

; 5758 : 					++index2;

	mov	eax, DWORD PTR _index2$4[ebp]
	add	eax, 1
	mov	DWORD PTR _index2$4[ebp], eax

; 5759 : 				}

	jmp	SHORT $LN23@stbi__tga_
$LN24@stbi__tga_:

; 5760 : 			}

	jmp	$LN20@stbi__tga_
$LN54@stbi__tga_:

; 5761 : 		}
; 5762 : 		//   clear my palette, if I had one
; 5763 : 		if (tga_palette != NULL)

	cmp	DWORD PTR _tga_palette$[ebp], 0
	je	SHORT $LN37@stbi__tga_

; 5764 : 		{
; 5765 : 			STBI_FREE(tga_palette);

	mov	esi, esp
	mov	eax, DWORD PTR _tga_palette$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN37@stbi__tga_:

; 5766 : 		}
; 5767 : 	}
; 5768 : 
; 5769 : 	// swap RGB - if the source data was RGB16, it already is in the right order
; 5770 : 	if (tga_comp >= 3 && !tga_rgb16)

	cmp	DWORD PTR _tga_comp$[ebp], 3
	jl	$LN56@stbi__tga_
	cmp	DWORD PTR _tga_rgb16$[ebp], 0
	jne	$LN56@stbi__tga_

; 5771 : 	{
; 5772 : 		unsigned char* tga_pixel = tga_data;

	mov	eax, DWORD PTR _tga_data$[ebp]
	mov	DWORD PTR _tga_pixel$2[ebp], eax

; 5773 : 		for (i = 0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN28@stbi__tga_
$LN26@stbi__tga_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN28@stbi__tga_:
	mov	eax, DWORD PTR _tga_width$[ebp]
	imul	eax, DWORD PTR _tga_height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN56@stbi__tga_

; 5774 : 		{
; 5775 : 			unsigned char temp = tga_pixel[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tga_pixel$2[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _temp$1[ebp], al

; 5776 : 			tga_pixel[0] = tga_pixel[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _tga_pixel$2[ebp]
	mov	esi, DWORD PTR _tga_pixel$2[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 5777 : 			tga_pixel[2] = temp;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tga_pixel$2[ebp]
	mov	dl, BYTE PTR _temp$1[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 5778 : 			tga_pixel += tga_comp;

	mov	eax, DWORD PTR _tga_pixel$2[ebp]
	add	eax, DWORD PTR _tga_comp$[ebp]
	mov	DWORD PTR _tga_pixel$2[ebp], eax

; 5779 : 		}

	jmp	$LN26@stbi__tga_
$LN56@stbi__tga_:

; 5780 : 	}
; 5781 : 
; 5782 : 	// convert to target component count
; 5783 : 	if (req_comp && req_comp != tga_comp)

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN57@stbi__tga_
	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _tga_comp$[ebp]
	je	SHORT $LN57@stbi__tga_

; 5784 : 		tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	mov	eax, DWORD PTR _tga_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _req_comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _tga_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tga_data$[ebp]
	push	ecx
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tga_data$[ebp], eax
$LN57@stbi__tga_:

; 5785 : 
; 5786 : 	//   the things I do to get rid of an error message, and yet keep
; 5787 : 	//   Microsoft's C compilers happy... [8^(
; 5788 : 	tga_palette_start = tga_palette_len = tga_palette_bits =

	mov	DWORD PTR _tga_y_origin$[ebp], 0
	mov	eax, DWORD PTR _tga_y_origin$[ebp]
	mov	DWORD PTR _tga_x_origin$[ebp], eax
	mov	ecx, DWORD PTR _tga_x_origin$[ebp]
	mov	DWORD PTR _tga_palette_bits$[ebp], ecx
	mov	edx, DWORD PTR _tga_palette_bits$[ebp]
	mov	DWORD PTR _tga_palette_len$[ebp], edx
	mov	eax, DWORD PTR _tga_palette_len$[ebp]
	mov	DWORD PTR _tga_palette_start$[ebp], eax

; 5789 : 		tga_x_origin = tga_y_origin = 0;
; 5790 : 	//   OK, done
; 5791 : 	return tga_data;

	mov	eax, DWORD PTR _tga_data$[ebp]
$LN1@stbi__tga_:

; 5792 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN80@stbi__tga_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 596				; 00000254H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@stbi__tga_:
	DD	2
	DD	$LN79@stbi__tga_
$LN79@stbi__tga_:
	DD	-168					; ffffff58H
	DD	4
	DD	$LN77@stbi__tga_
	DD	-240					; ffffff10H
	DD	4
	DD	$LN78@stbi__tga_
$LN78@stbi__tga_:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN77@stbi__tga_:
	DB	116					; 00000074H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	98					; 00000062H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
?stbi__tga_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__tga_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__tga_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_tga_color_type$ = -32					; size = 4
_sz$ = -20						; size = 4
_res$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__tga_test@@YAHPAUstbi__context@@@Z PROC		; stbi__tga_test, COMDAT

; 5543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5544 : 	int res = 0;

	mov	DWORD PTR _res$[ebp], 0

; 5545 : 	int sz, tga_color_type;
; 5546 : 	stbi__get8(s);      //   discard Offset

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4

; 5547 : 	tga_color_type = stbi__get8(s);   //   color type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _tga_color_type$[ebp], ecx

; 5548 : 	if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jle	SHORT $LN2@stbi__tga_
	jmp	$errorEnd$21
	jmp	$errorEnd$21
$LN2@stbi__tga_:

; 5549 : 	sz = stbi__get8(s);   //   image type

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5550 : 	if (tga_color_type == 1) { // colormapped (paletted) image

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jne	SHORT $LN4@stbi__tga_

; 5551 : 		if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

	cmp	DWORD PTR _sz$[ebp], 1
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 9
	je	SHORT $LN6@stbi__tga_
	jmp	$errorEnd$21
	jmp	$errorEnd$21
$LN6@stbi__tga_:

; 5552 : 		stbi__skip(s, 4);       // skip index of first colormap entry and number of entries

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5553 : 		sz = stbi__get8(s);    //   check bits per palette color entry

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5554 : 		if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN8@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN8@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN8@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN8@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN8@stbi__tga_
	jmp	$errorEnd$21
	jmp	$errorEnd$21
$LN8@stbi__tga_:

; 5555 : 		stbi__skip(s, 4);       // skip image x and y origin

	push	4
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5556 : 	}

	jmp	SHORT $LN5@stbi__tga_
$LN4@stbi__tga_:

; 5557 : 	else { // "normal" image w/o colormap
; 5558 : 		if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE

	cmp	DWORD PTR _sz$[ebp], 2
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 3
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 10			; 0000000aH
	je	SHORT $LN10@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 11			; 0000000bH
	je	SHORT $LN10@stbi__tga_
	jmp	$errorEnd$21
	jmp	$errorEnd$21
$LN10@stbi__tga_:

; 5559 : 		stbi__skip(s, 9); // skip colormap specification and image x/y origin

	push	9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8
$LN5@stbi__tga_:

; 5560 : 	}
; 5561 : 	if (stbi__get16le(s) < 1) goto errorEnd;      //   test width

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	cmp	eax, 1
	jge	SHORT $LN12@stbi__tga_
	jmp	SHORT $errorEnd$21
	jmp	SHORT $errorEnd$21
$LN12@stbi__tga_:

; 5562 : 	if (stbi__get16le(s) < 1) goto errorEnd;      //   test height

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	cmp	eax, 1
	jge	SHORT $LN14@stbi__tga_
	jmp	SHORT $errorEnd$21
	jmp	SHORT $errorEnd$21
$LN14@stbi__tga_:

; 5563 : 	sz = stbi__get8(s);   //   bits per pixel

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _sz$[ebp], ecx

; 5564 : 	if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index

	cmp	DWORD PTR _tga_color_type$[ebp], 1
	jne	SHORT $LN16@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN16@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN16@stbi__tga_
	jmp	SHORT $errorEnd$21
	jmp	SHORT $errorEnd$21
$LN16@stbi__tga_:

; 5565 : 	if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

	cmp	DWORD PTR _sz$[ebp], 8
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 15			; 0000000fH
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 16			; 00000010H
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 24			; 00000018H
	je	SHORT $LN18@stbi__tga_
	cmp	DWORD PTR _sz$[ebp], 32			; 00000020H
	je	SHORT $LN18@stbi__tga_
	jmp	SHORT $errorEnd$21
	jmp	SHORT $errorEnd$21
$LN18@stbi__tga_:

; 5566 : 
; 5567 : 	res = 1; // if we got this far, everything's good and we can return 1 instead of 0

	mov	DWORD PTR _res$[ebp], 1
$errorEnd$21:

; 5568 : 
; 5569 : errorEnd:
; 5570 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5571 : 	return res;

	mov	eax, DWORD PTR _res$[ebp]

; 5572 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__tga_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__tga_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bmp_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
tv75 = -252						; size = 4
_info$ = -52						; size = 32
_p$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__bmp_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__bmp_info, COMDAT

; 7035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7036 : 	void* p;
; 7037 : 	stbi__bmp_data info;
; 7038 : 
; 7039 : 	info.all_a = 255;

	mov	DWORD PTR _info$[ebp+28], 255		; 000000ffH

; 7040 : 	p = stbi__bmp_parse_header(s, &info);

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__bmp_parse_header@@YAPAXPAUstbi__context@@PAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 7041 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 7042 : 	if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@stbi__bmp_

; 7043 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 7044 : 	if (x)* x = s->img_x;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@stbi__bmp_
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@stbi__bmp_:

; 7045 : 	if (y)* y = s->img_y;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@stbi__bmp_
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN4@stbi__bmp_:

; 7046 : 	if (comp)* comp = info.ma ? 4 : 3;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR _info$[ebp+24], 0
	je	SHORT $LN7@stbi__bmp_
	mov	DWORD PTR tv75[ebp], 4
	jmp	SHORT $LN8@stbi__bmp_
$LN7@stbi__bmp_:
	mov	DWORD PTR tv75[ebp], 3
$LN8@stbi__bmp_:
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@stbi__bmp_:

; 7047 : 	return 1;

	mov	eax, 1
$LN1@stbi__bmp_:

; 7048 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@stbi__bmp_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@stbi__bmp_:
	DD	1
	DD	$LN10@stbi__bmp_
$LN10@stbi__bmp_:
	DD	-52					; ffffffccH
	DD	32					; 00000020H
	DD	$LN9@stbi__bmp_
$LN9@stbi__bmp_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
?stbi__bmp_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__bmp_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bmp_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
tv483 = -2088						; size = 4
tv446 = -2088						; size = 4
tv430 = -2088						; size = 4
tv382 = -2088						; size = 4
tv328 = -2088						; size = 4
tv234 = -2088						; size = 4
tv215 = -2088						; size = 4
tv153 = -2088						; size = 4
tv145 = -2088						; size = 4
tv133 = -2088						; size = 4
tv86 = -2088						; size = 4
tv70 = -2088						; size = 4
_p2$1 = -1504						; size = 4
_p1$2 = -1492						; size = 4
_t$3 = -1477						; size = 1
_a$4 = -1468						; size = 4
_v$5 = -1456						; size = 4
_bpp$6 = -1444						; size = 4
_a$7 = -1429						; size = 1
_easy$8 = -1420						; size = 4
_z$9 = -1408						; size = 4
_acount$10 = -1396					; size = 4
_bcount$11 = -1384					; size = 4
_gcount$12 = -1372					; size = 4
_rcount$13 = -1360					; size = 4
_ashift$14 = -1348					; size = 4
_bshift$15 = -1336					; size = 4
_gshift$16 = -1324					; size = 4
_rshift$17 = -1312					; size = 4
_v2$18 = -1300						; size = 4
_v$19 = -1288						; size = 4
_color$20 = -1276					; size = 4
_v$21 = -1264						; size = 4
_bit_offset$22 = -1252					; size = 4
_z$23 = -1240						; size = 4
_info$ = -1228						; size = 32
_target$ = -1188					; size = 4
_pad$ = -1176						; size = 4
_flip_vertically$ = -1164				; size = 4
_width$ = -1152						; size = 4
_j$ = -1140						; size = 4
_i$ = -1128						; size = 4
_psize$ = -1116						; size = 4
_pal$ = -1104						; size = 1024
_all_a$ = -72						; size = 4
_ma$ = -60						; size = 4
_mb$ = -48						; size = 4
_mg$ = -36						; size = 4
_mr$ = -24						; size = 4
_out$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__bmp_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__bmp_load, COMDAT

; 5273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2088				; 00000828H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2088]
	mov	ecx, 522				; 0000020aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5274 : 	stbi_uc* out;
; 5275 : 	unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;

	mov	DWORD PTR _mr$[ebp], 0
	mov	DWORD PTR _mg$[ebp], 0
	mov	DWORD PTR _mb$[ebp], 0
	mov	DWORD PTR _ma$[ebp], 0

; 5276 : 	stbi_uc pal[256][4];
; 5277 : 	int psize = 0, i, j, width;

	mov	DWORD PTR _psize$[ebp], 0

; 5278 : 	int flip_vertically, pad, target;
; 5279 : 	stbi__bmp_data info;
; 5280 : 	STBI_NOTUSED(ri);
; 5281 : 
; 5282 : 	info.all_a = 255;

	mov	DWORD PTR _info$[ebp+28], 255		; 000000ffH

; 5283 : 	if (stbi__bmp_parse_header(s, &info) == NULL)

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__bmp_parse_header@@YAPAXPAUstbi__context@@PAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@stbi__bmp_

; 5284 : 		return NULL; // error code already set

	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN35@stbi__bmp_:

; 5285 : 
; 5286 : 	flip_vertically = ((int)s->img_y) > 0;

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN85@stbi__bmp_
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN86@stbi__bmp_
$LN85@stbi__bmp_:
	mov	DWORD PTR tv70[ebp], 0
$LN86@stbi__bmp_:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _flip_vertically$[ebp], ecx

; 5287 : 	s->img_y = abs((int)s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_abs
	add	esp, 4
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+4], eax

; 5288 : 
; 5289 : 	mr = info.mr;

	mov	eax, DWORD PTR _info$[ebp+12]
	mov	DWORD PTR _mr$[ebp], eax

; 5290 : 	mg = info.mg;

	mov	eax, DWORD PTR _info$[ebp+16]
	mov	DWORD PTR _mg$[ebp], eax

; 5291 : 	mb = info.mb;

	mov	eax, DWORD PTR _info$[ebp+20]
	mov	DWORD PTR _mb$[ebp], eax

; 5292 : 	ma = info.ma;

	mov	eax, DWORD PTR _info$[ebp+24]
	mov	DWORD PTR _ma$[ebp], eax

; 5293 : 	all_a = info.all_a;

	mov	eax, DWORD PTR _info$[ebp+28]
	mov	DWORD PTR _all_a$[ebp], eax

; 5294 : 
; 5295 : 	if (info.hsz == 12) {

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	jne	SHORT $LN36@stbi__bmp_

; 5296 : 		if (info.bpp < 24)

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jge	SHORT $LN38@stbi__bmp_

; 5297 : 			psize = (info.offset - 14 - 24) / 3;

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 38					; 00000026H
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _psize$[ebp], eax
$LN38@stbi__bmp_:

; 5298 : 	}

	jmp	SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:

; 5299 : 	else {
; 5300 : 		if (info.bpp < 16)

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jge	SHORT $LN37@stbi__bmp_

; 5301 : 			psize = (info.offset - 14 - info.hsz) >> 2;

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	sar	eax, 2
	mov	DWORD PTR _psize$[ebp], eax
$LN37@stbi__bmp_:

; 5302 : 	}
; 5303 : 
; 5304 : 	s->img_n = ma ? 4 : 3;

	cmp	DWORD PTR _ma$[ebp], 0
	je	SHORT $LN87@stbi__bmp_
	mov	DWORD PTR tv86[ebp], 4
	jmp	SHORT $LN88@stbi__bmp_
$LN87@stbi__bmp_:
	mov	DWORD PTR tv86[ebp], 3
$LN88@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5305 : 	if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN40@stbi__bmp_
	cmp	DWORD PTR _req_comp$[ebp], 3
	jl	SHORT $LN40@stbi__bmp_

; 5306 : 		target = req_comp;

	mov	eax, DWORD PTR _req_comp$[ebp]
	mov	DWORD PTR _target$[ebp], eax
	jmp	SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:

; 5307 : 	else
; 5308 : 		target = s->img_n; // if they want monochrome, we'll post-convert

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _target$[ebp], ecx
$LN41@stbi__bmp_:

; 5309 : 
; 5310 : 	 // sanity-check size
; 5311 : 	if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	call	?stbi__mad3sizes_valid@@YAHHHHH@Z	; stbi__mad3sizes_valid
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN42@stbi__bmp_

; 5312 : 		return stbi__errpuc("too large", "Corrupt BMP");

	push	OFFSET ??_C@_09OJDLMMBJ@too?5large@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN89@stbi__bmp_
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN90@stbi__bmp_
$LN89@stbi__bmp_:
	mov	DWORD PTR tv133[ebp], 0
$LN90@stbi__bmp_:
	mov	eax, DWORD PTR tv133[ebp]
	jmp	$LN1@stbi__bmp_
$LN42@stbi__bmp_:

; 5313 : 
; 5314 : 	out = (stbi_uc*)stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	call	?stbi__malloc_mad3@@YAPAXHHHH@Z		; stbi__malloc_mad3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 5315 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN43@stbi__bmp_
	push	OFFSET ??_C@_08NOGIMCHF@outofmem@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN91@stbi__bmp_
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN92@stbi__bmp_
$LN91@stbi__bmp_:
	mov	DWORD PTR tv145[ebp], 0
$LN92@stbi__bmp_:
	mov	eax, DWORD PTR tv145[ebp]
	jmp	$LN1@stbi__bmp_
$LN43@stbi__bmp_:

; 5316 : 	if (info.bpp < 16) {

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jge	$LN44@stbi__bmp_

; 5317 : 		int z = 0;

	mov	DWORD PTR _z$23[ebp], 0

; 5318 : 		if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	cmp	DWORD PTR _psize$[ebp], 0
	je	SHORT $LN47@stbi__bmp_
	cmp	DWORD PTR _psize$[ebp], 256		; 00000100H
	jle	SHORT $LN46@stbi__bmp_
$LN47@stbi__bmp_:
	mov	esi, esp
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_07MALOAKCI@invalid@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN93@stbi__bmp_
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN94@stbi__bmp_
$LN93@stbi__bmp_:
	mov	DWORD PTR tv153[ebp], 0
$LN94@stbi__bmp_:
	mov	eax, DWORD PTR tv153[ebp]
	jmp	$LN1@stbi__bmp_
$LN46@stbi__bmp_:

; 5319 : 		for (i = 0; i < psize; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _psize$[ebp]
	jge	$LN3@stbi__bmp_

; 5320 : 			pal[i][2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR [edx+ecx], al

; 5321 : 			pal[i][1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR [edx+ecx], al

; 5322 : 			pal[i][0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _pal$[ebp+ecx*4]
	mov	ecx, 1
	imul	ecx, ecx, 0
	mov	BYTE PTR [edx+ecx], al

; 5323 : 			if (info.hsz != 12) stbi__get8(s);

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	je	SHORT $LN48@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
$LN48@stbi__bmp_:

; 5324 : 			pal[i][3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 5325 : 		}

	jmp	$LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5326 : 		stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

	cmp	DWORD PTR _info$[ebp+8], 12		; 0000000cH
	jne	SHORT $LN95@stbi__bmp_
	mov	DWORD PTR tv215[ebp], 3
	jmp	SHORT $LN96@stbi__bmp_
$LN95@stbi__bmp_:
	mov	DWORD PTR tv215[ebp], 4
$LN96@stbi__bmp_:
	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	mov	ecx, DWORD PTR _psize$[ebp]
	imul	ecx, DWORD PTR tv215[ebp]
	sub	eax, ecx
	push	eax
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5327 : 		if (info.bpp == 1) width = (s->img_x + 7) >> 3;

	cmp	DWORD PTR _info$[ebp], 1
	jne	SHORT $LN49@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 7
	shr	ecx, 3
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN50@stbi__bmp_
$LN49@stbi__bmp_:

; 5328 : 		else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

	cmp	DWORD PTR _info$[ebp], 4
	jne	SHORT $LN51@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	shr	ecx, 1
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN50@stbi__bmp_
$LN51@stbi__bmp_:

; 5329 : 		else if (info.bpp == 8) width = s->img_x;

	cmp	DWORD PTR _info$[ebp], 8
	jne	SHORT $LN53@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN50@stbi__bmp_
$LN53@stbi__bmp_:

; 5330 : 		else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

	mov	esi, esp
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_07JNJHIMGH@bad?5bpp@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN97@stbi__bmp_
	mov	DWORD PTR tv234[ebp], 0
	jmp	SHORT $LN98@stbi__bmp_
$LN97@stbi__bmp_:
	mov	DWORD PTR tv234[ebp], 0
$LN98@stbi__bmp_:
	mov	eax, DWORD PTR tv234[ebp]
	jmp	$LN1@stbi__bmp_
$LN50@stbi__bmp_:

; 5331 : 		pad = (-width) & 3;

	mov	eax, DWORD PTR _width$[ebp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR _pad$[ebp], eax

; 5332 : 		if (info.bpp == 1) {

	cmp	DWORD PTR _info$[ebp], 1
	jne	$LN55@stbi__bmp_

; 5333 : 			for (j = 0; j < (int)s->img_y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN6@stbi__bmp_

; 5334 : 				int bit_offset = 7, v = stbi__get8(s);

	mov	DWORD PTR _bit_offset$22[ebp], 7
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _v$21[ebp], ecx

; 5335 : 				for (i = 0; i < (int)s->img_x; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN9@stbi__bmp_

; 5336 : 					int color = (v >> bit_offset) & 0x1;

	mov	eax, DWORD PTR _v$21[ebp]
	mov	ecx, DWORD PTR _bit_offset$22[ebp]
	sar	eax, cl
	and	eax, 1
	mov	DWORD PTR _color$20[ebp], eax

; 5337 : 					out[z++] = pal[color][0];

	mov	eax, DWORD PTR _color$20[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _z$23[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx

; 5338 : 					out[z++] = pal[color][1];

	mov	eax, DWORD PTR _color$20[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5339 : 					out[z++] = pal[color][2];

	mov	eax, DWORD PTR _color$20[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5340 : 					if (target == 4) out[z++] = 255;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN57@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx
$LN57@stbi__bmp_:

; 5341 : 					if (i + 1 == (int)s->img_x) break;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN58@stbi__bmp_
	jmp	SHORT $LN9@stbi__bmp_
$LN58@stbi__bmp_:

; 5342 : 					if ((--bit_offset) < 0) {

	mov	eax, DWORD PTR _bit_offset$22[ebp]
	sub	eax, 1
	mov	DWORD PTR _bit_offset$22[ebp], eax
	jns	SHORT $LN59@stbi__bmp_

; 5343 : 						bit_offset = 7;

	mov	DWORD PTR _bit_offset$22[ebp], 7

; 5344 : 						v = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _v$21[ebp], ecx
$LN59@stbi__bmp_:

; 5345 : 					}
; 5346 : 				}

	jmp	$LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 5347 : 				stbi__skip(s, pad);

	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5348 : 			}

	jmp	$LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 5349 : 		}

	jmp	$LN56@stbi__bmp_
$LN55@stbi__bmp_:

; 5350 : 		else {
; 5351 : 			for (j = 0; j < (int)s->img_y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN56@stbi__bmp_

; 5352 : 				for (i = 0; i < (int)s->img_x; i += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN16@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN15@stbi__bmp_

; 5353 : 					int v = stbi__get8(s), v2 = 0;

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR _v$19[ebp], ecx
	mov	DWORD PTR _v2$18[ebp], 0

; 5354 : 					if (info.bpp == 4) {

	cmp	DWORD PTR _info$[ebp], 4
	jne	SHORT $LN60@stbi__bmp_

; 5355 : 						v2 = v & 15;

	mov	eax, DWORD PTR _v$19[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _v2$18[ebp], eax

; 5356 : 						v >>= 4;

	mov	eax, DWORD PTR _v$19[ebp]
	sar	eax, 4
	mov	DWORD PTR _v$19[ebp], eax
$LN60@stbi__bmp_:

; 5357 : 					}
; 5358 : 					out[z++] = pal[v][0];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _z$23[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx

; 5359 : 					out[z++] = pal[v][1];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5360 : 					out[z++] = pal[v][2];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5361 : 					if (target == 4) out[z++] = 255;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN61@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx
$LN61@stbi__bmp_:

; 5362 : 					if (i + 1 == (int)s->img_x) break;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN62@stbi__bmp_
	jmp	$LN15@stbi__bmp_
$LN62@stbi__bmp_:

; 5363 : 					v = (info.bpp == 8) ? stbi__get8(s) : v2;

	cmp	DWORD PTR _info$[ebp], 8
	jne	SHORT $LN99@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv328[ebp], ecx
	jmp	SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
	mov	edx, DWORD PTR _v2$18[ebp]
	mov	DWORD PTR tv328[ebp], edx
$LN100@stbi__bmp_:
	mov	eax, DWORD PTR tv328[ebp]
	mov	DWORD PTR _v$19[ebp], eax

; 5364 : 					out[z++] = pal[v][0];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _z$23[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx

; 5365 : 					out[z++] = pal[v][1];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5366 : 					out[z++] = pal[v][2];

	mov	eax, DWORD PTR _v$19[ebp]
	lea	ecx, DWORD PTR _pal$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$23[ebp]
	add	edx, 1
	mov	DWORD PTR _z$23[ebp], edx

; 5367 : 					if (target == 4) out[z++] = 255;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN63@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$23[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _z$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _z$23[ebp], ecx
$LN63@stbi__bmp_:

; 5368 : 				}

	jmp	$LN14@stbi__bmp_
$LN15@stbi__bmp_:

; 5369 : 				stbi__skip(s, pad);

	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5370 : 			}

	jmp	$LN11@stbi__bmp_
$LN56@stbi__bmp_:

; 5371 : 		}
; 5372 : 	}

	jmp	$LN45@stbi__bmp_
$LN44@stbi__bmp_:

; 5373 : 	else {
; 5374 : 		int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;

	mov	DWORD PTR _rshift$17[ebp], 0
	mov	DWORD PTR _gshift$16[ebp], 0
	mov	DWORD PTR _bshift$15[ebp], 0
	mov	DWORD PTR _ashift$14[ebp], 0
	mov	DWORD PTR _rcount$13[ebp], 0
	mov	DWORD PTR _gcount$12[ebp], 0
	mov	DWORD PTR _bcount$11[ebp], 0
	mov	DWORD PTR _acount$10[ebp], 0

; 5375 : 		int z = 0;

	mov	DWORD PTR _z$9[ebp], 0

; 5376 : 		int easy = 0;

	mov	DWORD PTR _easy$8[ebp], 0

; 5377 : 		stbi__skip(s, info.offset - 14 - info.hsz);

	mov	eax, DWORD PTR _info$[ebp+4]
	sub	eax, 14					; 0000000eH
	sub	eax, DWORD PTR _info$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5378 : 		if (info.bpp == 24) width = 3 * s->img_x;

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jne	SHORT $LN64@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [eax], 3
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN65@stbi__bmp_
$LN64@stbi__bmp_:

; 5379 : 		else if (info.bpp == 16) width = 2 * s->img_x;

	cmp	DWORD PTR _info$[ebp], 16		; 00000010H
	jne	SHORT $LN66@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 1
	mov	DWORD PTR _width$[ebp], ecx
	jmp	SHORT $LN65@stbi__bmp_
$LN66@stbi__bmp_:

; 5380 : 		else /* bpp = 32 and pad = 0 */ width = 0;

	mov	DWORD PTR _width$[ebp], 0
$LN65@stbi__bmp_:

; 5381 : 		pad = (-width) & 3;

	mov	eax, DWORD PTR _width$[ebp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR _pad$[ebp], eax

; 5382 : 		if (info.bpp == 24) {

	cmp	DWORD PTR _info$[ebp], 24		; 00000018H
	jne	SHORT $LN68@stbi__bmp_

; 5383 : 			easy = 1;

	mov	DWORD PTR _easy$8[ebp], 1

; 5384 : 		}

	jmp	SHORT $LN69@stbi__bmp_
$LN68@stbi__bmp_:

; 5385 : 		else if (info.bpp == 32) {

	cmp	DWORD PTR _info$[ebp], 32		; 00000020H
	jne	SHORT $LN69@stbi__bmp_

; 5386 : 			if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

	cmp	DWORD PTR _mb$[ebp], 255		; 000000ffH
	jne	SHORT $LN69@stbi__bmp_
	cmp	DWORD PTR _mg$[ebp], 65280		; 0000ff00H
	jne	SHORT $LN69@stbi__bmp_
	cmp	DWORD PTR _mr$[ebp], 16711680		; 00ff0000H
	jne	SHORT $LN69@stbi__bmp_
	cmp	DWORD PTR _ma$[ebp], -16777216		; ff000000H
	jne	SHORT $LN69@stbi__bmp_

; 5387 : 				easy = 2;

	mov	DWORD PTR _easy$8[ebp], 2
$LN69@stbi__bmp_:

; 5388 : 		}
; 5389 : 		if (!easy) {

	cmp	DWORD PTR _easy$8[ebp], 0
	jne	$LN72@stbi__bmp_

; 5390 : 			if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	cmp	DWORD PTR _mr$[ebp], 0
	je	SHORT $LN74@stbi__bmp_
	cmp	DWORD PTR _mg$[ebp], 0
	je	SHORT $LN74@stbi__bmp_
	cmp	DWORD PTR _mb$[ebp], 0
	jne	SHORT $LN73@stbi__bmp_
$LN74@stbi__bmp_:
	mov	esi, esp
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	OFFSET ??_C@_09DAEBACAB@bad?5masks@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN101@stbi__bmp_
	mov	DWORD PTR tv382[ebp], 0
	jmp	SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:
	mov	DWORD PTR tv382[ebp], 0
$LN102@stbi__bmp_:
	mov	eax, DWORD PTR tv382[ebp]
	jmp	$LN1@stbi__bmp_
$LN73@stbi__bmp_:

; 5391 : 			// right shift amt to put high bit in position #7
; 5392 : 			rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);

	mov	eax, DWORD PTR _mr$[ebp]
	push	eax
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _rshift$17[ebp], eax
	mov	eax, DWORD PTR _mr$[ebp]
	push	eax
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _rcount$13[ebp], eax

; 5393 : 			gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);

	mov	eax, DWORD PTR _mg$[ebp]
	push	eax
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _gshift$16[ebp], eax
	mov	eax, DWORD PTR _mg$[ebp]
	push	eax
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _gcount$12[ebp], eax

; 5394 : 			bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);

	mov	eax, DWORD PTR _mb$[ebp]
	push	eax
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _bshift$15[ebp], eax
	mov	eax, DWORD PTR _mb$[ebp]
	push	eax
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _bcount$11[ebp], eax

; 5395 : 			ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);

	mov	eax, DWORD PTR _ma$[ebp]
	push	eax
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	add	esp, 4
	sub	eax, 7
	mov	DWORD PTR _ashift$14[ebp], eax
	mov	eax, DWORD PTR _ma$[ebp]
	push	eax
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	add	esp, 4
	mov	DWORD PTR _acount$10[ebp], eax
$LN72@stbi__bmp_:

; 5396 : 		}
; 5397 : 		for (j = 0; j < (int)s->img_y; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN45@stbi__bmp_

; 5398 : 			if (easy) {

	cmp	DWORD PTR _easy$8[ebp], 0
	je	$LN75@stbi__bmp_

; 5399 : 				for (i = 0; i < (int)s->img_x; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN22@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN21@stbi__bmp_

; 5400 : 					unsigned char a;
; 5401 : 					out[z + 2] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx+2], al

; 5402 : 					out[z + 1] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx+1], al

; 5403 : 					out[z + 0] = stbi__get8(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al

; 5404 : 					z += 3;

	mov	eax, DWORD PTR _z$9[ebp]
	add	eax, 3
	mov	DWORD PTR _z$9[ebp], eax

; 5405 : 					a = (easy == 2 ? stbi__get8(s) : 255);

	cmp	DWORD PTR _easy$8[ebp], 2
	jne	SHORT $LN103@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get8@@YAEPAUstbi__context@@@Z	; stbi__get8
	add	esp, 4
	movzx	ecx, al
	mov	DWORD PTR tv430[ebp], ecx
	jmp	SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
	mov	DWORD PTR tv430[ebp], 255		; 000000ffH
$LN104@stbi__bmp_:
	mov	dl, BYTE PTR tv430[ebp]
	mov	BYTE PTR _a$7[ebp], dl

; 5406 : 					all_a |= a;

	movzx	eax, BYTE PTR _a$7[ebp]
	or	eax, DWORD PTR _all_a$[ebp]
	mov	DWORD PTR _all_a$[ebp], eax

; 5407 : 					if (target == 4) out[z++] = a;

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN77@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _z$9[ebp]
	mov	cl, BYTE PTR _a$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx
$LN77@stbi__bmp_:

; 5408 : 				}

	jmp	$LN20@stbi__bmp_
$LN21@stbi__bmp_:

; 5409 : 			}

	jmp	$LN76@stbi__bmp_
$LN75@stbi__bmp_:

; 5410 : 			else {
; 5411 : 				int bpp = info.bpp;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _bpp$6[ebp], eax

; 5412 : 				for (i = 0; i < (int)s->img_x; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN25@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN76@stbi__bmp_

; 5413 : 					stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));

	cmp	DWORD PTR _bpp$6[ebp], 16		; 00000010H
	jne	SHORT $LN105@stbi__bmp_
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__get16le@@YAHPAUstbi__context@@@Z	; stbi__get16le
	add	esp, 4
	mov	DWORD PTR tv446[ebp], eax
	jmp	SHORT $LN106@stbi__bmp_
$LN105@stbi__bmp_:
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__get32le@@YAIPAUstbi__context@@@Z	; stbi__get32le
	add	esp, 4
	mov	DWORD PTR tv446[ebp], eax
$LN106@stbi__bmp_:
	mov	edx, DWORD PTR tv446[ebp]
	mov	DWORD PTR _v$5[ebp], edx

; 5414 : 					unsigned int a;
; 5415 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

	mov	eax, DWORD PTR _rcount$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _rshift$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mr$[ebp]
	push	edx
	call	?stbi__shiftsigned@@YAHIHH@Z		; stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5416 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

	mov	eax, DWORD PTR _gcount$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _gshift$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mg$[ebp]
	push	edx
	call	?stbi__shiftsigned@@YAHIHH@Z		; stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5417 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

	mov	eax, DWORD PTR _bcount$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _bshift$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _mb$[ebp]
	push	edx
	call	?stbi__shiftsigned@@YAHIHH@Z		; stbi__shiftsigned
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx

; 5418 : 					a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	cmp	DWORD PTR _ma$[ebp], 0
	je	SHORT $LN107@stbi__bmp_
	mov	eax, DWORD PTR _acount$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _ashift$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$5[ebp]
	and	edx, DWORD PTR _ma$[ebp]
	push	edx
	call	?stbi__shiftsigned@@YAHIHH@Z		; stbi__shiftsigned
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv483[ebp], eax
	jmp	SHORT $LN108@stbi__bmp_
$LN107@stbi__bmp_:
	mov	DWORD PTR tv483[ebp], 255		; 000000ffH
$LN108@stbi__bmp_:
	mov	eax, DWORD PTR tv483[ebp]
	mov	DWORD PTR _a$4[ebp], eax

; 5419 : 					all_a |= a;

	mov	eax, DWORD PTR _all_a$[ebp]
	or	eax, DWORD PTR _a$4[ebp]
	mov	DWORD PTR _all_a$[ebp], eax

; 5420 : 					if (target == 4) out[z++] = STBI__BYTECAST(a);

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN78@stbi__bmp_
	mov	eax, DWORD PTR _a$4[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _z$9[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _z$9[ebp]
	add	edx, 1
	mov	DWORD PTR _z$9[ebp], edx
$LN78@stbi__bmp_:

; 5421 : 				}

	jmp	$LN23@stbi__bmp_
$LN76@stbi__bmp_:

; 5422 : 			}
; 5423 : 			stbi__skip(s, pad);

	mov	eax, DWORD PTR _pad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__skip@@YAXPAUstbi__context@@H@Z	; stbi__skip
	add	esp, 8

; 5424 : 		}

	jmp	$LN17@stbi__bmp_
$LN45@stbi__bmp_:

; 5425 : 	}
; 5426 : 
; 5427 : 	// if alpha channel is all 0s, replace with all 255s
; 5428 : 	if (target == 4 && all_a == 0)

	cmp	DWORD PTR _target$[ebp], 4
	jne	SHORT $LN79@stbi__bmp_
	cmp	DWORD PTR _all_a$[ebp], 0
	jne	SHORT $LN79@stbi__bmp_

; 5429 : 		for (i = 4 * s->img_x * s->img_y - 1; i >= 0; i -= 4)

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 4
	mov	DWORD PTR _i$[ebp], eax
$LN28@stbi__bmp_:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN79@stbi__bmp_

; 5430 : 			out[i] = 255;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $LN26@stbi__bmp_
$LN79@stbi__bmp_:

; 5431 : 
; 5432 : 	if (flip_vertically) {

	cmp	DWORD PTR _flip_vertically$[ebp], 0
	je	$LN80@stbi__bmp_

; 5433 : 		stbi_uc t;
; 5434 : 		for (j = 0; j < (int)s->img_y >> 1; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN31@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sar	ecx, 1
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN80@stbi__bmp_

; 5435 : 			stbi_uc* p1 = out + j * s->img_x * target;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _target$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p1$2[ebp], ecx

; 5436 : 			stbi_uc* p2 = out + (s->img_y - 1 - j) * s->img_x * target;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	imul	ecx, DWORD PTR [edx]
	imul	ecx, DWORD PTR _target$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p2$1[ebp], ecx

; 5437 : 			for (i = 0; i < (int)s->img_x * target; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN34@stbi__bmp_
$LN32@stbi__bmp_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN34@stbi__bmp_:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _target$[ebp]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN33@stbi__bmp_

; 5438 : 				t = p1[i]; p1[i] = p2[i]; p2[i] = t;

	mov	eax, DWORD PTR _p1$2[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _t$3[ebp], cl
	mov	eax, DWORD PTR _p1$2[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p2$1[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _p2$1[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _t$3[ebp]
	mov	BYTE PTR [eax], cl

; 5439 : 			}

	jmp	SHORT $LN32@stbi__bmp_
$LN33@stbi__bmp_:

; 5440 : 		}

	jmp	$LN29@stbi__bmp_
$LN80@stbi__bmp_:

; 5441 : 	}
; 5442 : 
; 5443 : 	if (req_comp && req_comp != target) {

	cmp	DWORD PTR _req_comp$[ebp], 0
	je	SHORT $LN81@stbi__bmp_
	mov	eax, DWORD PTR _req_comp$[ebp]
	cmp	eax, DWORD PTR _target$[ebp]
	je	SHORT $LN81@stbi__bmp_

; 5444 : 		out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?stbi__convert_format@@YAPAEPAEHHII@Z	; stbi__convert_format
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 5445 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN81@stbi__bmp_
	mov	eax, DWORD PTR _out$[ebp]
	jmp	SHORT $LN1@stbi__bmp_
$LN81@stbi__bmp_:

; 5446 : 	}
; 5447 : 
; 5448 : 	*x = s->img_x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 5449 : 	*y = s->img_y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 5450 : 	if (comp)* comp = s->img_n;

	cmp	DWORD PTR _comp$[ebp], 0
	je	SHORT $LN83@stbi__bmp_
	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
$LN83@stbi__bmp_:

; 5451 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@stbi__bmp_:

; 5452 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN112@stbi__bmp_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2088				; 00000828H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@stbi__bmp_:
	DD	2
	DD	$LN111@stbi__bmp_
$LN111@stbi__bmp_:
	DD	-1104					; fffffbb0H
	DD	1024					; 00000400H
	DD	$LN109@stbi__bmp_
	DD	-1228					; fffffb34H
	DD	32					; 00000020H
	DD	$LN110@stbi__bmp_
$LN110@stbi__bmp_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN109@stbi__bmp_:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?stbi__bmp_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__bmp_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__bmp_test@@YAHPAUstbi__context@@@Z PROC		; stbi__bmp_test, COMDAT

; 5124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5125 : 	int r = stbi__bmp_test_raw(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__bmp_test_raw@@YAHPAUstbi__context@@@Z ; stbi__bmp_test_raw
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 5126 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5127 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 5128 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__bmp_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__png_is16@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_p$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?stbi__png_is16@@YAHPAUstbi__context@@@Z PROC		; stbi__png_is16, COMDAT

; 5092 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5093 : 	stbi__png p;
; 5094 : 	p.s = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5095 : 	if (!stbi__png_info_raw(&p, NULL, NULL, NULL))

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?stbi__png_info_raw@@YAHPAUstbi__png@@PAH11@Z ; stbi__png_info_raw
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@stbi__png_

; 5096 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5097 : 	if (p.depth != 16) {

	cmp	DWORD PTR _p$[ebp+16], 16		; 00000010H
	je	SHORT $LN3@stbi__png_

; 5098 : 		stbi__rewind(p.s);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5099 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__png_
$LN3@stbi__png_:

; 5100 : 	}
; 5101 : 	return 1;

	mov	eax, 1
$LN1@stbi__png_:

; 5102 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@stbi__png_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@stbi__png_:
	DD	1
	DD	$LN6@stbi__png_
$LN6@stbi__png_:
	DD	-28					; ffffffe4H
	DD	20					; 00000014H
	DD	$LN5@stbi__png_
$LN5@stbi__png_:
	DB	112					; 00000070H
	DB	0
?stbi__png_is16@@YAHPAUstbi__context@@@Z ENDP		; stbi__png_is16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__png_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_p$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__png_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__png_info, COMDAT

; 5085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5086 : 	stbi__png p;
; 5087 : 	p.s = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5088 : 	return stbi__png_info_raw(&p, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?stbi__png_info_raw@@YAHPAUstbi__png@@PAH11@Z ; stbi__png_info_raw
	add	esp, 16					; 00000010H

; 5089 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__png_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi__png_:
	DD	1
	DD	$LN4@stbi__png_
$LN4@stbi__png_:
	DD	-28					; ffffffe4H
	DD	20					; 00000014H
	DD	$LN3@stbi__png_
$LN3@stbi__png_:
	DB	112					; 00000070H
	DB	0
?stbi__png_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__png_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__png_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
_p$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__png_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__png_load, COMDAT

; 5058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5059 : 	stbi__png p;
; 5060 : 	p.s = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5061 : 	return stbi__do_png(&p, x, y, comp, req_comp, ri);

	mov	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _req_comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comp$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?stbi__do_png@@YAPAXPAUstbi__png@@PAH11HPAUstbi__result_info@@@Z ; stbi__do_png
	add	esp, 24					; 00000018H

; 5062 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__png_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi__png_:
	DD	1
	DD	$LN4@stbi__png_
$LN4@stbi__png_:
	DD	-28					; ffffffe4H
	DD	20					; 00000014H
	DD	$LN3@stbi__png_
$LN3@stbi__png_:
	DB	112					; 00000070H
	DB	0
?stbi__png_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__png_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__png_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__png_test@@YAHPAUstbi__context@@@Z PROC		; stbi__png_test, COMDAT

; 5065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 5066 : 	int r;
; 5067 : 	r = stbi__check_png_header(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__check_png_header@@YAHPAUstbi__context@@@Z ; stbi__check_png_header
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 5068 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 5069 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 5070 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__png_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__png_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_info@@YAHPAUstbi__context@@PAH11@Z
_TEXT	SEGMENT
_j$ = -20						; size = 4
_result$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi__jpeg_info@@YAHPAUstbi__context@@PAH11@Z PROC	; stbi__jpeg_info, COMDAT

; 3866 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3867 : 	int result;
; 3868 : 	stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));

	push	18456					; 00004818H
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3869 : 	j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3870 : 	result = stbi__jpeg_info_raw(j, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__jpeg_info_raw@@YAHPAUstbi__jpeg@@PAH11@Z ; stbi__jpeg_info_raw
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 3871 : 	STBI_FREE(j);

	mov	esi, esp
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3872 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 3873 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_info@@YAHPAUstbi__context@@PAH11@Z ENDP	; stbi__jpeg_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z
_TEXT	SEGMENT
_j$ = -20						; size = 4
_result$ = -8						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_ri$ = 28						; size = 4
?stbi__jpeg_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z PROC ; stbi__jpeg_load, COMDAT

; 3830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3831 : 	unsigned char* result;
; 3832 : 	stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

	push	18456					; 00004818H
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3833 : 	STBI_NOTUSED(ri);
; 3834 : 	j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3835 : 	stbi__setup_jpeg(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__setup_jpeg@@YAXPAUstbi__jpeg@@@Z	; stbi__setup_jpeg
	add	esp, 4

; 3836 : 	result = load_jpeg_image(j, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	call	?load_jpeg_image@@YAPAEPAUstbi__jpeg@@PAH11H@Z ; load_jpeg_image
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 3837 : 	STBI_FREE(j);

	mov	esi, esp
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3838 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 3839 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_load@@YAPAXPAUstbi__context@@PAH11HPAUstbi__result_info@@@Z ENDP ; stbi__jpeg_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__jpeg_test@@YAHPAUstbi__context@@@Z
_TEXT	SEGMENT
_j$ = -20						; size = 4
_r$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__jpeg_test@@YAHPAUstbi__context@@@Z PROC		; stbi__jpeg_test, COMDAT

; 3842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 3843 : 	int r;
; 3844 : 	stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

	push	18456					; 00004818H
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 3845 : 	j->s = s;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx

; 3846 : 	stbi__setup_jpeg(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__setup_jpeg@@YAXPAUstbi__jpeg@@@Z	; stbi__setup_jpeg
	add	esp, 4

; 3847 : 	r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

	push	1
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	?stbi__decode_jpeg_header@@YAHPAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 3848 : 	stbi__rewind(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__rewind@@YAXPAUstbi__context@@@Z	; stbi__rewind
	add	esp, 4

; 3849 : 	STBI_FREE(j);

	mov	esi, esp
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3850 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 3851 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__jpeg_test@@YAHPAUstbi__context@@@Z ENDP		; stbi__jpeg_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__rewind@@YAXPAUstbi__context@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?stbi__rewind@@YAXPAUstbi__context@@@Z PROC		; stbi__rewind, COMDAT

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 798  : 	// conceptually rewind SHOULD rewind to the beginning of the stream,
; 799  : 	// but we just rewind to the beginning of the initial buffer, because
; 800  : 	// we only use it after doing 'test', which only ever looks at at most 92 bytes
; 801  : 	s->img_buffer = s->img_buffer_original;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	DWORD PTR [eax+168], edx

; 802  : 	s->img_buffer_end = s->img_buffer_original_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+172], edx

; 803  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__rewind@@YAXPAUstbi__context@@@Z ENDP		; stbi__rewind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_f$ = 12						; size = 4
?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z PROC ; stbi__start_file, COMDAT

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 789  : 	stbi__start_callbacks(s, &stbi__stdio_callbacks, (void*)f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	OFFSET ?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ENDP ; stbi__start_file
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__stdio_eof@@YAHPAX@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
?stbi__stdio_eof@@YAHPAX@Z PROC				; stbi__stdio_eof, COMDAT

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 777  : 	return feof((FILE*)user);

	mov	esi, esp
	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	call	DWORD PTR __imp__feof
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 778  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__stdio_eof@@YAHPAX@Z ENDP				; stbi__stdio_eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__stdio_skip@@YAXPAXH@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
_n$ = 12						; size = 4
?stbi__stdio_skip@@YAXPAXH@Z PROC			; stbi__stdio_skip, COMDAT

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 772  : 	fseek((FILE*)user, n, SEEK_CUR);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 773  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__stdio_skip@@YAXPAXH@Z ENDP			; stbi__stdio_skip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__stdio_read@@YAHPAXPADH@Z
_TEXT	SEGMENT
_user$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
?stbi__stdio_read@@YAHPAXPADH@Z PROC			; stbi__stdio_read, COMDAT

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 767  : 	return (int)fread(data, 1, size, (FILE*)user);

	mov	esi, esp
	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 768  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__stdio_read@@YAHPAXPADH@Z ENDP			; stbi__stdio_read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_user$ = 16						; size = 4
?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z PROC ; stbi__start_callbacks, COMDAT

; 753  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 754  : 	s->io = *c;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 755  : 	s->io_user_data = user;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _user$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 756  : 	s->buflen = sizeof(s->buffer_start);

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+36], 128			; 00000080H

; 757  : 	s->read_from_callbacks = 1;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 1

; 758  : 	s->img_buffer_original = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 759  : 	stbi__refill_buffer(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__refill_buffer@@YAXPAUstbi__context@@@Z ; stbi__refill_buffer
	add	esp, 4

; 760  : 	s->img_buffer_original_end = s->img_buffer_end;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	mov	DWORD PTR [eax+180], edx

; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ENDP ; stbi__start_callbacks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z
_TEXT	SEGMENT
tv71 = -196						; size = 4
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z PROC	; stbi__start_mem, COMDAT

; 744  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 745  : 	s->io.read = NULL;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+16], 0

; 746  : 	s->read_from_callbacks = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 0

; 747  : 	s->img_buffer = s->img_buffer_original = (stbi_uc*)buffer;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax+176], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+168], eax

; 748  : 	s->img_buffer_end = s->img_buffer_original_end = (stbi_uc*)buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [ecx+180], edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [eax+172], ecx

; 749  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ENDP	; stbi__start_mem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__refill_buffer@@YAXPAUstbi__context@@@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_s$ = 8							; size = 4
?stbi__refill_buffer@@YAXPAUstbi__context@@@Z PROC	; stbi__refill_buffer, COMDAT

; 1453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1454 : 	int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);

	mov	esi, esp
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$[ebp], eax

; 1455 : 	if (n == 0) {

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@stbi__refi

; 1456 : 		// at end of file, treat same as if from memory, but need to handle case
; 1457 : 		// where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1458 : 		s->read_from_callbacks = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1459 : 		s->img_buffer = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 1460 : 		s->img_buffer_end = s->buffer_start + 1;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 41					; 00000029H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 1461 : 		*s->img_buffer = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	BYTE PTR [ecx], 0

; 1462 : 	}

	jmp	SHORT $LN1@stbi__refi
$LN2@stbi__refi:

; 1463 : 	else {
; 1464 : 		s->img_buffer = s->buffer_start;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 1465 : 		s->img_buffer_end = s->buffer_start + n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+172], edx
$LN1@stbi__refi:

; 1466 : 	}
; 1467 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__refill_buffer@@YAXPAUstbi__context@@@Z ENDP	; stbi__refill_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__sse2_available@@YAHXZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_info3$ = -8						; size = 4
?stbi__sse2_available@@YAHXZ PROC			; stbi__sse2_available, COMDAT

; 680  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 681  : 	int info3 = stbi__cpuid3();

	call	?stbi__cpuid3@@YAHXZ			; stbi__cpuid3
	mov	DWORD PTR _info3$[ebp], eax

; 682  : 	return ((info3 >> 26) & 1) != 0;

	mov	eax, DWORD PTR _info3$[ebp]
	sar	eax, 26					; 0000001aH
	and	eax, 1
	je	SHORT $LN3@stbi__sse2
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
	mov	DWORD PTR tv68[ebp], 0
$LN4@stbi__sse2:
	mov	eax, DWORD PTR tv68[ebp]

; 683  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?stbi__sse2_available@@YAHXZ ENDP			; stbi__sse2_available
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT ?stbi__cpuid3@@YAHXZ
_TEXT	SEGMENT
_info$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
?stbi__cpuid3@@YAHXZ PROC				; stbi__cpuid3, COMDAT

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 659  : 	int info[4];
; 660  : 	__cpuid(info, 1);

	lea	esi, DWORD PTR _info$[ebp]
	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 661  : 	return info[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _info$[ebp+ecx]

; 662  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi__cpui
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@stbi__cpui:
	DD	1
	DD	$LN4@stbi__cpui
$LN4@stbi__cpui:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@stbi__cpui
$LN3@stbi__cpui:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
?stbi__cpuid3@@YAHXZ ENDP				; stbi__cpuid3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_noheader_buffer
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_noheader_buffer PROC			; COMDAT

; 4349 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5620				; 000015f4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5620]
	mov	ecx, 1405				; 0000057dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4350 : 	stbi__zbuf a;
; 4351 : 	a.zbuffer = (stbi_uc*)ibuffer;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4352 : 	a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	add	eax, DWORD PTR _ilen$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4353 : 	if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _olen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ; stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 4354 : 		return (int)(a.zout - a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN1@stbi_zlib_
	jmp	SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4355 : 	else
; 4356 : 		return -1;

	or	eax, -1
$LN1@stbi_zlib_:

; 4357 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 5620				; 000015f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@stbi_zlib_:
	DD	1
	DD	$LN6@stbi_zlib_
$LN6@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN5@stbi_zlib_
$LN5@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_noheader_malloc
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_noheader_malloc PROC			; COMDAT

; 4332 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5632				; 00001600H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5632]
	mov	ecx, 1408				; 00000580H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4333 : 	stbi__zbuf a;
; 4334 : 	char* p = (char*)stbi__malloc(16384);

	push	16384					; 00004000H
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4335 : 	if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4336 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4337 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4338 : 	if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

	push	0
	push	1
	push	16384					; 00004000H
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ; stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4339 : 		if (outlen)* outlen = (int)(a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@stbi_zlib_:

; 4340 : 		return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN1@stbi_zlib_

; 4341 : 	}

	jmp	SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 4342 : 	else {
; 4343 : 		STBI_FREE(a.zout_start);

	mov	esi, esp
	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4344 : 		return NULL;

	xor	eax, eax
$LN1@stbi_zlib_:

; 4345 : 	}
; 4346 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 5632				; 00001600H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_buffer
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_buffer PROC				; COMDAT

; 4321 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5620				; 000015f4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5620]
	mov	ecx, 1405				; 0000057dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4322 : 	stbi__zbuf a;
; 4323 : 	a.zbuffer = (stbi_uc*)ibuffer;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4324 : 	a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

	mov	eax, DWORD PTR _ibuffer$[ebp]
	add	eax, DWORD PTR _ilen$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4325 : 	if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

	push	1
	push	0
	mov	eax, DWORD PTR _olen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ; stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 4326 : 		return (int)(a.zout - a.zout_start);

	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN1@stbi_zlib_
	jmp	SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4327 : 	else
; 4328 : 		return -1;

	or	eax, -1
$LN1@stbi_zlib_:

; 4329 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 5620				; 000015f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@stbi_zlib_:
	DD	1
	DD	$LN6@stbi_zlib_
$LN6@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN5@stbi_zlib_
$LN5@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_malloc PROC				; COMDAT

; 4299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4300 : 	return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

	mov	eax, DWORD PTR _outlen$[ebp]
	push	eax
	push	16384					; 00004000H
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_stbi_zlib_decode_malloc_guesssize
	add	esp, 16					; 00000010H

; 4301 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc_guesssize_headerflag
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_parse_header$ = 24					; size = 4
_stbi_zlib_decode_malloc_guesssize_headerflag PROC	; COMDAT

; 4304 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5632				; 00001600H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5632]
	mov	ecx, 1408				; 00000580H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4305 : 	stbi__zbuf a;
; 4306 : 	char* p = (char*)stbi__malloc(initial_size);

	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4307 : 	if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4308 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4309 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4310 : 	if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

	mov	eax, DWORD PTR _parse_header$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _initial_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ; stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4311 : 		if (outlen)* outlen = (int)(a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@stbi_zlib_:

; 4312 : 		return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN1@stbi_zlib_

; 4313 : 	}

	jmp	SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 4314 : 	else {
; 4315 : 		STBI_FREE(a.zout_start);

	mov	esi, esp
	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4316 : 		return NULL;

	xor	eax, eax
$LN1@stbi_zlib_:

; 4317 : 	}
; 4318 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 5632				; 00001600H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_zlib_decode_malloc_guesssize
_TEXT	SEGMENT
_p$ = -4092						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_stbi_zlib_decode_malloc_guesssize PROC			; COMDAT

; 4282 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5632				; 00001600H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-5632]
	mov	ecx, 1408				; 00000580H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4283 : 	stbi__zbuf a;
; 4284 : 	char* p = (char*)stbi__malloc(initial_size);

	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	call	?stbi__malloc@@YAPAXI@Z			; stbi__malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 4285 : 	if (p == NULL) return NULL;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4286 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 4287 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _a$[ebp+4], eax

; 4288 : 	if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

	push	1
	push	1
	mov	eax, DWORD PTR _initial_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	?stbi__do_zlib@@YAHPAUstbi__zbuf@@PADHHH@Z ; stbi__do_zlib
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 4289 : 		if (outlen)* outlen = (int)(a.zout - a.zout_start);

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	eax, DWORD PTR _a$[ebp+16]
	sub	eax, DWORD PTR _a$[ebp+20]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@stbi_zlib_:

; 4290 : 		return a.zout_start;

	mov	eax, DWORD PTR _a$[ebp+20]
	jmp	SHORT $LN1@stbi_zlib_

; 4291 : 	}

	jmp	SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 4292 : 	else {
; 4293 : 		STBI_FREE(a.zout_start);

	mov	esi, esp
	mov	eax, DWORD PTR _a$[ebp+20]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4294 : 		return NULL;

	xor	eax, eax
$LN1@stbi_zlib_:

; 4295 : 	}
; 4296 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@stbi_zlib_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 5632				; 00001600H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@stbi_zlib_:
	DD	1
	DD	$LN8@stbi_zlib_
$LN8@stbi_zlib_:
	DD	-4080					; fffff010H
	DD	4072					; 00000fe8H
	DD	$LN7@stbi_zlib_
$LN7@stbi_zlib_:
	DB	97					; 00000061H
	DB	0
_stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_set_flip_vertically_on_load
_TEXT	SEGMENT
_flag_true_if_should_flip$ = 8				; size = 4
_stbi_set_flip_vertically_on_load PROC			; COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1001 : 	stbi__vertically_flip_on_load = flag_true_if_should_flip;

	mov	eax, DWORD PTR _flag_true_if_should_flip$[ebp]
	mov	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, eax

; 1002 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_convert_iphone_png_to_rgb
_TEXT	SEGMENT
_flag_true_if_should_convert$ = 8			; size = 4
_stbi_convert_iphone_png_to_rgb PROC			; COMDAT

; 4798 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4799 : 	stbi__de_iphone_flag = flag_true_if_should_convert;

	mov	eax, DWORD PTR _flag_true_if_should_convert$[ebp]
	mov	DWORD PTR ?stbi__de_iphone_flag@@3HA, eax

; 4800 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_set_unpremultiply_on_load
_TEXT	SEGMENT
_flag_true_if_should_unpremultiply$ = 8			; size = 4
_stbi_set_unpremultiply_on_load PROC			; COMDAT

; 4793 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 4794 : 	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;

	mov	eax, DWORD PTR _flag_true_if_should_unpremultiply$[ebp]
	mov	DWORD PTR ?stbi__unpremultiply_on_load@@3HA, eax

; 4795 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_16_bit_from_file
_TEXT	SEGMENT
_pos$ = -216						; size = 4
_s$ = -204						; size = 184
_r$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_stbi_is_16_bit_from_file PROC				; COMDAT

; 7389 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7390 : 	int r;
; 7391 : 	stbi__context s;
; 7392 : 	long pos = ftell(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__ftell
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 7393 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 7394 : 	r = stbi__is_16_main(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__is_16_main@@YAHPAUstbi__context@@@Z ; stbi__is_16_main
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax

; 7395 : 	fseek(f, pos, SEEK_SET);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7396 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 7397 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_16
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@stbi_is_16:
	DD	1
	DD	$LN4@stbi_is_16
$LN4@stbi_is_16:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_16
$LN3@stbi_is_16:
	DB	115					; 00000073H
	DB	0
_stbi_is_16_bit_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_16_bit
_TEXT	SEGMENT
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_stbi_is_16_bit PROC					; COMDAT

; 7379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7380 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 7381 : 	int result;
; 7382 : 	if (!f) return stbi__err("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@stbi_is_16
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi_is_16
$LN2@stbi_is_16:

; 7383 : 	result = stbi_is_16_bit_from_file(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_stbi_is_16_bit_from_file
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax

; 7384 : 	fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7385 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi_is_16:

; 7386 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_16_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_info_from_file
_TEXT	SEGMENT
_pos$ = -216						; size = 4
_s$ = -204						; size = 184
_r$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info_from_file PROC				; COMDAT

; 7368 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7369 : 	int r;
; 7370 : 	stbi__context s;
; 7371 : 	long pos = ftell(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__ftell
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 7372 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 7373 : 	r = stbi__info_main(&s, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z ; stbi__info_main
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r$[ebp], eax

; 7374 : 	fseek(f, pos, SEEK_SET);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7375 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 7376 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_info
_TEXT	SEGMENT
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info PROC						; COMDAT

; 7358 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7359 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 7360 : 	int result;
; 7361 : 	if (!f) return stbi__err("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@stbi_info
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	jmp	SHORT $LN1@stbi_info
$LN2@stbi_info:

; 7362 : 	result = stbi_info_from_file(f, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_stbi_info_from_file
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 7363 : 	fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7364 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi_info:

; 7365 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_16_bit_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_user$ = 12						; size = 4
_stbi_is_16_bit_from_callbacks PROC			; COMDAT

; 7422 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7423 : 	stbi__context s;
; 7424 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 7425 : 	return stbi__is_16_main(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__is_16_main@@YAHPAUstbi__context@@@Z ; stbi__is_16_main
	add	esp, 4

; 7426 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_16
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_is_16:
	DD	1
	DD	$LN4@stbi_is_16
$LN4@stbi_is_16:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_16
$LN3@stbi_is_16:
	DB	115					; 00000073H
	DB	0
_stbi_is_16_bit_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_16_bit_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_stbi_is_16_bit_from_memory PROC			; COMDAT

; 7415 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7416 : 	stbi__context s;
; 7417 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 7418 : 	return stbi__is_16_main(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__is_16_main@@YAHPAUstbi__context@@@Z ; stbi__is_16_main
	add	esp, 4

; 7419 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_16
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_is_16:
	DD	1
	DD	$LN4@stbi_is_16
$LN4@stbi_is_16:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_16
$LN3@stbi_is_16:
	DB	115					; 00000073H
	DB	0
_stbi_is_16_bit_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_info_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_callbacks PROC				; COMDAT

; 7408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7409 : 	stbi__context s;
; 7410 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 7411 : 	return stbi__info_main(&s, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z ; stbi__info_main
	add	esp, 16					; 00000010H

; 7412 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_info_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_memory PROC				; COMDAT

; 7401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 7402 : 	stbi__context s;
; 7403 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 7404 : 	return stbi__info_main(&s, x, y, comp);

	mov	eax, DWORD PTR _comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__info_main@@YAHPAUstbi__context@@PAH11@Z ; stbi__info_main
	add	esp, 16					; 00000010H

; 7405 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_info_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_info_:
	DD	1
	DD	$LN4@stbi_info_
$LN4@stbi_info_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_info_
$LN3@stbi_info_:
	DB	115					; 00000073H
	DB	0
_stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_image_free
_TEXT	SEGMENT
_retval_from_stbi_load$ = 8				; size = 4
_stbi_image_free PROC					; COMDAT

; 985  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 986  : 	STBI_FREE(retval_from_stbi_load);

	mov	esi, esp
	mov	eax, DWORD PTR _retval_from_stbi_load$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 987  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_failure_reason
_TEXT	SEGMENT
_stbi_failure_reason PROC				; COMDAT

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 880  : 	return stbi__g_failure_reason;

	mov	eax, DWORD PTR ?stbi__g_failure_reason@@3PBDB

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_hdr_from_file
_TEXT	SEGMENT
_s$ = -216						; size = 184
_res$ = -24						; size = 4
_pos$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_stbi_is_hdr_from_file PROC				; COMDAT

; 1398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1399 : #ifndef STBI_NO_HDR
; 1400 : 	long pos = ftell(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__ftell
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pos$[ebp], eax

; 1401 : 	int res;
; 1402 : 	stbi__context s;
; 1403 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 1404 : 	res = stbi__hdr_test(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax

; 1405 : 	fseek(f, pos, SEEK_SET);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1406 : 	return res;

	mov	eax, DWORD PTR _res$[ebp]

; 1407 : #else
; 1408 : 	STBI_NOTUSED(f);
; 1409 : 	return 0;
; 1410 : #endif
; 1411 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_hd
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@stbi_is_hd:
	DD	1
	DD	$LN4@stbi_is_hd
$LN4@stbi_is_hd:
	DD	-216					; ffffff28H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_hd
$LN3@stbi_is_hd:
	DB	115					; 00000073H
	DB	0
_stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_hdr
_TEXT	SEGMENT
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_stbi_is_hdr PROC					; COMDAT

; 1387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1388 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1389 : 	int result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 1390 : 	if (f) {

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN2@stbi_is_hd

; 1391 : 		result = stbi_is_hdr_from_file(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_stbi_is_hdr_from_file
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax

; 1392 : 		fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@stbi_is_hd:

; 1393 : 	}
; 1394 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1395 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_hdr_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_stbi_is_hdr_from_memory PROC				; COMDAT

; 1373 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1374 : #ifndef STBI_NO_HDR
; 1375 : 	stbi__context s;
; 1376 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 1377 : 	return stbi__hdr_test(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4

; 1378 : #else
; 1379 : 	STBI_NOTUSED(buffer);
; 1380 : 	STBI_NOTUSED(len);
; 1381 : 	return 0;
; 1382 : #endif
; 1383 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_hd
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_is_hd:
	DD	1
	DD	$LN4@stbi_is_hd
$LN4@stbi_is_hd:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_hd
$LN3@stbi_is_hd:
	DB	115					; 00000073H
	DB	0
_stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_is_hdr_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_stbi_is_hdr_from_callbacks PROC			; COMDAT

; 1415 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1416 : #ifndef STBI_NO_HDR
; 1417 : 	stbi__context s;
; 1418 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1419 : 	return stbi__hdr_test(&s);

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__hdr_test@@YAHPAUstbi__context@@@Z ; stbi__hdr_test
	add	esp, 4

; 1420 : #else
; 1421 : 	STBI_NOTUSED(clbk);
; 1422 : 	STBI_NOTUSED(user);
; 1423 : 	return 0;
; 1424 : #endif
; 1425 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_is_hd
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_is_hd:
	DD	1
	DD	$LN4@stbi_is_hd
$LN4@stbi_is_hd:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_is_hd
$LN3@stbi_is_hd:
	DB	115					; 00000073H
	DB	0
_stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_ldr_to_hdr_scale
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_ldr_to_hdr_scale PROC				; COMDAT

; 1431 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR ?stbi__l2h_scale@@3MA, xmm0
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_ldr_to_hdr_gamma
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_ldr_to_hdr_gamma PROC				; COMDAT

; 1430 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
	movss	xmm0, DWORD PTR _gamma$[ebp]
	movss	DWORD PTR ?stbi__l2h_gamma@@3MA, xmm0
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_hdr_to_ldr_scale
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_hdr_to_ldr_scale PROC				; COMDAT

; 1437 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR ?stbi__h2l_scale_i@@3MA, xmm0
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_hdr_to_ldr_gamma
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_hdr_to_ldr_gamma PROC				; COMDAT

; 1436 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _gamma$[ebp]
	movss	DWORD PTR ?stbi__h2l_gamma_i@@3MA, xmm0
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_loadf_from_file
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf_from_file PROC				; COMDAT

; 1359 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1360 : 	stbi__context s;
; 1361 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 1362 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z ; stbi__loadf_main
	add	esp, 20					; 00000014H

; 1363 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_loadf
_TEXT	SEGMENT
tv71 = -220						; size = 4
_f$ = -20						; size = 4
_result$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf PROC					; COMDAT

; 1349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1350 : 	float* result;
; 1351 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1352 : 	if (!f) return stbi__errpf("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@stbi_loadf
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_loadf
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_loadf:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 1353 : 	result = stbi_loadf_from_file(f, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_loadf_from_file
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1354 : 	fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1355 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi_loadf:

; 1356 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_loadf_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_callbacks PROC				; COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1342 : 	stbi__context s;
; 1343 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1344 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z ; stbi__loadf_main
	add	esp, 20					; 00000014H

; 1345 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_loadf_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_memory PROC				; COMDAT

; 1334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1335 : 	stbi__context s;
; 1336 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 1337 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__loadf_main@@YAPAMPAUstbi__context@@PAH11H@Z ; stbi__loadf_main
	add	esp, 20					; 00000014H

; 1338 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_loadf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_loadf:
	DD	1
	DD	$LN4@stbi_loadf
$LN4@stbi_loadf:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_loadf
$LN3@stbi_loadf:
	DB	115					; 00000073H
	DB	0
_stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_from_file_16
_TEXT	SEGMENT
_s$ = -204						; size = 184
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_from_file_16 PROC				; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1246 : 	stbi__uint16* result;
; 1247 : 	stbi__context s;
; 1248 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 1249 : 	result = stbi__load_and_postprocess_16bit(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1250 : 	if (result) {

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN2@stbi_load_

; 1251 : 		// need to 'unget' all the characters in the IO buffer
; 1252 : 		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _s$[ebp+172]
	sub	eax, DWORD PTR _s$[ebp+168]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@stbi_load_:

; 1253 : 	}
; 1254 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1255 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@stbi_load_:
	DD	1
	DD	$LN5@stbi_load_
$LN5@stbi_load_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_16
_TEXT	SEGMENT
tv71 = -220						; size = 4
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_16 PROC					; COMDAT

; 1258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1259 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1260 : 	stbi__uint16* result;
; 1261 : 	if (!f) return (stbi_us*)stbi__errpuc("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@stbi_load_
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_load_
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_load_
$LN4@stbi_load_:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_load_:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 1262 : 	result = stbi_load_from_file_16(f, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_load_from_file_16
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1263 : 	fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1264 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi_load_:

; 1265 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_16_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_channels_in_file$ = 24					; size = 4
_desired_channels$ = 28					; size = 4
_stbi_load_16_from_callbacks PROC			; COMDAT

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1279 : 	stbi__context s;
; 1280 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1281 : 	return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);

	mov	eax, DWORD PTR _desired_channels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channels_in_file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H

; 1282 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_16_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_channels_in_file$ = 24					; size = 4
_desired_channels$ = 28					; size = 4
_stbi_load_16_from_memory PROC				; COMDAT

; 1271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1272 : 	stbi__context s;
; 1273 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 1274 : 	return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);

	mov	eax, DWORD PTR _desired_channels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channels_in_file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_16bit@@YAPAGPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_16bit
	add	esp, 20					; 00000014H

; 1275 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_gif_from_memory
_TEXT	SEGMENT
_s$ = -204						; size = 184
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_delays$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_z$ = 28						; size = 4
_comp$ = 32						; size = 4
_req_comp$ = 36						; size = 4
_stbi_load_gif_from_memory PROC				; COMDAT

; 1300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1301 : 	unsigned char* result;
; 1302 : 	stbi__context s;
; 1303 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 1304 : 
; 1305 : 	result = (unsigned char*)stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _delays$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?stbi__load_gif_main@@YAPAXPAUstbi__context@@PAPAHPAH222H@Z ; stbi__load_gif_main
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _result$[ebp], eax

; 1306 : 	if (stbi__vertically_flip_on_load) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	SHORT $LN2@stbi_load_

; 1307 : 		stbi__vertical_flip_slices(result, *x, *y, *z, *comp);

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	?stbi__vertical_flip_slices@@YAXPAXHHHH@Z ; stbi__vertical_flip_slices
	add	esp, 20					; 00000014H
$LN2@stbi_load_:

; 1308 : 	}
; 1309 : 
; 1310 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1311 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@stbi_load_:
	DD	1
	DD	$LN5@stbi_load_
$LN5@stbi_load_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_gif_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_from_file
_TEXT	SEGMENT
_s$ = -204						; size = 184
_result$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_from_file PROC				; COMDAT

; 1232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1233 : 	unsigned char* result;
; 1234 : 	stbi__context s;
; 1235 : 	stbi__start_file(&s, f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__start_file@@YAXPAUstbi__context@@PAU_iobuf@@@Z ; stbi__start_file
	add	esp, 8

; 1236 : 	result = stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1237 : 	if (result) {

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN2@stbi_load_

; 1238 : 		// need to 'unget' all the characters in the IO buffer
; 1239 : 		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _s$[ebp+172]
	sub	eax, DWORD PTR _s$[ebp+168]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@stbi_load_:

; 1240 : 	}
; 1241 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 1242 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@stbi_load_:
	DD	1
	DD	$LN5@stbi_load_
$LN5@stbi_load_:
	DD	-204					; ffffff34H
	DD	184					; 000000b8H
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load
_TEXT	SEGMENT
tv71 = -220						; size = 4
_result$ = -20						; size = 4
_f$ = -8						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load PROC						; COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1223 : 	FILE* f = stbi__fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?stbi__fopen@@YAPAU_iobuf@@PBD0@Z	; stbi__fopen
	add	esp, 8
	mov	DWORD PTR _f$[ebp], eax

; 1224 : 	unsigned char* result;
; 1225 : 	if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@stbi_load
	push	OFFSET ??_C@_0M@JPDHFAGK@can?8t?5fopen@
	call	?stbi__err@@YAHPBD@Z			; stbi__err
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@stbi_load
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN5@stbi_load
$LN4@stbi_load:
	mov	DWORD PTR tv71[ebp], 0
$LN5@stbi_load:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN1@stbi_load
$LN2@stbi_load:

; 1226 : 	result = stbi_load_from_file(f, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_stbi_load_from_file
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax

; 1227 : 	fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1228 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@stbi_load:

; 1229 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_from_callbacks
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_callbacks PROC				; COMDAT

; 1292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1293 : 	stbi__context s;
; 1294 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	eax, DWORD PTR _user$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clbk$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_callbacks@@YAXPAUstbi__context@@PAUstbi_io_callbacks@@PAX@Z ; stbi__start_callbacks
	add	esp, 12					; 0000000cH

; 1295 : 	return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H

; 1296 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\HeaderFiles\Vendor\stb_image.h
;	COMDAT _stbi_load_from_memory
_TEXT	SEGMENT
_s$ = -192						; size = 184
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_memory PROC				; COMDAT

; 1285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __AA12E9A8_stb_image@h
	call	@__CheckForDebuggerJustMyCode@4

; 1286 : 	stbi__context s;
; 1287 : 	stbi__start_mem(&s, buffer, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?stbi__start_mem@@YAXPAUstbi__context@@PBEH@Z ; stbi__start_mem
	add	esp, 12					; 0000000cH

; 1288 : 	return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR _req_comp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?stbi__load_and_postprocess_8bit@@YAPAEPAUstbi__context@@PAH11H@Z ; stbi__load_and_postprocess_8bit
	add	esp, 20					; 00000014H

; 1289 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@stbi_load_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@stbi_load_:
	DD	1
	DD	$LN4@stbi_load_
$LN4@stbi_load_:
	DD	-192					; ffffff40H
	DD	184					; 000000b8H
	DD	$LN3@stbi_load_
$LN3@stbi_load_:
	DB	115					; 00000073H
	DB	0
_stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ?unBind@Texture@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?unBind@Texture@@QAEXXZ PROC				; Texture::unBind, COMDAT
; _this$ = ecx

; 51   : void Texture::unBind() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 52   : 
; 53   : 	glBindTexture(GL_TEXTURE_2D, 0);

	mov	esi, esp
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 54   : 
; 55   : 
; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?unBind@Texture@@QAEXXZ ENDP				; Texture::unBind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ?Bind@Texture@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_sampler$ = 8						; size = 4
?Bind@Texture@@QAEXI@Z PROC				; Texture::Bind, COMDAT
; _this$ = ecx

; 43   : void Texture::Bind(unsigned int sampler) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 44   : 	if (sampler <= 31) {

	cmp	DWORD PTR _sampler$[ebp], 31		; 0000001fH
	ja	SHORT $LN1@Bind

; 45   : 		glActiveTexture(GL_TEXTURE0+sampler);

	mov	eax, DWORD PTR _sampler$[ebp]
	add	eax, 33984				; 000084c0H
	mov	esi, esp
	push	eax
	call	DWORD PTR ___glewActiveTexture
	cmp	esi, esp
	call	__RTC_CheckEsp

; 46   : 		glBindTexture(GL_TEXTURE_2D, Id);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Bind:

; 47   : 
; 48   : 
; 49   : 	}
; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Bind@Texture@@QAEXI@Z ENDP				; Texture::Bind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ??1Texture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1Texture@@QAE@XZ PROC					; Texture::~Texture, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Texture@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 37   : 	glDeleteTextures(1, &Id);

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glDeleteTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 38   : 	stbi_image_free(cpuBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_stbi_image_free
	add	esp, 4

; 39   : 	
; 40   : 
; 41   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Texture@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Texture@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Texture@@QAE@XZ ENDP					; Texture::~Texture
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv196 = -452						; size = 4
tv74 = -448						; size = 4
tv194 = -444						; size = 4
tv191 = -444						; size = 4
tv81 = -440						; size = 4
tv78 = -440						; size = 4
$T2 = -432						; size = 28
$T3 = -396						; size = 28
$T4 = -360						; size = 28
_fullpath$ = -132					; size = 28
_ending$ = -96						; size = 28
_FILE$ = -60						; size = 28
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 28
??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Texture::Texture, COMDAT
; _this$ = ecx

; 11   : Texture::Texture(std::string name) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 440				; 000001b8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 12   : 	Texture::path = name;

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 13   : 
; 14   : 	std::string FILE = "src/res/Textures/";

	push	OFFSET ??_C@_0BC@MIBMIPKG@src?1res?1Textures?1@
	lea	ecx, DWORD PTR _FILE$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 15   : 	std::string ending = ".png";

	push	OFFSET ??_C@_04EEOGCCFB@?4png@
	lea	ecx, DWORD PTR _ending$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 16   : 
; 17   : 	std::string fullpath = FILE + path + ending;

	lea	eax, DWORD PTR _ending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR _FILE$[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR tv191[ebp]
	push	edx
	lea	eax, DWORD PTR _fullpath$[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 18   : 	
; 19   : 	cpuBuffer = stbi_load(fullpath.c_str(),&width,&height,&BPP,4);//loads in the texture data into cpuBuffer and stores the width,height and bpp

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	lea	ecx, DWORD PTR _fullpath$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_stbi_load
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 20   : 
; 21   : 	if (cpuBuffer ==0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	$LN2@Texture

; 22   : 		std::cout << "the file " + fullpath + " could not be found!!!" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BH@PIKNLKAJ@?5could?5not?5be?5found?$CB?$CB?$CB@
	lea	eax, DWORD PTR _fullpath$[ebp]
	push	eax
	push	OFFSET ??_C@_09LDDNJKDN@the?5file?5@
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv194[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv194[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv196[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv196[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@Texture:

; 23   : 
; 24   : 	}
; 25   : 	glGenTextures(1,&Id);//this allocates a buffer and sets a id to use it

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, esp
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 26   : 	glBindTexture(GL_TEXTURE_2D,Id);//binds the buffer to texture2d

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 27   : 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);//tells how the data is formated 

	mov	esi, esp
	push	1
	push	3317					; 00000cf5H
	call	DWORD PTR __imp__glPixelStorei@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 28   : 	glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);//sets the filters to gl_nearest so that the pixel art will look right

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@46180000
	movss	DWORD PTR [esp], xmm0
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 29   : 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	mov	esi, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@46180000
	movss	DWORD PTR [esp], xmm0
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   : 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,cpuBuffer);//loads in the texture to the GPU for use later

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	5121					; 00001401H
	push	6408					; 00001908H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	push	6408					; 00001908H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 31   : 	glBindTexture(GL_TEXTURE_2D, 0);//unbinds

	mov	esi, esp
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 32   : 	
; 33   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _fullpath$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ending$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _FILE$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@Texture
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN17@Texture:
	DD	3
	DD	$LN16@Texture
$LN16@Texture:
	DD	-60					; ffffffc4H
	DD	28					; 0000001cH
	DD	$LN12@Texture
	DD	-96					; ffffffa0H
	DD	28					; 0000001cH
	DD	$LN13@Texture
	DD	-132					; ffffff7cH
	DD	28					; 0000001cH
	DD	$LN14@Texture
$LN14@Texture:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN13@Texture:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN12@Texture:
	DB	70					; 00000046H
	DB	73					; 00000049H
	DB	76					; 0000004cH
	DB	69					; 00000045H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	lea	ecx, DWORD PTR _FILE$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3:
	lea	ecx, DWORD PTR _ending$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5:
	lea	ecx, DWORD PTR _fullpath$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$6:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$7:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Texture::Texture
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :     const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1341 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1335 :     _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1336 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1337 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4219 :     const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4220 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4221 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4215 :     _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4216 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4217 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 4211 :     void _Swap_proxy_and_iterators(basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4212 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators

; 4213 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4201 :     [[noreturn]] static void _Xlen() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4202 :         _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 4203 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -245						; size = 1
__Al$3 = -44						; size = 4
__Ptr$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4185 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4186 :         _Mypair._Myval2._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4187 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 4188 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$4[ebp], ecx

; 4189 :             auto& _Al          = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$3[ebp], eax

; 4190 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
	add	esp, 4

; 4191 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$4[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$3[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4192 :         }
; 4193 : 
; 4194 :         _Mypair._Myval2._Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4195 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 4196 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4197 :         // write can alias this
; 4198 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 4199 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4177 :     void _Tidy_init() noexcept { // initialize basic_string data members

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4178 :         _Mypair._Myval2._Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4179 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 4180 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4181 :         // write can alias this
; 4182 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 4183 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$ = -32						; size = 4
__Ptr$ = -20						; size = 4
_this$ = -8						; size = 4
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 4160 :     void _Become_small() {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4161 :         // release any held storage and return to small string mode
; 4162 :         // pre: *this is in large string mode
; 4163 :         // pre: this is small enough to return to small string mode
; 4164 :         _Mypair._Myval2._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4165 :         const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 4166 :         auto& _Al          = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 4167 :         _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
	add	esp, 4

; 4168 :         _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 4169 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4170 :         _Mypair._Myval2._Myres = _BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 4171 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4098 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4099 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __Requested$[ebp]
	push	edx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH

; 4100 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T2 = -228						; size = 4
__Masked$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4085 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4086 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	eax, DWORD PTR __Requested$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Masked$[ebp], eax

; 4087 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, DWORD PTR __Masked$[ebp]
	cmp	eax, DWORD PTR __Max$[ebp]
	jbe	SHORT $LN2@Calculate_

; 4088 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4089 :         }
; 4090 : 
; 4091 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Old$[ebp], ecx
	jbe	SHORT $LN3@Calculate_

; 4092 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4093 :         }
; 4094 : 
; 4095 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Old$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR __Masked$[ebp]
	push	edx
	call	??$_Max_value@I@std@@YAABIABI0@Z	; std::_Max_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4096 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Calculate_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@Calculate_:
	DD	1
	DD	$LN7@Calculate_
$LN7@Calculate_:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN5@Calculate_
$LN5@Calculate_:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -221						; size = 1
__Old_size$2 = -20					; size = 4
_this$ = -8						; size = 4
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3619 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3620 :         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	jbe	SHORT $LN2@reserve

; 3621 :             return; // nothing to do

	jmp	SHORT $LN1@reserve
$LN2@reserve:

; 3622 :         }
; 3623 : 
; 3624 :         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	jne	SHORT $LN3@reserve

; 3625 :             return; // nothing to do

	jmp	SHORT $LN1@reserve
$LN3@reserve:

; 3626 :         }
; 3627 : 
; 3628 :         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	jae	SHORT $LN4@reserve

; 3629 :             const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$2[ebp], ecx

; 3630 :             _Reallocate_grow_by(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newcap$[ebp]
	sub	edx, DWORD PTR __Old_size$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3631 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 3632 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3633 :                 });
; 3634 : 
; 3635 :             _Mypair._Myval2._Mysize = _Old_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Old_size$2[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3636 :             return;

	jmp	SHORT $LN1@reserve
$LN4@reserve:

; 3637 :         }
; 3638 : 
; 3639 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

	cmp	DWORD PTR __Newcap$[ebp], 16		; 00000010H
	jae	SHORT $LN1@reserve
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@reserve

; 3640 :             // deallocate everything; switch back to "small" mode
; 3641 :             _Become_small();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
$LN1@reserve:

; 3642 :             return;
; 3643 :         }
; 3644 : 
; 3645 :         // ignore requests to reserve to [_BUF_SIZE, _Myres)
; 3646 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T2 = -276						; size = 4
$T3 = -264						; size = 4
$T4 = -252						; size = 4
__Storage_max$ = -48					; size = 4
__Alloc_max$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3596 :     _NODISCARD size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3597 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	add	esp, 4
	mov	DWORD PTR __Alloc_max$[ebp], eax

; 3598 :         const size_type _Storage_max = // can always store small string

	mov	DWORD PTR $T4[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR __Alloc_max$[ebp]
	push	ecx
	call	??$_Max_value@I@std@@YAABIABI0@Z	; std::_Max_value<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Storage_max$[ebp], edx

; 3599 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3600 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, DWORD PTR __Storage_max$[ebp]
	sub	eax, 1
	mov	DWORD PTR $T3[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 3601 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3602 :         );
; 3603 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@max_size
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@max_size:
	DD	1
	DD	$LN5@max_size
$LN5@max_size:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN3@max_size
$LN3@max_size:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3592 :     _NODISCARD size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3593 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 3594 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 3578 :     _NODISCARD _Ret_z_ const _Elem* data() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3579 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3580 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3574 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3575 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3576 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2890 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2891 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2892 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Old_ptr$3 = -20					; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2871 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2872 :         // assign [_Ptr, _Ptr + _Count)
; 2873 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	ja	SHORT $LN2@assign

; 2874 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 2875 :             _Mypair._Myval2._Mysize = _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2876 :             _Traits::move(_Old_ptr, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	push	edx
	call	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 2877 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$3[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2878 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 2879 :         }
; 2880 : 
; 2881 :         return _Reallocate_for(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 2882 :             _Count,
; 2883 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2884 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2885 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2886 :             },
; 2887 :             _Ptr);
; 2888 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2786 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2787 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2788 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Old_ptr$3 = -32					; size = 4
__Old_size$ = -20					; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2764 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2765 :         // append [_Ptr, _Ptr + _Count)
; 2766 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 2767 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], ecx
	ja	SHORT $LN2@append

; 2768 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 2769 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$3[ebp], eax

; 2770 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$3[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 2771 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$3[ebp]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2772 :             return *this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 2773 :         }
; 2774 : 
; 2775 :         return _Reallocate_grow_by(

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2776 :             _Count,
; 2777 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2778 :                 const size_type _Count) {
; 2779 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2780 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2781 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2782 :             },
; 2783 :             _Ptr, _Count);
; 2784 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2738 :     basic_string& append(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2739 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2740 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2729 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2730 :         return append(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2731 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2718 :     basic_string& operator+=(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2719 :         return append(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2720 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2691 :     basic_string& operator=(const basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2692 :         if (this != _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	je	SHORT $LN2@operator

; 2693 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN2@operator:

; 2694 :         }
; 2695 : 
; 2696 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 2697 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2655 :     void _Copy_assign(const basic_string& _Right, false_type) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2656 :         _Pocca(_Getal(), _Right._Getal());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
	add	esp, 8

; 2657 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2658 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -60					; size = 4
_$S8$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2627 :     ~basic_string() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2628 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2629 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2630 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S8$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S8$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 2631 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __To_delete$[ebp], ecx

; 2632 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2633 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	eax, DWORD PTR __To_delete$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 2634 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2635 :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@basic_stri:
	DD	1
	DD	$LN5@basic_stri
$LN5@basic_stri:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN3@basic_stri
$LN3@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	56					; 00000038H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2514 :     void _Take_contents(basic_string& _Right, true_type) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2515 :         // assign by stealing _Right's buffer, memcpy optimization
; 2516 :         // pre: this != &_Right
; 2517 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2518 :         // pre: *this owns no memory, iterators orphaned (note:
; 2519 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2520 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2521 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 2522 :             // take ownership of _Right's iterators along with its buffer
; 2523 :             _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 2524 :         } else {

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 2525 :             _Right._Mypair._Myval2._Orphan_all();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Take_conte:

; 2526 :         }
; 2527 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2528 : 
; 2529 :         _Memcpy_val_from(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 2530 :         _Right._Tidy_init();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2531 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right_data_mem$ = -44					; size = 4
__My_data_mem$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2505 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2506 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2507 :         const auto _My_data_mem =

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __My_data_mem$[ebp], eax

; 2508 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2509 :         const auto _Right_data_mem =

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __Right_data_mem$[ebp], eax

; 2510 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2511 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	push	24					; 00000018H
	mov	eax, DWORD PTR __Right_data_mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data_mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2512 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -245						; size = 1
$T3 = -233						; size = 1
$T4 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2416 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4
	push	eax
	movzx	eax, BYTE PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2417 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2418 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2419 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -265						; size = 1
__Proxy$ = -64						; size = 8
_$S10$ = -45						; size = 1
__Alproxy$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2333 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2334 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S10$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S10$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 2335 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2336 :         _Tidy_init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2337 :         assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2338 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2339 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN9@basic_stri:
	DD	2
	DD	$LN8@basic_stri
$LN8@basic_stri:
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN5@basic_stri
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN6@basic_stri
$LN6@basic_stri:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN5@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	48					; 00000030H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2285 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2286 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2287 :         _Tidy_init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2288 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2188 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2186 :         _Bxty() {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2160 :     bool _Large_string_engaged() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Large_stri
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Large_stri
$LN3@Large_stri:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
	mov	al, BYTE PTR tv66[ebp]

; 2162 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2151 :     const value_type* _Myptr() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 2153 :         if (_Large_string_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2155 :         }
; 2156 : 
; 2157 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2158 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2142 :     value_type* _Myptr() {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 2144 :         if (_Large_string_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2146 :         }
; 2147 : 
; 2148 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2149 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 679  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 681  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 785  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 781  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 772  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$allocator@D@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$allocator@D@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$allocator@D@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -220						; size = 4
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 29   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Min_value@I@std@@YAABIABI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __DB22397A_utility
	call	@__CheckForDebuggerJustMyCode@4

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Min_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Min_value
$LN3@Min_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]

; 31   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Min_value@I@std@@YAABIABI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Min_value@I@std@@YAABIABI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 404  :     _NODISCARD static constexpr int_type eof() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 405  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 406  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 396  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 397  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 398  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 376  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 377  :         _Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 378  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::move, COMDAT

; 365  :         const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 368  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::move
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 330  :         const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 331  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 333  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::copy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 309  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __C564DC25_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 310  :         // find length of null-terminated string
; 311  : #if _HAS_CXX17
; 312  : #ifdef __cpp_char8_t
; 313  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 314  : #if _HAS_U8_INTRINSICS
; 315  :             return __builtin_u8strlen(_First);
; 316  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 317  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 318  : #endif // _HAS_U8_INTRINSICS
; 319  :         } else
; 320  : #endif // __cpp_char8_t
; 321  :         {
; 322  :             return __builtin_strlen(_First);
; 323  :         }
; 324  : #else // _HAS_CXX17
; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 326  : #endif // _HAS_CXX17
; 327  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __2C3DAE68_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1261 :     void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1262 :         _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1263 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -48						; size = 4
__Lock$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1215 : inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1216 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1217 :     _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1218 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1219 : 
; 1220 :     _Container_proxy* _Temp = _Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$[ebp], ecx

; 1221 :     _Myproxy                = _Right._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1222 :     _Right._Myproxy         = _Temp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Temp$[ebp]
	mov	DWORD PTR [eax], ecx

; 1223 : 
; 1224 :     if (_Myproxy) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Swap_proxy

; 1225 :         _Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
$LN2@Swap_proxy:

; 1226 :     }
; 1227 : 
; 1228 :     if (_Right._Myproxy) {

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Swap_proxy

; 1229 :         _Right._Myproxy->_Mycont = &_Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@Swap_proxy:

; 1230 :     }
; 1231 : }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Swap_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN8@Swap_proxy:
	DD	1
	DD	$LN7@Swap_proxy
$LN7@Swap_proxy:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN5@Swap_proxy
$LN5@Swap_proxy:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$2 = -48						; size = 4
__Lock$3 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1201 : inline void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1202 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1203 :     if (_Myproxy) { // proxy allocated, drain it

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_all

; 1204 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1205 : 
; 1206 :         for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$2[ebp], ecx
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$2[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_all

; 1207 :             (*_Pnext)->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0

; 1208 :         }

	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1209 : 
; 1210 :         _Myproxy->_Myfirstiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 1211 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Orphan_all:

; 1212 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1213 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN7@Orphan_all
$LN7@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1088 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Container_base12@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Container_base12@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Container_base12@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1080 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont_$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 986  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Convert_size@I@std@@YAII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 987  :     // convert size_t to size_t, unchanged
; 988  :     return _Len;

	mov	eax, DWORD PTR __Len$[ebp]

; 989  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Convert_size@I@std@@YAII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Convert_size@I@std@@YAII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 106  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 107  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 108  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN7@Adjust_man
	jmp	SHORT $LN2@Adjust_man
$LN7@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN2@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN4@Adjust_man

; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN13@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN13@Adjust_man
	jmp	SHORT $LN8@Adjust_man
$LN13@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0GI@JKOMEBKC@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1NA@OANNLGA@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN8@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN10@Adjust_man

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax], ecx

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 50   :     _DECLSPEC_ALLOCATOR static void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B1B75AB9_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 51   :         return ::operator new(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 52   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 322  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __CB7CF65A_exception
	call	@__CheckForDebuggerJustMyCode@4

; 323  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Throw_bad_:

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_array_new_length@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 138  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_array_new_length@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 137  :         : bad_alloc("bad array new length")

	push	OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@AAE@QBD@Z		; std::bad_alloc::bad_alloc

; 138  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 139  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0bad_array_new_length@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_array_new_length@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 127  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@AAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 126  :         : exception(_Message, 1)

	push	1
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 127  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 128  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0bad_alloc@std@@AAE@QBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@AAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1exception@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 87   :         __std_exception_destroy(&_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_destroy
	add	esp, 4

; 88   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0exception@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 68   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 71   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0exception@std@@QAE@QBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __CFCEF810_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 62   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 64   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 65   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@QBDH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@QBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 557  :     _NODISCARD static constexpr int(max)() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?max@?$numeric_limits@H@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __CDF80030_limits
	call	@__CheckForDebuggerJustMyCode@4

; 558  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 559  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?max@?$numeric_limits@H@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?max@?$numeric_limits@H@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??2@YAPAXIPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __BD3EDE1B_vcruntime_new@h
	call	@__CheckForDebuggerJustMyCode@4

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 171  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??2@YAPAXIPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??2@YAPAXIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Platformer\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\CPPGame-a38d0db726ab2ff89afdd02c18394bd0c58340c9\PlatformerGame\src\GameEngine\Texture.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __2ED228C6_Texture@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
